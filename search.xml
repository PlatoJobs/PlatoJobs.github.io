<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>职场实习攻略</title>
    <url>/2009/07/10/%E8%81%8C%E5%9C%BA%E5%AE%9E%E4%B9%A0%E6%94%BB%E7%95%A5/</url>
    <content><![CDATA[<blockquote>
<p>相信很多同学在第一次到企业实习的时候都会不知所措，心里激情满满，却发现自己大脑是晕晕的。别，小二这就给您上菜，听我慢慢道来。</p>
</blockquote>
<h5 id="开篇之前问题"><a href="#开篇之前问题" class="headerlink" title="﻿开篇之前问题"></a>﻿开篇之前问题</h5><p><code>问：我是一名应届生，我应该如何做职业规划？</code></p>
<blockquote>
<p>答：职业规划和理财很像，首先你得有才。所以对应届生来说，尽可能提升自己的能力才是当务之急。在行业选择上，可以选择一些正在得到大量投资的行业，通常而言，它们代表了未来的发展方向，比如云计算、大数据、移动互联网、智能硬件、共享经济、互联网金融等。</p>
</blockquote>
<p><code>问：学历在求职中重要吗？</code></p>
<blockquote>
<p>答：一般创业公司不会对候选人学历设限制，但类似BAT之类的上市公司通常会有一个本科学历的门槛。这个门槛并不是绝对的，如果你的直接上级愿意帮你去申请特批，还是可以通过的，但是这要求你的能力足够出众。另外，如果你有同等级的公司背景，学历也是可以忽略的，当你有腾讯的工作经历的时候，就没有太多人在乎你的大专学历了。</p>
</blockquote>
<p><code>问：我工作的公司很一般，如何写简历才好？</code></p>
<blockquote>
<p>答：技术招聘一般看两个点，一个<br>是经历证明，一个是能力证明。如果你之前的公司很一般，那么你在经历证明上就相对弱势。这种时候需要想办法提升自己的能力证明。代码是程序员能力最好的证明，所以辛苦一点，把每天睡觉看美剧刷微博的时间挤一挤，努力写一个代码可以见人的开源项目出来吧，这一点就可以帮你超过九成的竞争对手。</p>
</blockquote>
<p><code>问：我是一个新手，在公司没有人带我，得不到成长，如何才能换一个有大牛带的公司？</code></p>
<blockquote>
<p>答：做两手准备。大部分有大牛的公司并不喜欢带一个什么都不懂的新手，当然有运气好的，但是我们不能把自己的职业发展建立在运气上。所以当你遇到这种机会时，要义无反顾地跳过去；但当你没有遇到这样的机会时，也不要抱怨，记住在编码这件事上，别人其实帮不了你太多。去GitHub看开源代码，到StackOverflow去问问题，学会自己成长。只有这样你才能真正独当一面。</p>
</blockquote>
<p><code>问：我是一名PHP程序员，我想转到C方向去做更底层的开发，怎么才能找到这样的机会？</code></p>
<blockquote>
<p>答：转型是我们遇到比较多的问题，很多同学都想找一家新公司，选一个新方向，有一个新开始，但其实招聘方更愿意培养应届生，因为他们的成长期比较长，能在公司长久稳定，对薪资的要求也低一些。所以如果你不是应届生，那么你需要在你想转型的方向上进行预投入，才能增加竞争力。最理想的方式就是从当前的方向和你想要转的方向找到一个交叉点，以此为基础来转型。如果是从PHP转到C，完全可以从PHP扩展切入。这样可以保证你在PHP方向的经验不会白费，又满足了向系统层逐步深入的愿望。</p>
</blockquote>
<p>图片发自简书App</p>
<h5 id="入职之前应当做好的准备"><a href="#入职之前应当做好的准备" class="headerlink" title="入职之前应当做好的准备"></a>入职之前应当做好的准备</h5><p>入职之前应该和公司的HR或行政或同部门前辈了解一下公司的衣着风格（dressing code），尽量干净整洁、符合统一的步调。比如在金融类公司或者老牌外企一般穿商务正装比较好，但是在一些比较自由的互联网公司里如果你穿一身西装就有些奇怪了。﻿</p>
<p>提前熟悉办公设备和软件，比如大型复印机。这个在《令人心动的offer》里面恰好也有体现，人大的学霸李浩源差点把复印机搞坏，我自己也是在实习第一天的时候学习了大型复印机的使用方法，尤其是扫描，因为各个公司的扫描设置可能不同，有的是扫描后发到邮箱，有的是到公共盘，有的是需要用U盘。不管哪一种，最好是有机会学习一下，比如在学校复印的时候可以问问看，也多观察一下。﻿</p>
<p>提前熟悉好office软件，虽说好多同学的简历上都写熟练操作，但是每个人对“熟练”的理解还是不太一样的。比如excel的pivot、mailing、查重、合并等功能和vlookup、if、sum等函数都是很实用的，最好找机会提前练习一下。还有word的目录设置、排版、PPT的各种对齐、outlook的发送和撤回、定时发送、会议邀请等等。比如何运晨在节目中的办公软件操作习惯就非常好。﻿</p>
<h5 id="入职当天可能要做的事"><a href="#入职当天可能要做的事" class="headerlink" title="入职当天可能要做的事"></a>入职当天可能要做的事</h5><p>一般刚入职都会被引导到一个统一的地点签署实习协议和发放办公设备，并进行内部账号、邮箱等配置，一定要记好自己的各类账号密码哦。﻿</p>
<p>还有证明你是这个公司的人的东西啦，比如员工卡、门禁卡、餐卡（如果有餐厅不要太幸福哦）、班车卡（有班车不要太幸福哦）等等。﻿</p>
<p>接下来通常会有公司的入职培训，一般是会进行对公司、各个部门、文化氛围及活动和重要规章制度的介绍等等，要注意听讲哦。:-)﻿</p>
<p>然后就是同部门的前辈会带你去认识下日常工作的上下游，以及向同部门的同事进行介绍啦，一方面不要害羞，好好介绍自己，另一方面要尽量记住同事的名字和脸哦，记不住的话可以回头画个工位图，跟带你的前辈确认好名字，没事儿就观察一下，自然就记住啦。﻿</p>
<h5 id="入职之后应该养成的优秀工作习惯"><a href="#入职之后应该养成的优秀工作习惯" class="headerlink" title="入职之后应该养成的优秀工作习惯"></a>入职之后应该养成的优秀工作习惯</h5><p>文件要记得经常备份，无论是办公软件（随手ctrl+s，再多存几个副本）还是纸质文件，以防丢失。﻿</p>
<p>如果可能的话与外部门同事正式沟通时尽量避免一对一，一来此时经验不足，二来以防双方对讨论结果的理解不同导致以后工作出问题。﻿</p>
<p>记得经常和带你的前辈沟通，开始做什么事情之前一定要让前辈知晓。﻿</p>
<p>沟通时注意沟通的时机，尽量找对方的工作空隙沟通，提前组织好语言，每次沟通占用时间不超过5分钟为宜。﻿</p>
<p>养成做日程计划的能力，有deadline意识，开始练习时间的管理规划。好比北大的选手梅桢同学在接到任务的第一时间就会去确认提交报告的时间。﻿</p>
<p>遇到不明白的事情，百度（一定要养成自己先调查一下的习惯）、问前辈、偷偷观察前辈做法都是可以的，但是切忌不懂装懂。﻿</p>
<p>要有眼力见儿但不要乱接活儿，以防给你的直接领导带来麻烦。﻿</p>
<p>不八卦不传谣，遵守公司的保密原则。﻿</p>
<p>和同事保持适当的距离感，每个人都有自己的工作。﻿</p>
<p>刚开始工作从小事做起，不积跬步无以至千里，不要好高骛远。﻿</p>
<p>入职之后应该养成的优秀工作习惯（进阶篇）</p>
<p>就一个问题准备多种方案，并作出对比（方便领导决策），主动找领导讨论。﻿</p>
<p>通过回顾经历（错的对的都回顾）进行复盘总结，分析自己的优劣势，对自己的工作水平保持清醒的认知。﻿</p>
<p>工作要以结果导向为主，过程导向为辅。重要的是你做成了什么，而不是你做了什么，每个人背后都做了很多工作，过程不是你的借口。﻿</p>
<p>提升团队意识，记住自己不是独立的作战单元。你需要独立工作，尽量独当一面，但是遇到问题一定要思考着是不是你一个人要解决的问题，没有人能够解决所有问题的。一个人非要承担整个团队的问题，而团队其他人不知道的话很容易出岔子。﻿</p>
<p>保持关注行业新闻，把握动向，坚持持续地学习。﻿</p>
<h5 id="心理准备"><a href="#心理准备" class="headerlink" title="心理准备"></a>心理准备</h5><p>正视自己和前辈要求之间的差距，有差距意味着你在当前的岗位上还有充分的成长空间。﻿</p>
<p>正视自己假想的职场和真实职场之间的差距，别因为这些不同沮丧。﻿</p>
<blockquote>
<p>以上，祝实习愉快，顺利转正！哎，哎，哎，还没给钱呢！！说的就是你！</p>
</blockquote>
]]></content>
      <categories>
        <category>职场</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title>当年万里觅封侯</title>
    <url>/2009/09/10/%E5%BD%93%E5%B9%B4%E4%B8%87%E9%87%8C%E8%A7%85%E5%B0%81%E4%BE%AF/</url>
    <content><![CDATA[<h5 id="诉衷情·当年万里觅封侯"><a href="#诉衷情·当年万里觅封侯" class="headerlink" title="诉衷情·当年万里觅封侯"></a><strong>诉衷情·当年万里觅封侯</strong></h5><p><strong>宋代：陆游</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br>当年万里觅封侯，匹马戍梁州。<br><br>关河梦断何处？尘暗旧貂裘。<br><br>胡未灭，鬓先秋，泪空流。<br><br>此生谁料，心在天山，身老沧洲。<br><br></code></pre></td></tr></table></figure>
<blockquote>
<p>译文<br>回想当年为了建功立业驰骋万里，单枪匹马奔赴边境戍守梁州。如今防守边疆要塞的从军生活只能在梦中出现，梦一醒不知身在何处？唯有曾穿过的貂裘，已积满灰尘变得又暗又旧。<br>胡人还未消灭，自己的双鬓却早已白如秋霜，只能任忧国的眼泪白白地流淌。谁能料我这一生，心始终在前线抗敌，人却老死在沧洲！</p>
</blockquote>
<p><code>注释</code><br><code>诉衷情</code>：词牌名。<br><code>万里觅封侯</code>：奔赴万里外的疆场，寻找建功立业的机会。<br><code>戍（shù</code>）：守边。<br><code>梁州</code>：治所在南郑。陆游著作中，称其参加四川宣抚使幕府所在地，常杂用以上地名。<br><code>关河</code>：关塞、河流。一说指潼关黄河之所在。此处泛指汉中前线险要的地方。梦断：梦醒。<br><code>尘暗旧貂裘</code>：貂皮裘上落满灰尘，颜色为之暗淡。这里借用苏秦典故，说自己不受重用，未能施展抱负。<br><code>胡</code>：古泛称西北各族为胡，亦指来自彼方之物。南宋词中多指金人。此处指金入侵者。<br><code>鬓</code>：鬓发。秋：秋霜，比喻年老鬓白。<br><code>天山</code>：在中国西北部，是汉唐时的边疆。这里代指南宋与金国相持的西北前线。<br><code>沧洲</code>：靠近水的地方，古时常用来泛指隐士居住之地。这里是指作者位于镜湖之滨的家乡</p>
<h3 id="赏析"><a href="#赏析" class="headerlink" title="赏析"></a>赏析</h3><p>　　此词描写了作者一生中最值得怀念的一段岁月，通过今昔对比，反映了一位爱国志士的坎坷经历和不幸遭遇，表达了作者壮志未酬、报国无门的悲愤不平之情。上片开头追忆作者昔日戎马疆场的意气风发，接写当年宏愿只能在梦中实现的失望；下片抒写敌人尚未消灭而英雄却已迟暮的感叹。全词格调苍凉悲壮，语言明白晓畅，用典自然，不着痕迹，不加雕饰，如叹如诉，有较强的艺术感染力。</p>
<p>　　“当年万里觅封侯，匹马戍梁州”，开头两句，词人再现了往日壮志凌云，奔赴抗敌前线的勃勃英姿。“当年”，指1172年（乾道八年），在那时陆游来到南郑（今陕西汉中），投身到四川宣抚使王炎幕下。在前线，他曾亲自参加过对金兵的遭遇战。“觅封候”用班超投笔从戎、立功异域“以取封侯”的典故，写自己报效祖国，收拾旧河山的壮志。“自许封侯在万里”（《夜游宫·记梦寄师伯浑》），一个“觅”字显出词人当年的自许、自负、自信的雄心和坚定执着的追求精神。“万里”与“匹马”形成空间形象上的强烈对比，匹马征万里，“壮岁从戎，曾是气吞残虏”（《谢池春·壮岁从戎》），呈现出一派卓荦不凡之气。“悲歌击筑，凭高酹酒”（《秋波媚·七月十六日晚登高兴亭望长安南山》），“呼鹰古垒，截虎平川”（《汉宫春·初自南郑来成都作》），那豪雄飞纵、激动人心的军旅生活至今历历在目，时时入梦，之所以会这样，是因为强烈的愿望受到太多的压抑，积郁的情感只有在梦里才能得到宣泄。</p>
<p>　　“关河梦断何处，尘暗旧貂裘”，在南郑前线仅半年，陆游就被调离，从此关塞河防，只能时时在梦中达成愿望，而梦醒不知身何处，只有旧时貂裘戎装，而且已是尘封色暗。一个“暗”字将岁月的流逝，人事的消磨，化作灰尘堆积之暗淡画面，心情饱含惆怅。</p>
<p>　　上片开头以“当年”二字楔入往日豪放军旅生活的回忆，声调高亢，“梦断”一转，形成一个强烈的情感落差，慷慨化为悲凉。至下片则进一步抒写理想与现实的矛盾，跌入更深沉的浩叹，悲凉化为沉郁。</p>
<p>　　“胡未灭，鬓先秋，泪空流。”这三句步步紧逼，声调短促，说尽平生不得志。放眼西北，神州陆沉，残虏未扫；回首人生，流年暗度，两鬓已苍；沉思往事，雄心虽在，壮志难酬。“未”“先”“空”三字在承接比照中，流露出沉痛的感情，越转越深：人生自古谁不老？但逆胡尚未灭，功业尚未成，岁月已无多，这才迫切感到人“先”老之酸楚。“一事无成霜鬓侵”，一股悲凉渗透心头，人生老大矣。然而，即使天假数年，双鬓再青，也难以实现“攘除奸凶，兴复汉室”的事业。“朱门沉沉按歌舞，厩马肥死弓断弦”，“云外华山千仞，依旧无人问”。所以说，这忧国之泪只是“空”流，一个“空”字既写了内心的失望和痛苦，也写了对君臣尽醉的偏安东南一隅的小朝廷的不满和愤慨。</p>
<p>　　“此生谁料，心在天山，身老沧洲。”最后三句总结一生，反省现实。“天山”代指抗敌前线，“沧洲”指闲居之地，“此生谁料”即“谁料此生”。词人没料到，自己的一生会不断地处在“心”与“身”的矛盾冲突中，他的心神驰于疆场，他的身却僵卧孤村，他看到了“铁马冰河”，但这只是在梦中，他的心灵高高扬起，飞到“天山”，他的身体却沉重地坠落在“沧洲”。“谁料”二字写出了往日的天真与此时的失望，“早岁那知世事艰”，“而今识尽愁滋味”，理想与现实是如此格格不入，无怪乎词人要声声浩叹。“心在天山，身老沧洲”两句作结，先扬后抑，形成一个大转折，词人犹如一心要搏击长空的苍鹰，却被折断羽翮，落到地上，在痛苦中呻吟。</p>
<p>　　陆游这首词，确实饱含着人生的秋意，但由于词人“身老沧洲”的感叹中包含了更多的历史内容，他的阑干老泪中融汇了对祖国炽热的感情，所以，词的情调体现出幽咽而又不失开阔深沉的特色，比一般仅仅抒写个人苦闷的作品显得更有力量，更为动人。</p>
<h4 id="赏析二"><a href="#赏析二" class="headerlink" title="赏析二"></a>赏析二</h4><p>　　陆游四十八岁，应四川宣抚使王炎之邀，从夔州前往当时西北前线重镇南郑（今陕西汉中）军中任职，度过了八个多月的戎马生活。　开篇两句，怀着自豪的心情回忆从戎南郑的生活。起处用“当年”二字领起，化实为虚，点出所叙系指往事。“觅封侯”，谓寻找杀敌立功以取封侯的机会。“匹马”既是纪实，也刻划出作者从军时的勃勃英姿。“戍梁州”，具体指出驻守的地方。南郑属古梁州，故曰。那是乾道八年（1172）的春天，陆游接到王炎的邀请书后，便匹马单身离开夔州，风尘仆仆地奔赴前线，去任“四川宣抚使司干办公事兼检法官”。当时他十分兴奋，希望能在万里边防线上找到杀敌报国的机会。来到南郑之后，他身披铁甲，跨上战马，腰悬利剑，手挽长枪，冒着酷暑严寒，踏着崎岖坎坷的山路，奔驰于岐渭蜀陇之间，调查地形，了解敌情，积极为北伐进行准备。他曾向王炎陈进取之策，对收复失地、统一祖国充满了胜利的信心。诗人回忆这段生活，是为了与后文对照，揭示英雄末路的悲哀。</p>
<p>　　“关河”两句一转，回笔描写现实。杀敌报国的理想破灭了，而今只有在梦中才能重返前线。可是梦醒之后，一切都消失了，那雄伟险峻的关山江河又在什么地方呢？只有当年从军时穿过的那件“旧貂裘”，积满灰尘，还挂在墙上，作为“匹马戍梁州”的纪念。陆游对这件“旧貂裘”十分珍视，因为他曾穿着它在前线冲锋陷阵：“貂裘半脱马如龙，举鞭指麾气吐虹。”（《醉歌》）还穿着它在荒滩上亲手剌死过一只猛虎：“百骑河滩猎盛秋，至今血溅短貂裘”。（《醉歌》）所以当他离开南郑后，一直把它藏在身边保存着。“旧貂裘”是此篇中唯一展现在作者眼前的物象，虽然词中只用一句轻轻带过，但却是理解此词的关键。原来诗人是睹物伤情，因见貂裘而引起对往事的回忆和感慨。也可以说，“旧貂裘”是这首词灵感的触媒。</p>
<p>　　换头三句，紧承上片结拍，写梦醒后的悲凉心情。“胡未灭”，谓入侵中原的金人尚未被消灭，半壁河山还在敌寇的铁蹄蹂躏之下；“鬓先秋”，慨叹自己发如秋霜，年迈体衰，不能重返前线；“泪空流”，是说壮志成空，忧国忧民的眼泪等于白流。这里连用“未”、“先”、“空”三个虚词，表达作者对现实的幻灭感，一唱一叹，感人至深。 “未”表达了作者逆胡（金入侵者）没有消灭，功业没有建成，感到无比遗恨之情；“先”表达了作者岁月不多，两鬓已苍，雄心虽在，壮志难酬的沉痛之情；“空”表达了作者对朝廷的不满和愤慨，内心的失望和痛苦之情。</p>
<p>　　最后三句，通过自身的遭遇反映现实和理想的矛盾，抒发对南宋统治集团误国误民政策的无比愤慨。谁会料到，像他这样一生志在恢复中原，时刻准备奔赴疆场，为国献身的人，却落得如此下场！此时被罢官回乡，只得披上渔蓑，去作江边的无名隐士，终老于镜湖之滨了。这种“心在天山，身老沧洲”的矛盾，不仅体现在陆游身上，南宋许多爱国志士同样也有切身的体验。因此陆游所抒发的悲愤之情，具有一定的代表性。梁启超《读陆放翁集》（之二）说：“辜负胸中十万兵，百无聊赖以诗名。谁怜爱国千行泪，说到胡尘意不平。”这首词虽然没有从正面揭露和谴责南宋投降派，仅就个人的身世经历和遭遇而言，但通过诗人饱含热泪的诉说，不难看到投降派迫害爱国志士的罪行，从而激起读者对他们的愤恨。</p>
<p>　　此篇语言明白晓畅，用典自然，不着痕迹，感情自胸臆流出，不加雕饰，如叹如诉，沉郁苍凉，有较强的艺术感染力，是陆游爱国词作的名篇之一。<code>▲</code></p>
<blockquote>
<p>创作背景<br>公元1172年（<code>宋孝宗乾道八年</code>），陆游在西北前线重镇南郑军中任职，度过了八个多月的戎马生活。公元1189年（<code>淳熙十六年</code>）陆游被弹劾罢官后，退隐山阴故居长达十二年。这期间写下了一系列爱国诗词。这首<code>《诉衷情》</code>是其中的一篇，具体创作时间不详。</p>
</blockquote>
]]></content>
      <categories>
        <category>文学</category>
        <category>宋词</category>
      </categories>
      <tags>
        <tag>陆游</tag>
      </tags>
  </entry>
  <entry>
    <title>贪官忏悔录里套路多:打虚假感情牌 摆出身讲贡献</title>
    <url>/2011/07/20/%E8%B4%AA%E5%AE%98%E5%BF%8F%E6%82%94%E5%BD%95%E9%87%8C%E5%A5%97%E8%B7%AF%E5%A4%9A/</url>
    <content><![CDATA[<p>“我是农民的儿子”“我已违纪违法,党永远是我心中的红太阳,照耀我走到人生尽头”……写忏悔录是违纪党员干部接受组织审查时进行思想改造的重要环节,其主要内容是问题官员对自己的理想、信念进行深刻反思。许多忏悔录内容深刻,对其他党员干部起到明显的警示教育作用。但《新华每日电讯》记者梳理发现,有部分忏悔录的模式化、套路化表达令人啼笑皆非,各种“套话”充斥其间。<br>专家认为,忏悔录频现“套话”,既与落马官员存在“减轻惩处”的侥幸心理有关,也与部分官员表达能力退化、“两面官员”习惯表演等因素有关。种种“套路”,客观上削弱了反腐败成果的警示教育作用。<br>忏悔录里“套路”多<br>落马官员在忏悔录中既空洞又虚假的表达,没有真正对自己违法乱纪行为进行反思,也无法起到警示作用<br>党的十八大以来,一批腐败分子被查处,许多地方和部门也付出了高昂的反腐成本。为了不让代价白付,很多地方都将问题官员撰写的忏悔录作为警示学习材料。每一份忏悔录,都是用违纪干部的惨痛教训换来的,应该最大限度挖掘它们的价值。<br>比如,朱明国、金道铭等人的忏悔录和检讨材料,就在党员干部中引发较大反响。中纪委宣传部、中央电视台联合制作的8集专题片《永远在路上》,更是成为一大热点话题,对党员干部起到了巨大的警示教育作用。<br>与此同时,各地都不断公布当地查处的党员干部的忏悔录和警示教育片,也起到了相应作用。但《新华每日电讯》记者梳理发现,有部分忏悔录充满了“套路”。<br>类型一,打虚假感情牌。中部某省一名落马厅级领导干部在忏悔录中说:“一路走来,我的每一步都沐浴着党组织的阳光,我感恩这一切。亲爱的党啊!我辜负了组织的期望,损坏了组织形象,我已经违纪违法了,不管走到哪里,党永远是我心中的红太阳,一直照耀着我走到人生尽头。”“亲爱的党啊!山高水长总有源,树高千尺总有根,我本来自人民,我多么渴望早点回到人民当中去。”<br>类似的话语,在各种忏悔录中并不少见。一名业内人士表示,落马官员在忏悔录中既空洞又虚假的表达,没有真正对自己违法乱纪行为进行反思,也无法起到警示作用。<br>类型二,找客观理由。一些违法乱纪的党员干部,会在忏悔录中找各种客观理由,为自己的不法行为开脱。有的党员干部称,社会风气和“潜规则”是自己违法乱纪的主要原因之一。有的党员干部将“交友不慎”作为重要因素,对内因却分析过少。<br>浙江省宁波市一名落马局长在忏悔录中分析,交友不慎是他走上不归路的致命一击,自己交友时缺乏原则,让“狐朋狗友”把自己送上了绝路。一名落马厅级干部则将自己腐化堕落原因归于“受封建文化糟粕和西方腐朽生活方式影响严重”,为了解释这一原因,他在忏悔录中说自己“去西方国家的机会较多,出访过程中阅读了大量现当代西方主要性学专家的著作,浏览了大量成人网站,并参加成人话题的网聊,体验了他们的性文化,对他们开放的生活方式羡慕不已。”<br>类型三,摆出身、讲贡献。有的违法乱纪的党员干部强调自己穷苦的出身,有的党员干部不断强调自己在行业领域的突出贡献,因为心理失衡导致“犯错”。一名地理测绘系统的厅级官员在忏悔录中说:“我把一个落后地区的测绘工作带到了全国前列,每年服务总值以2位数百分比增长,职工收入逐年增加,下属院领导绩效更是水涨船高……我心里有点失衡……”<br>八股文式忏悔录土壤何在<br>长期身处某种话语体系里,习惯于“权力代办”,出门有公车,讲话稿有秘书……使得部分党员干部出现“低能现象”,养成了满嘴“套话”的话语习惯<br>一名纪检监察系统工作人员表示,接受组织审查期间,被审查人要学习党章党规党纪,对照理想信念宗旨进行深刻反省,然后写出忏悔和反思材料。部分党员干部因各种原因和心态问题,导致忏悔录中出现了大量“套话”。<br>他们在忏悔录中自我剖析时几乎是同一个模式:没有加强对世界观、人生观和价值观的改造；没有加强学习和严格要求自己；没有把握党组织对自己的提醒和挽救。尽管这些原因的剖析都有道理,但许多党员干部对自身权力为何失去监督,为何没守住腐败防线等原因却谈得很少,有些人甚至完全没有分析。<br>一是希望减轻罪罚。一名纪检监察系统工作人员分析认为,部分违法乱纪的党员干部将忏悔录当作“救命稻草”,在忏悔录里展现良好的认罪、悔罪态度,渴望争取司法机关减轻处罚的机会。正因为夹杂着这些功利因素,他们在忏悔录中表达的感情不够真实,出现了“雷人”语言或“套话”。有的落马官员甚至声称自己“不懂法”“法律意识淡薄”等,其真实目的是企图逃避党纪国法制裁。<br>一位办案人员说,为了博取同情,美化形象,不少落马官员往往在忏悔录中花大量篇幅谈自己最初如何廉洁奉公。一所高校的原基建处长,在一篇仅千余字的忏悔录中,不惜以二三百字篇幅阐述自己当初如何“努力工作”、如何“拒绝他人钱物、吃请”。<br>二是干部“低能现象”出现。长期身处某种话语体系里,习惯于“权力代办”,出门有公车,讲话稿有秘书……使得部分党员干部出现“低能现象”,养成了满嘴“套话”的话语习惯。因此,在忏悔录中,一些违法乱纪的党员干部不懂得如何表达自身的感受,而是按习惯性的话语体系进行表达,使人感觉像是说“官话”。<br>应避免忏悔“套路化”<br>“真正的悔罪,应该从本人真实情况出发,从体制机制层面反思,帮助党和政府防范类似腐败现象。”<br>十八届中央纪委七次全会明确提出,要深刻剖析典型案件,忏悔录能公开的都要公开,充分发挥反面教材作用。然而,《新华每日电讯》记者在采访中了解到,作为涉腐官员用惨痛教训换来的忏悔录,由于不少内容过于模式化、趋同化,导致其警示教育效果大打折扣。<br>专家认为,忏悔录是对党员干部警示教育的重要载体之一,忏悔录频现官话套话的现象应尽力避免,要让忏悔录发挥最大警示教育的作用,最大限度实现忏悔的真实化、真诚化、深度化。<br>“当前防腐拒腐的警示教育宣传中,文字材料、音像制品的忏悔录,都是非常重要的载体。忏悔录的内容和态度如果含有官话套话式的‘官僚气息’,则肯定无法起到让其他党员干部振聋发聩的作用,也就难以‘治病救人’。”一名纪检干部称。<br>一些受访纪检干部认为,贪官忏悔录中总是出现千篇一律的表达,一方面暴露出其为抓住忏悔录这“最后一根稻草”的焦灼心态,并以此为遮羞布,掩饰腐化堕落后内心的不堪,为自己推脱罪责。<br>另一方面,更为深层次的原因则是,由于不少“两面贪官”长期以来形成的行为模式的惯性使然,以至虽身陷囹圄仍不忘作秀表演,因而即使党纪国法严惩在即,落马官员在忏悔录中仍改不了说大话、套话、假话的习性。<br>“这样的忏悔录,既无法让其他仍在位的党员领导干部灵魂受到触动、受到教育,反而让人觉得虚伪,甚至可能引发反感。”江西省犯罪学研究会副秘书长颜三忠说,“真正的悔罪,应该从本人真实情况出发,从体制机制层面反思,帮助党和政府防范类似腐败现象。”</p>
]]></content>
      <categories>
        <category>时事评论</category>
      </categories>
      <tags>
        <tag>时政</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello GitHub HomePage</title>
    <url>/2017/11/24/2017-11-24/</url>
    <content><![CDATA[<p>It was the end of November,more than a month after ourreturn from Baskerville Hall.Holmes and I were sitting on either side of a bright fire in our sitting room in Baker Street.Since our return,Holmes had been working hard on two other cases,and he had been too busy to discuss the Baskerville case.But now the other cases were finished,and he had been successful in both of them.I decided it was a good time to ask him the final questions about Stapleton and the hound.</p>
<p>‘The picture showed us that Stapleton was indeed a Baskerville,’Holmes began.’He was the son of Roger Baskerville,who was Sir Charles’younger brotner.Roger was a criminal who escaped from prison and ran away to South America.Everyone thought he had died unmarried,but that was not true.He had one son,also called Roger,whom we knew as Stapleton.Stapleton married a beautiful South Ameri can,and came to England,where he started a school in the north.He discovered that he would inherit the Baskerville lands and fortune if Sir Charles and Sir Henry both died.That is why he moved to Devonshire when the school closed.</p>
<p>‘When he met Sir Charles,he heard the story of the hell hound.He also learned that Sir Charles believed these super natural stories,and that he had a weak heart.</p>
<p>‘Stapleton had the idea of buying a huge hound,and of using the phosphorus to make it shine like the hound in the story.I have found the place where he bought the animal.He took it by train to Devonshire and walked many miles over the moors with it so that it would not be seen near Baskerville Hall.</p>
<p>‘He needed to get Sir Charles out of the Hall at night.This would be easy to do if his wife made Sir Charles fall in love with her.But,although he beat her,she refused to help him with his evil plan.</p>
<p>‘Then Stapleton met Laura Lyons.We know that he made her write a letter to bring Sir Charles to the moor gate on that sad night.The hound,which was shining with phosphorus,chased Sir Charles down the Yew Alley.Sir Charles’ terror was so great that his weak heart stopped,and he died,but the animal did not touch the dead body.</p>
<p>‘The hound had run on the grass,so it left no footprints,ex cept the one found by Dr Mortimer.You see how clever Staple ton was.Neither he nor the hound had touched Sir Charles so there was no sign of murder.The only two people who might suspect him—his wife and Mrs Lyons could not be certain about what he had done.Anyway,neither of them would in form the police about him.</p>
<p>‘Next,Stapleton learned that Sir Henry had reached Eng land,so he went to London.He hoped to murder Sir Henry there.He took his wife with him,but he wasn’t sure that she would keep his secret,so he did not tell her the truth.He locked her up in their hotel.She knew that he had some evil plan,but she was too frightened to give Sir Henry a clear warning.Instead,she sent him the letter made of words cut from a newspaper.</p>
<p>‘Meanwhile,Stapleton was wearing a false beard and fol lowing Sir Henry.He needed something to give the hound Sir Henry’s scent,so he paid a maid at Sir Henry’s hotel to steal one of his shoes The first one was a new one,and didn’t have Sir Henry’s scent on it.It was no use for the hound,so he put it back,and another,older,shoe was stolen.When the shoes were changed,I knew that the hound must be a natural and not a supernatural creature.</p>
<p>‘Next there was the letter made of words cut from a news paper.When I looked at it,I held it close to my eyes.I noticed a smell of perfume,so I guessed that a woman had sent the let ter.</p>
<p>‘By the time I went to Devonshire I knew that there was a real hound,and I knew we were looking for a man and a wom an.I guessed that the Stapletons were the pair.I had to watch Stapleton,but I had to hide myself As I have explained.I could not tell you what I was doing.I stayed in Newtown and used the hut on the moor only when necessary.</p>
<p>‘Your letters were sent to me immediately from Baker Street,and were very helpful.When you told me that Stapleton had owned a school in the north of England.I checked on him and where he had come from.I discovered he had come from South America.And then everything became clear.</p>
<p>‘By the time you found me on the moor,I knew everything,but I could prove nothing.We had to catch the man doing something criminal,and so I had to put Sir Henry in danger.</p>
<p>‘Dr Mortimer tells me that Sir Henry will be completely better after some rest.As you know,the two of them have be come good friends,and are going on a long holiday together.Sir Henry will take some time to forget Miss Stapleton.He loved her deeply and it hurt him badly when he learned the truth about her.</p>
<p>‘She was very frightened of her cruel husband,but she sus pected that he was responsible for Sir Charles’ death.She knew about the hound,and when Selden died she guessed that the hound had killed him.She knew her husband had the hound at their house on the night Sir Henry came to dinner.They argued about the hound that evening,and as they argued Stapleton told her about Mrs Lyons.Any love she had for her husband disappeared at that moment.He knew that she want ed to help Sir Henry,so he beat her and tied her up.</p>
<p>‘He probably hoped that when he inherited the Baskerville lands,she would love him again.He certainly thought that she would keep silent if she became Lady Baskerville.But I think he was wrong.He had been too cruel to her.She could not for give him or love him again,nor,I think,allow him to enjoy the results of his crime.<br><img src="/img/q1.jpg" alt=""><br>‘Of course,he could not frighten Sir Henry in the same way as Sir Charles.Sir Henry was a young and healthy man.So he kept the hound hungry.He knew that the animal would either kill Sir Henry or would hurt him so badly that it would be easy to complete the murder.’</p>
<p>I had one last question for Holmes.’But Stapleton was living so close to Baskerville Hall and using a false name.It looked very strange.How would he explain that to the police,if after Sir Henry’s death he then inherited the Baskerville lands and fortune?’</p>
<p>‘I don’t know how he planned to explain the false name and why he was living at Pen House,’said Holmes.’I can only say that he was a very clever man.I am sure he had thought of an answer to the problem.</p>
<p>‘But that’s enough work for the evening,Watson.I have two tickets for the theatre.If we get ready now,we shall have time to stop at my favourite restaurant for some dinner on the way.’</p>
]]></content>
      <categories>
        <category>历史</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo的Replica主题</title>
    <url>/2019/11/10/Hexo%E7%9A%84Replica%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Replica"><a href="#Replica" class="headerlink" title="Replica "></a>Replica <a href="https://opensource.org/licenses/MIT"><img src="https://img.shields.io/badge/LICENSE-MIT-blue.svg" alt="LICENSE MIT"></a></h1><p>Github style replication for hexo theme. </p>
<p>Just in case you are working in the office but suddenly have some genius ideas. :two_hearts:<br><a href="//sabrinaluo.github.io/tech">Click here to view the demo site</a></p>
<p>Issues &amp; Contributions are welcome! :stuck_out_tongue:</p>
<h2 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h2><h4 id="v1-0"><a href="#v1-0" class="headerlink" title="v1.0"></a>v1.0</h4><p>Github UI before 2017, which uses the grey navbar</p>
<h4 id="v2-0-in-progress"><a href="#v2-0-in-progress" class="headerlink" title="v2.0 (in progress)"></a>v2.0 (in progress)</h4><p>Github UI in 2017, which uses the black navbar</p>
<h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><h4 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h4><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">git clone git@github.com:sabrinaluo/hexo-theme-<span class="hljs-keyword">replica</span>.git themes/<span class="hljs-keyword">replica</span><br></code></pre></td></tr></table></figure>
<p>or<br><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">git clone https://github.com/sabrinaluo/hexo-theme-<span class="hljs-keyword">replica</span>.git themes/<span class="hljs-keyword">replica</span><br></code></pre></td></tr></table></figure></p>
<h4 id="Configure"><a href="#Configure" class="headerlink" title="Configure"></a>Configure</h4><p>Set <code>theme: replica</code> in <code>_config.yml</code> (the one in your root folder)</p>
<p><strong>PLEASE NOTE</strong><br>Modifying <code>blog_root/themes/replica/_config.yml</code> directly is <strong>NOT</strong> recommended.<br>It’s suggested to configure your site through <code>blog_root/_config.yml</code> <strong>(root folder).</strong></p>
<p>Here is a sample of <code>blog_root/_config.yml</code></p>
<details>
<summary>CLICK ME</summary>
<p>

<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Hexo Configuration</span><br><span class="hljs-comment">## Docs: http://hexo.io/docs/configuration.html</span><br><span class="hljs-comment">## Source: https://github.com/hexojs/hexo/</span><br><br><span class="hljs-comment"># Site</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">My</span> <span class="hljs-string">Blog</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">My</span> <span class="hljs-string">Blog</span> <span class="hljs-string">Description</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">HiiTea</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br><span class="hljs-attr">timezone:</span> <span class="hljs-string">Asia/Shanghai</span><br><span class="hljs-attr">favicon:</span> <span class="hljs-string">https://assets-cdn.github.com/favicon.ico</span><br><br><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">http://sabrinaluo.com/tech</span><br><span class="hljs-attr">root:</span> <span class="hljs-string">/tech/</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span><br><span class="hljs-attr">permalink_defaults:</span><br><br><span class="hljs-comment"># Directory</span><br><span class="hljs-attr">source_dir:</span> <span class="hljs-string">source</span><br><span class="hljs-attr">public_dir:</span> <span class="hljs-string">public</span><br><span class="hljs-attr">tag_dir:</span> <span class="hljs-string">tags</span><br><span class="hljs-attr">archive_dir:</span> <span class="hljs-string">archives</span><br><span class="hljs-attr">category_dir:</span> <span class="hljs-string">categories</span><br><span class="hljs-attr">code_dir:</span> <span class="hljs-string">downloads/code</span><br><span class="hljs-attr">i18n_dir:</span> <span class="hljs-string">:lang</span><br><span class="hljs-attr">skip_render:</span><br><br><span class="hljs-comment"># Writing</span><br><span class="hljs-attr">new_post_name:</span> <span class="hljs-string">:year:month:day-:title.md</span> <span class="hljs-comment"># File name of new posts</span><br><span class="hljs-attr">default_layout:</span> <span class="hljs-string">post</span><br><span class="hljs-attr">titlecase:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># Transform title into titlecase</span><br><span class="hljs-attr">external_link:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Open external links in new tab</span><br><span class="hljs-attr">filename_case:</span> <span class="hljs-number">0</span><br><span class="hljs-attr">render_drafts:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">relative_link:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">future:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">highlight:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">auto_detect:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">tab_replace:</span><br><br><span class="hljs-comment"># Category &amp; Tag</span><br><span class="hljs-attr">default_category:</span> <span class="hljs-string">uncategorized</span><br><span class="hljs-attr">category_map:</span><br><span class="hljs-attr">tag_map:</span><br><br><span class="hljs-comment"># Date / Time format</span><br><span class="hljs-comment">## Hexo uses Moment.js to parse and display date</span><br><span class="hljs-comment">## You can customize the date format as defined in</span><br><span class="hljs-comment">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="hljs-attr">date_format:</span> <span class="hljs-string">YYYY-MM-DD</span><br><span class="hljs-attr">time_format:</span> <span class="hljs-string">HH:mm:ss</span><br><br><span class="hljs-comment"># Pagination</span><br><span class="hljs-comment">## Set per_page to 0 to disable pagination</span><br><span class="hljs-attr">per_page:</span> <span class="hljs-number">0</span><br><span class="hljs-attr">pagination_dir:</span> <span class="hljs-string">page</span><br><br><span class="hljs-comment"># Extensions</span><br><span class="hljs-comment">## Plugins: http://hexo.io/plugins/</span><br><span class="hljs-comment">## Themes: http://hexo.io/themes/</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">replica</span><br><br><span class="hljs-comment"># Google Analytics</span><br><span class="hljs-attr">ga:</span> <span class="hljs-comment"># GA code UA-XXXXXXXX-X</span><br><br><span class="hljs-comment">#marked setting for markdown</span><br><span class="hljs-attr">marked:</span><br>  <span class="hljs-attr">gfm:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">pedantic:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">sanitize:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">tables:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">breaks:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">smartLists:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">smartypants:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-attr">gcs:</span> <span class="hljs-comment"># GOOGLE CUSTOM SEARCH</span><br><span class="hljs-attr">baidutongji:</span> <span class="hljs-comment"># BAIDU TONGJI CODE</span><br><span class="hljs-attr">disqus:</span> <span class="hljs-comment"># DISQUS ID</span><br><br><span class="hljs-attr">location:</span> <span class="hljs-string">Hong</span> <span class="hljs-string">Kong</span><br><span class="hljs-attr">email:</span> <span class="hljs-string">xx@example.com</span><br><br><span class="hljs-attr">avatar:</span> <span class="hljs-string">https://avatars2.githubusercontent.com/u/5300359?v=4&amp;s=460</span><br><span class="hljs-attr">social:</span><br>  <span class="hljs-attr">github:</span> <span class="hljs-string">https://github.com/sabrinaluo</span><br>  <span class="hljs-attr">weibo:</span> <span class="hljs-string">http://weibo.com/206663121</span><br>  <span class="hljs-attr">linkedin:</span><br><br><span class="hljs-comment"># flagcounter</span><br><span class="hljs-attr">flagcounter_href:</span> <span class="hljs-comment"># https://info.flagcounter.com/xxxx</span><br><span class="hljs-attr">flagcounter_img_src:</span> <span class="hljs-comment"># https://s01.flagcounter.com/xxxx</span><br></code></pre></td></tr></table></figure>
#### Update
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> themes/replica<br>git pull<br></code></pre></td></tr></table></figure>
In case you want the old version with grey navbar
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> themes/replica<br>git checkout 1.0 <span class="hljs-comment"># AKA `git checkout -b 1.0 origin/1.0`</span><br></code></pre></td></tr></table></figure>
</p>
</details>

<h2 id="Available-Widgets"><a href="#Available-Widgets" class="headerlink" title="Available Widgets"></a>Available Widgets</h2><p><del>多说</del> (Duoshuo stopped the service since June, 2017)<br>百度统计<br>Disqus<br>Google Analytics<br>Google Custom Search Engine<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://cse.google.com/
">[1]</span></a></sup></p>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h4 id="Q-How-can-I-use-category-and-tag"><a href="#Q-How-can-I-use-category-and-tag" class="headerlink" title="Q: How can I use category and tag?"></a>Q: How can I use category and tag?</h4><p>A: Create below files under <code>source</code> folder:</p>
<p><code>blog_root/source/categories/index.md</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">categories</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2016-01-21 18:46:15</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure>
<p><code>blog_root/source/tags/index.md</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">tags</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2016-01-21 18:45:55</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>The MIT License<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://opensource.org/licenses/MIT
">[2]</span></a></sup></p>
<p>Copyright (c) 2015-2019 Hiitea <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#58;&#x6c;&#x75;&#111;&#x68;&#97;&#x6f;&#106;&#x69;&#110;&#103;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;">&#x6c;&#x75;&#111;&#x68;&#97;&#x6f;&#106;&#x69;&#110;&#103;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;</a></p>
<h2 id="Buy-me-coffee-yum"><a href="#Buy-me-coffee-yum" class="headerlink" title="Buy me coffee :yum:"></a>Buy me coffee :yum:</h2><p>BTC: 19U6USzi7WaFmY3DTkgn67EzYpTqZPNwRG<br><img src="https://user-images.githubusercontent.com/5300359/30433338-cb7a9e48-9996-11e7-8e17-55f582b56e48.png" alt="image"></p>
<p><a href="https://user-images.githubusercontent.com/5300359/53497706-baf13a00-3adf-11e9-8223-5aa1c63b8779.png"><img src="https://user-images.githubusercontent.com/5300359/53497706-baf13a00-3adf-11e9-8223-5aa1c63b8779.png" alt="Coffee Fund"></a></p>
<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://cse.google.com/">https://cse.google.com/</a>
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://opensource.org/licenses/MIT">https://opensource.org/licenses/MIT</a>
<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>主题</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS不规则圆角</title>
    <url>/2011/05/10/iOS%E4%B8%8D%E8%A7%84%E5%88%99%E5%9C%86%E8%A7%92/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/19168340-826ded794dbc796b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1.png"></p>
<blockquote>
<p>如上面的<code>开多</code>,<code>开空</code>按钮视图</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/19168340-86a25eab7d9dc340.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2.png"></p>
<blockquote>
<p><code>蓝色</code>视图的圆角，左下和右下圆角视图</p>
</blockquote>
<p>对于这种情况，<a href="https://stackoverflow.com/questions/2264083/rounded-uiview-using-calayers-only-some-corners-how">Stackoverflow</a>上提供了几种解决方案。其中最简单优雅的方案，就是使用<code>UIBezierPath</code>。下面给出一段示例代码。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">UIView</span> *view2 = [[<span class="hljs-built_in">UIView</span> alloc]initWithFrame:<span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">120</span>, <span class="hljs-number">10</span>, <span class="hljs-number">80</span>, <span class="hljs-number">80</span>)];<br>view2.backgroundColor = [<span class="hljs-built_in">UIColor</span> redColor];[<span class="hljs-keyword">self</span>.view addSubview:view2]; <br><span class="hljs-built_in">UIBezierPath</span> *maskPath = [<span class="hljs-built_in">UIBezierPath</span> bezierPathWithRoundedRect:view2.bounds byRoundingCorners:<span class="hljs-built_in">UIRectCornerBottomLeft</span> | <span class="hljs-built_in">UIRectCornerBottomRight</span> cornerRadii:<span class="hljs-built_in">CGSizeMake</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)];<br><span class="hljs-built_in">CAShapeLayer</span> *maskLayer = [[<span class="hljs-built_in">CAShapeLayer</span> alloc] init];<br>maskLayer.frame = view2.bounds;maskLayer.path = maskPath.CGPath;<br>view2.layer.mask = maskLayer;<br><br></code></pre></td></tr></table></figure>
<p>其中，<br><code>byRoundingCorners:UIRectCornerBottomLeft | UIRectCornerBottomRight</code></p>
<p>指定了需要成为圆角的角。该参数是UIRectCorner类型的，可选的值有：<br><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">NS_OPTIONS</span>(<span class="hljs-built_in">NSUInteger</span>, <span class="hljs-built_in">UIRectCorner</span>) &#123;<br>    <span class="hljs-built_in">UIRectCornerTopLeft</span>     = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>,<br>    <span class="hljs-built_in">UIRectCornerTopRight</span>    = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>,<br>    <span class="hljs-built_in">UIRectCornerBottomLeft</span>  = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>,<br>    <span class="hljs-built_in">UIRectCornerBottomRight</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>,<br>    <span class="hljs-built_in">UIRectCornerAllCorners</span>  = ~<span class="hljs-number">0</span>UL<br>&#125;;<br><br><br>+ <span class="hljs-built_in">UIRectCornerTopLeft</span>  <span class="hljs-comment">//左边</span><br>+ <span class="hljs-built_in">UIRectCornerTopRight</span> <span class="hljs-comment">//右边</span><br>+ <span class="hljs-built_in">UIRectCornerBottomLeft</span>  <span class="hljs-comment">//下左</span><br>+ <span class="hljs-built_in">UIRectCornerBottomRight</span> <span class="hljs-comment">//下右</span><br>+ <span class="hljs-built_in">UIRectCornerAllCorners</span>  <span class="hljs-comment">//所有都是圆角</span><br></code></pre></td></tr></table></figure><br>从名字很容易看出来代表的意思，使用<code>“|”</code>来组合就好了。</p>
<h5 id="如果添加阴影"><a href="#如果添加阴影" class="headerlink" title="如果添加阴影"></a>如果添加阴影</h5><p><a href="https://stackoverflow.com/questions/2264083/rounded-uiview-using-calayers-only-some-corners-how">Stackoverflow</a>里面有个例子：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">// Create a transparent view</span><br><span class="hljs-built_in">UIView</span> *theView = [[<span class="hljs-built_in">UIView</span> alloc] initWithFrame:theFrame];<br>[theView setBackgroundColor:[<span class="hljs-built_in">UIColor</span> clearColor]];<br><br><span class="hljs-comment">// Create the path (with only the top-left corner rounded)</span><br><span class="hljs-built_in">UIBezierPath</span> *maskPath = [<span class="hljs-built_in">UIBezierPath</span> bezierPathWithRoundedRect:theView.bounds <br>                                               byRoundingCorners:<span class="hljs-built_in">UIRectCornerTopLeft</span><br>                                                     cornerRadii:<span class="hljs-built_in">CGSizeMake</span>(<span class="hljs-number">10.0</span>f, <span class="hljs-number">10.0</span>f)];<br><br><span class="hljs-comment">// Create the shadow layer</span><br><span class="hljs-built_in">CAShapeLayer</span> *shadowLayer = [<span class="hljs-built_in">CAShapeLayer</span> layer];<br>[shadowLayer setFrame:theView.bounds];<br>[shadowLayer setMasksToBounds:<span class="hljs-literal">NO</span>];<br>[shadowLayer setShadowPath:maskPath.CGPath];<br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// Set the shadowColor, shadowOffset, shadowOpacity &amp; shadowRadius as required</span><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// Create the rounded layer, and mask it using the rounded mask layer</span><br><span class="hljs-built_in">CALayer</span> *roundedLayer = [<span class="hljs-built_in">CALayer</span> layer];<br>[roundedLayer setFrame:theView.bounds];<br>[roundedLayer setContents:(<span class="hljs-keyword">id</span>)theImage.CGImage];<br><br><span class="hljs-built_in">CAShapeLayer</span> *maskLayer = [<span class="hljs-built_in">CAShapeLayer</span> layer];<br>[maskLayer setFrame:theView.bounds];<br>[maskLayer setPath:maskPath.CGPath];<br><br>roundedLayer.mask = maskLayer;<br><br><span class="hljs-comment">// Add these two layers as sublayers to the view</span><br>[theView.layer addSublayer:shadowLayer];<br>[theView.layer addSublayer:roundedLayer];<br><br></code></pre></td></tr></table></figure>
<h4 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h4><blockquote>
<p>写个分类</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//</span><br><span class="hljs-comment">//  UIView+BzexACSLayer.h</span><br><span class="hljs-comment">//  BZEX</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  Created by yebinghe on 2019/11/08.</span><br><span class="hljs-comment">//  Copyright © 2019 bzex. All rights reserved.</span><br><span class="hljs-comment">//</span><br><br><br><br><br><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;UIKit/UIKit.h&gt;</span></span><br><br><span class="hljs-built_in">NS_ASSUME_NONNULL_BEGIN</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">UIView</span> (<span class="hljs-title">KimACSLayer</span>)</span><br><br>- (<span class="hljs-keyword">void</span>)bzex_radiusWithRadius:(<span class="hljs-built_in">CGFloat</span>)radius corner:(<span class="hljs-built_in">UIRectCorner</span>)corner;<br><br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-built_in">NS_ASSUME_NONNULL_END</span><br><br><br></code></pre></td></tr></table></figure></h2></blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  UIView+BzexACSLayer.m</span><br><span class="hljs-comment">//  BZEX</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  Created by yebinghe on 2019/11/08.</span><br><span class="hljs-comment">//  Copyright © 2019 bzex. All rights reserved.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;UIView+BzexACSLayer.h&quot;</span></span><br><br><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">UIView</span> (<span class="hljs-title">BzexACSLayer</span>)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 圆角</span><br><span class="hljs-comment"> 使用自动布局，需要在layoutsubviews 中使用</span><br><span class="hljs-comment"> @param radius 圆角尺寸</span><br><span class="hljs-comment"> @param corner 圆角位置</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-keyword">void</span>)bzex_radiusWithRadius:(<span class="hljs-built_in">CGFloat</span>)radius corner:(<span class="hljs-built_in">UIRectCorner</span>)corner &#123;<br>    <span class="hljs-keyword">if</span> (@available(iOS <span class="hljs-number">11.0</span>, *)) &#123;<br>        <span class="hljs-keyword">self</span>.layer.cornerRadius = radius;<br>        <span class="hljs-keyword">self</span>.layer.maskedCorners = (<span class="hljs-built_in">CACornerMask</span>)corner;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">UIBezierPath</span> * path = [<span class="hljs-built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="hljs-keyword">self</span>.bounds byRoundingCorners:corner cornerRadii:<span class="hljs-built_in">CGSizeMake</span>(radius, radius)];<br>        <span class="hljs-built_in">CAShapeLayer</span> *maskLayer = [[<span class="hljs-built_in">CAShapeLayer</span> alloc] init];<br>        maskLayer.frame = <span class="hljs-keyword">self</span>.bounds;<br>        maskLayer.path = path.CGPath;<br>        <span class="hljs-keyword">self</span>.layer.mask = maskLayer;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br><br></code></pre></td></tr></table></figure>
<blockquote>
<p>运用很简单： <code>[self.blueView bzex_radiusWithRadius:10 corner:UIRectCornerBottomLeft | UIRectCornerBottomRight];</code> 【图2的效果】<br>【图1】就简单多了</p>
</blockquote>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>圆角</tag>
      </tags>
  </entry>
  <entry>
    <title>内存中的区域划分</title>
    <url>/2012/11/10/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<ul>
<li><strong>栈区(stack)</strong>:由系统自动分配和释放，存放局部变量的值，容量小速度快，有序</li>
<li><strong>堆</strong>：一般由程序员分配和释放，如果不释放，则出现内存泄露。程序会回收您的内存，特点：容量大，速度慢，无序</li>
<li><strong>静态存储区</strong>：全局变量（外部变量）和静态变量都存放在静态区域。当程序结束使，系统回收</li>
<li><strong>常量区</strong>：存放常量的内存区域，程序结束时，系统回收</li>
<li><strong>代码区</strong>：存放二进制代码的区域</li>
</ul>
]]></content>
      <categories>
        <category>iOS面试</category>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>求职简历</title>
    <url>/2012/01/24/%E6%B1%82%E8%81%8C%E7%AE%80%E5%8E%86/</url>
    <content><![CDATA[<ul>
<li>Email：goodman@gmail.com （虽然我觉得QQ邮箱无所谓，不过有些技术人员比较反感，建议用G，非要用的话，不要用数字邮箱名）</li>
<li>QQ/微信号：6…（提供一个通过网络可以联系到你的方式）</li>
</ul>
<h1 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h1><p>（工作经历按逆序排列，最新的在最前边，按公司做一级分组，公司内按二级分组）</p>
<h2 id="ABC公司-（-2012年9月-2014年9月-）"><a href="#ABC公司-（-2012年9月-2014年9月-）" class="headerlink" title="ABC公司 （ 2012年9月 ~ 2014年9月 ）"></a>ABC公司 （ 2012年9月 ~ 2014年9月 ）</h2><h3 id="DEF项目"><a href="#DEF项目" class="headerlink" title="DEF项目"></a>DEF项目</h3><p>我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。</p>
<h3 id="GHI项目"><a href="#GHI项目" class="headerlink" title="GHI项目"></a>GHI项目</h3><p>我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。</p>
<h3 id="其他项目"><a href="#其他项目" class="headerlink" title="其他项目"></a>其他项目</h3><p>（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。）</p>
<h2 id="JKL公司-（-2010年3月-2012年8月-）"><a href="#JKL公司-（-2010年3月-2012年8月-）" class="headerlink" title="JKL公司 （ 2010年3月 ~ 2012年8月 ）"></a>JKL公司 （ 2010年3月 ~ 2012年8月 ）</h2><h3 id="MNO项目"><a href="#MNO项目" class="headerlink" title="MNO项目"></a>MNO项目</h3><p>我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。</p>
<h3 id="PQR项目"><a href="#PQR项目" class="headerlink" title="PQR项目"></a>PQR项目</h3><p>我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。</p>
<h3 id="其他项目-1"><a href="#其他项目-1" class="headerlink" title="其他项目"></a>其他项目</h3><p>（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。）</p>
<h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><ul>
<li>陈工/男/1990 </li>
<li>本科/南大学计算机系 </li>
<li>工作年限：3年</li>
<li>微博：<a href="http://weibo.com/8909easy">@Easy</a> （如果没有技术相关内容，也可以不放）</li>
<li>技术博客：<a href="http://old.fuootqq.com">http://old.fuootqq.com</a> ( 使用GitHub Host的Big较高  )</li>
<li><p>Github：<a href="http://github.com/uueasychen">http://github.com/uueasychen</a> ( 有原创repo的Github帐号会极大的提升你的个人品牌  )</p>
</li>
<li><p>期望职位：PHP高级程序员，应用架构师</p>
</li>
<li>期望薪资：税前月薪85k~120k，特别喜欢的公司可例外</li>
<li>期望城市：东京</li>
</ul>
<h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><p>（HR会打印你的简历，用于在面试的时候联系，所以联系方式放到最上边会比较方便）</p>
<ul>
<li>手机：195…. （如果是外地手机，可注明。如经常关机，要写上最优联系时间）</li>
<li>Email：goohhdman@gmail.com （虽然我觉得QQ邮箱无所谓，不过有些技术人员比较反感，建议用G，非要用的话，不要用数字邮箱名）</li>
<li>QQ/微信号：690…（提供一个通过网络可以联系到你的方式）</li>
</ul>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>简历格式</tag>
      </tags>
  </entry>
  <entry>
    <title>清歌莫断肠</title>
    <url>/2019/11/10/%E6%B8%85%E6%AD%8C%E8%8E%AB%E6%96%AD%E8%82%A0/</url>
    <content><![CDATA[  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br>“以后无论我去哪我都把你带着我看账你帮我打算盘我谈生意你<br>      帮我出主意一起把吴家东院发扬光大做到陕西第一天下第一”<br><br></code></pre></td></tr></table></figure>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1573368558764&amp;di=e3171e689163a38139b236dd2730c002&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.rjzxw.com%2Fdats%2Ftwjc%2F7%2F13721%2F13721-1.jpg" alt="35-1FZ416105K21.jpg"></p>
<blockquote>
<p>欲将沉醉换悲凉，清歌莫断肠。这混乱的尘世，究竟充斥了多少绝望和悲伤。你想去做一个勇敢的男子，为爱，为信仰，轰轰烈烈的奋斗一场。你周身充斥着无人可比的灵气和光芒。你有着与伟人比肩的才气和名声，你是那样高傲孤洁的男子。你的一寸狂心未说，已经几度黄昏雨。</p>
</blockquote>
<p>　　曾经以为，相爱的人一定要相守，只有相守，情感才能长久。可是，此岸和彼岸只不过是空间的差距，却无法拉长心灵的距离。</p>
<ul>
<li><code>刘若英</code>用了19年的时间，把《后来》拍成电影，可是，你怎么看着看着就哭了？</li>
<li><code>奶茶</code>某次在演唱会上唱起《后来》，泪流满面，她想起了谁？</li>
<li><code>朴树</code>在节目上唱起《送别》，几度哽咽，他又想起了谁？</li>
<li>现在的你又想起了哪座城市和生活在那里的人？<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1573368558762&amp;di=b7120320071687988976bd79c364992f&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.readmeok.com%2Fupimg%2F%25E5%25BC%25A0%25E8%2589%25B3%25E7%25BA%25A23%2F0000000000000000000%25E5%2595%258A%2F26%2F381765-%25E3%2580%258A%25E9%2582%25A3%25E5%25B9%25B4%25E8%258A%25B1%25E5%25BC%2580%25E6%259C%2588%25E6%25AD%25A3%25E5%259C%2586%25E3%2580%258B%25E5%2589%25A7%25E7%2585%25A7.jpg" alt="QQ.jpeg"></li>
</ul>
<p>　　<code>你</code>曾经是否有过这样的一场爱情。车站与机场，时间和距离。你们一起走过很长的一段路，挨过了很多辛苦，但最后还是没能迈过那个坎。没有出轨，没有背叛，没有狗血，但就是没办法继续在一起了，因为你发现相距几千公里，连吵架都是没有温度的<code>歇斯底里</code>，虽然真的真的很爱你。只是爱到最后，再也爱不动了。</p>
<p>　　我们都曾经历过相识、相知，之后相爱、相守，也曾有误解、争吵，恨不得下一刻就出现在对方门前。一张张车票，一条条聊天记录，一段段回忆。这样的爱情故事不曲折，不离奇，充满着世俗烟火气息，不是电影桥段，但却真实而残酷。</p>
<p>　　<code>时光荏苒，岁月无声</code>。日子不紧不慢的如涓涓溪水静静的流去，而从身边流去的只有时光，沉淀下来的是与你一路相伴的幸福和快乐，温馨和安暖。于我，在这个凋零都感受到诗意横溢的秋，只想做一件事，拈一片绯红的枫叶，轻轻地刻上我的心语。对信仰，是我今生永不改变的主题！而后，幸福的寄往有你的那个城市。从此，在我心里，于我的生命里，轻握你许的安暖，静静地在岁月的彼岸，为你守候一世永恒！</p>
<p>　　<code>一段情</code>，反复的掂量，最后加深了岁月的绵长。一路追赶里，一路追忆里，最后得到的是什么，最后又失去的是什么。或许，只有我们在静思的时候才会明白，这路的追忆里，我们得到的快乐往往比痛苦要少。当相思成殇的时候，除了对月徒悲叹之外，什么也不曾抓到。<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1573368558762&amp;di=d92edf03834072488d015172dd6b6f30&amp;imgtype=0&amp;src=http%3A%2F%2Fimage.fsyule.net%2F2017-10-01%2Fcaf829fd21255f3176e09b1e2f52361a.png" alt="xc.jpeg"></p>
<p>忽然想起<a href="https://baike.sogou.com/v154999849.htm?fromTitle=%E5%91%A8%E8%8E%B9%EF%BC%88%E6%B8%85%E6%9C%AB%E5%87%BA%E8%BA%AB%E6%B0%91%E9%97%B4%E7%9A%84%E9%99%95%E8%A5%BF%E5%A5%B3%E9%A6%96%E5%AF%8C%EF%BC%89">周莹</a>的那段对白：</p>
<blockquote>
<p>“你别忘了你现在的命是我救的如果我想要女人的身子我想要多少有多少我才<br> 不稀罕你呢”<br> “那你想要什么我要你心甘情愿的跟着我”<br>“不可能”<br>“你既然可以心甘情愿的跟着吴聘为什么不可以跟着我我哪点不如他”<br>“你哪都不如他”<br>….</p>
</blockquote>
]]></content>
      <categories>
        <category>电视剧</category>
      </categories>
      <tags>
        <tag>文学</tag>
      </tags>
  </entry>
  <entry>
    <title>要么不开始，要么一辈子</title>
    <url>/2019/11/10/%E8%A6%81%E4%B9%88%E4%B8%8D%E5%BC%80%E5%A7%8B%EF%BC%8C%E8%A6%81%E4%B9%88%E4%B8%80%E8%BE%88%E5%AD%90/</url>
    <content><![CDATA[<blockquote>
<p>我真的完全没有精力再失恋一次了。﻿</p>
</blockquote>
<p><img src="http://a.hiphotos.baidu.com/image/pic/item/38dbb6fd5266d01681fbe0859d2bd40734fa35b8.jpg" alt="图片"><br>18岁失恋了，可以躲在厕所里哭，可以在ktv喝酒唱通宵，可以哭得昏天暗地，可以发誓以后和他老死不相往来，然后重新开始，像没有受过伤一样。﻿﻿</p>
<p>22岁失恋了，一夜未眠，一夜游荡，第二天却还要假装没事，因为你还要工作，还要生活，你面无表情，可你知道你心里已经塌了。﻿﻿</p>
<p>25岁，你想过无数次，要不索性回到十七岁，再轰轰烈烈的爱一次，可是你清楚的知道，你已经没有力气再失恋一次了。﻿﻿</p>
<p>第一次恋爱，心里住了梅花鹿，连看他一眼都小鹿乱撞。﻿﻿</p>
<p>后来心里生了一条蛇，一有人靠近就摇起尾巴，告诉别人你很危险更没有耐心。﻿﻿</p>
<p>经常有人问我，为什么不谈恋爱？﻿﻿</p>
<p>其实身边也不缺追求者，只是每次想答应的时候，都会胆怯害怕，然后习惯性的拒绝，爱一个人的成本太高了，要耗上大把时间和精力，还不一定会有回报，大概是件稳赔不赚的事。﻿﻿</p>
<p>所以，我怕了。﻿﻿</p>
<p>两个人在一起很简单，相互喜欢就好，但是分开，却要耗尽毕生的精力。﻿﻿</p>
<p>你花了大把的时间和精力去习惯了解一个人，最后却还是要分开，真的很累，我好不容易从上一段感情中活过来，不想再送死了。﻿﻿</p>
<p>我知道，我们都到了害怕失恋的年纪。﻿﻿</p>
<p>有人说，爱情是属于那些即使灰心失望，却仍继续期待的人，是属于那些被出卖欺骗，却仍坚信美好的人，是属于那些纵然伤痕累累，却仍渴求爱的人。﻿﻿</p>
<p><code>所以希望下一次恋爱，要么不开始，要么一辈子。</code></p>
]]></content>
      <categories>
        <category>散文</category>
      </categories>
      <tags>
        <tag>文学</tag>
        <tag>情感</tag>
      </tags>
  </entry>
  <entry>
    <title>熟悉Objective-C</title>
    <url>/2019/11/13/%E7%86%9F%E6%82%89Objective-C/</url>
    <content><![CDATA[<h3 id="了解Objective-C语言"><a href="#了解Objective-C语言" class="headerlink" title="了解Objective-C语言"></a>了解Objective-C语言</h3><ol>
<li>消息与函数调用的区别：（oc消息结构和c++函数调用）<br>使用消息结构的语言，其运行时所应执行的代码由运行时环境决定；而使用函数调用的语言，则由编译器决定。<br>如果函数的调用是多态的，那么在运行时姐要按照“virtual table”来查出到底应该执行哪个函数实现。而采用消息结构的语言，不论是多态，总是在运行时才会查找所要执行的方法。实际上，编译器甚至不关心接收消息的对象是何种类型。接收消息的对象问题也要在运行时处理，也就是<a href="https://platojobs.github.io">oc的动态绑定</a>。</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">// oc对象所占内存总是分配在堆空间</span><br><span class="hljs-built_in">NSString</span> * someThing = <span class="hljs-string">@&quot;string&quot;</span>;<br><span class="hljs-built_in">NSString</span> *anoterTing = someThing;<br><br></code></pre></td></tr></table></figure>
<p><code>someThing</code>变量指向分配在堆里的某块内存，其中含有一个<code>NSString</code>对象，也就是说，如果再创建一个变量<code>anoterTing</code>，只是指向同一个地址，那么并不拷贝该对象，只是这两个变量会同时指向此对象。</p>
<p>只有一个<code>NSString</code>对象，然而有两个变量指向此实例。两个变量都是<code>NSString*</code>类型，这说明当前<code>stack frame</code>里分配了两块内存，每块内存的大小都能容下一枚指针（32位是4字节，64位是8字节）。两块内存的值都一样，就是实例的内存地址。也就是说有两个分配在栈上的指针指向该堆上的实例。</p>
<blockquote>
<p> oc为c语言添加了面向对象特性，是其超集。oc使用动态绑定的消息结构，也就是说，在运行时才会检查对象类型。接收一条消息以后，究竟执行何种代码，由运行时环境而非编译器决定。</p>
</blockquote>
<h3 id="在类的头文件中尽量少引入其他头文件"><a href="#在类的头文件中尽量少引入其他头文件" class="headerlink" title="在类的头文件中尽量少引入其他头文件"></a>在类的头文件中尽量少引入其他头文件</h3><blockquote>
<p>有的时候我们只是使用一个类，并不需要知道这个类的全部细节，只需要知道有这个类，那么就需要用到：<code>@class 类名</code>,这就叫做<code>向前声明</code>该类。但是在用到这个类的实现文件里还是要用到引入这个类的<code>.h</code>文件</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@class</span> <span class="hljs-title">PlatoJobsObj</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">PJObjc</span> : <span class="hljs-title">NSObject</span></span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">copy</span>)<span class="hljs-built_in">NSSting</span> * fname;<br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">copy</span>)<span class="hljs-built_in">NSSting</span> * sname;<br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">strong</span>)PlatoJobsObj * person;<br><br><span class="hljs-keyword">@end</span><br><br><br><br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;PJObjc.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;PlatoJobsObj.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">PJObjc</span></span><br><br><span class="hljs-comment">// Implementation of methods</span><br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//将引入头文件的时机尽量延后，只在确有需要的时候才去引入，这样就可以减少类的使用者所需引入的头文件的数量，如果不用这种方式，直接引入，那么就会增加编译时间.</span><br><br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>向前声明</code>也解决了两个类的相互引用的问题.</p>
</blockquote>
<ul>
<li>类的头文件互引用事例：<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">// A.h</span><br><br><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;B.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">A</span> : <span class="hljs-title">NSObject</span>    </span><br><br><span class="hljs-keyword">@end</span><br><br><br><span class="hljs-comment">//B.h</span><br><br><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;A.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">B</span> : <span class="hljs-title">NSObject</span> </span><br><br><span class="hljs-keyword">@end</span><br><br><br><span class="hljs-comment">//这样就会出一个无限循环的拷贝状态。无法编译成功</span><br><br></code></pre></td></tr></table></figure></li>
<li>解决类的头文件互引用方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">//用关键字：@class 类名。</span><br><span class="hljs-comment">//关键字说明：在编译时，告诉编译器有一个类叫 “类名”。</span><br><span class="hljs-comment">//用法：在两个类A,B的声明中，A.h文件中换成@class B，并A.m文件中导入B.h；也可在B.h文件中换成@class A，并在B.m文件中导入A.h，只要不形成 无限循环的拷贝状态 即可。</span><br><br>   <br><span class="hljs-comment">// A.h</span><br><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@class</span> <span class="hljs-title">B</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">A</span> : <span class="hljs-title">NSObject</span>   </span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//B.h</span><br><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@class</span> <span class="hljs-title">A</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">B</span> : <span class="hljs-title">NSObject</span> </span><br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//优点：即可以解决无限循环的拷贝状态，也可以减少编译的时间。因为在编译的时候 导入.h文件也就是一个拷贝的过程。</span><br><br><br></code></pre></td></tr></table></figure>
<ul>
<li>成员变量的 手动管理对象引用计数器<code>(MRC)</code>被循环判断且循环执行<code>dealloc</code>对象方法 和 内存泄漏问题<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">//前提：两个类A和B，A类中有类型为B的成员变量 _b，B类中有类型为A的成员变量 _a</span><br><br><span class="hljs-comment">//A类的成员变量 _b 的set / get 方法：@property (nonatomic ,retain)B * b ;</span><br><br><span class="hljs-comment">//B类的成员变量 _a 的set / get 方法：@property (nonatomic ,retain)A * a ;</span><br><br><span class="hljs-comment">//实现了dealloc对象方法：- (void) dealloc&#123;  [ name release] ;   [surper dealloc] ;  &#125; //name = _a 或 _b</span><br><br><span class="hljs-comment">//main函数体如下:</span><br><br>   A * pa = [ [A alloc] init ] ;  <span class="hljs-comment">// pa引用计数 = 1</span><br><br>   B * pb = [ [B alloc] init ] ;  <span class="hljs-comment">// pb引用计数 = 1</span><br><br>   [pa setB: pb] ;  <span class="hljs-comment">// pb引用计数 = 2</span><br><br>   [pb setA: pa] ;  <span class="hljs-comment">// pa引用计数 = 2</span><br><br><span class="hljs-comment">// 一个alloc 对应一个 release</span><br><br>   [pb release] ;  <span class="hljs-comment">// pb引用计数 = 1</span><br><br>   [pa release] ;  <span class="hljs-comment">// pa引用计数 = 1</span><br><br><br></code></pre></td></tr></table></figure>
<blockquote>
<p>(1)问题：上面main函数体的代码出现内存泄漏： 两个对象引用计数 都等于1，在堆里面开辟的空间没有清空。两个对象都没有调用dealloc对象方法。<br>如果上面的<code>[pb setA: pa]</code>; 这行代码去掉，那么会在<code>[pa release]</code>; 这行代码， <code>pa</code>引用计数 = 0 ,会无限循环调用A类dealloc,B类dealloc , _a是个野指针，出现报错。<br>(2)解决方案：两个类中<code>set</code>方法管理内存，一个用<code>retain</code> , 一个用<code>assign</code>。<br>在两类中做如下更改：  在<code>A</code>类：<code>@property (nonatomic ,retain)B * b;</code>在<code>B</code>类：<code>@property (nonatomic ,assign)A * a ;</code><br>问题：<code>strong</code>对象的指针出现了循环互引用。这样就会导致在一个相互指向的循环圈内的对象内存不能被释放，出现内存泄漏问题.<br>解决：一端用<code>strong</code>类型指针，一端用<code>weak</code>类型指针。只要没有出现强指针类型的对象循环指向就可以解决该问题。</p>
</blockquote>
</li>
</ul>
<hr>
<blockquote>
<p>小结：对于头文件互引用问题，解决方法：在头文件中用@class 类名 ; 告诉编译器有那么一个类。对于对象出现的互引用问题，<br><em>解决方法</em>：<br><code>ARC</code>：一端用<code>strong</code> 类型指针，一端用<code>weak</code>类型指针。<br><code>MRC</code>：一端用 <code>retain</code>类型指针，一端用<code>assign</code> 类型指针。</p>
</blockquote>
<hr>
<h3 id="多用字面量语法，少用与之等价的方法"><a href="#多用字面量语法，少用与之等价的方法" class="headerlink" title="多用字面量语法，少用与之等价的方法"></a>多用字面量语法，少用与之等价的方法</h3><h4 id="字面数值和字面数组"><a href="#字面数值和字面数组" class="headerlink" title="字面数值和字面数组"></a>字面数值和字面数组</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//字面量创建字符串</span><br><span class="hljs-built_in">NSString</span> * someTh =<span class="hljs-string">@&quot;PlatoJobs&quot;</span>;<br><span class="hljs-comment">//数值</span><br><span class="hljs-built_in">NSNumber</span> * someNum = [<span class="hljs-built_in">NSNumber</span> numberWithInt: <span class="hljs-number">30</span>];<br><span class="hljs-comment">//使用字面量数值</span><br><span class="hljs-built_in">NSNumber</span> * someNum = @<span class="hljs-number">30</span>;<br><br><span class="hljs-comment">//字面量数组</span><br><span class="hljs-built_in">NSArray</span> *persons = @[<span class="hljs-string">@&quot;习近平&quot;</span>,<span class="hljs-string">@&quot;胡锦涛&quot;</span>,<span class="hljs-string">@&quot;江泽民&quot;</span>,<span class="hljs-string">@&quot;毛泽东&quot;</span>];<br><span class="hljs-comment">//字面量取值</span><br><span class="hljs-built_in">NSString</span> * xijinping = persons[<span class="hljs-number">0</span>];  <span class="hljs-comment">//也是subscripting</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>字面量语法创建数组时候⚠️：若数组元素对象中有nil，那么则会抛出异常，因为字面量语法<br>实际上只是一种<code>语法糖</code>，其效果等于先创建了一个数组，然后把方括号内的所有对象添加到数组中。</p>
</blockquote>
<p>常见异常如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br>*** Terminating app due to uncaught exception <br><span class="hljs-string">&#x27;NSInvalidArgumentException&#x27;</span>, reason: <span class="hljs-string">&#x27;*** </span><br><span class="hljs-string">-[__NSPlaceholderArray initWithObjects:count:]: attempt to insert nil object from objects[0]&#x27;</span><br><br></code></pre></td></tr></table></figure></p>
<blockquote>
<p>那么问题来了：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-built_in">NSArray</span> * arrayA = [<span class="hljs-built_in">NSArray</span> arrayWithObjects:objc1,objc2,objc3,<span class="hljs-literal">nil</span>];<span class="hljs-comment">//方法1</span><br><br><span class="hljs-built_in">NSArray</span> * arrayB =@[objc1,objc2,objc3]; <br><br><span class="hljs-comment">//如果objc2=nil；那么arrayA只有一个元素，由于objc2=nil，方法1会提前结束。</span><br></code></pre></td></tr></table></figure></h2></blockquote>
<h4 id="字面字典"><a href="#字面字典" class="headerlink" title="字面字典"></a>字面字典</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-built_in">NSDictionary</span> *person =[<span class="hljs-built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:<span class="hljs-string">@&quot;value1&quot;</span>,<span class="hljs-string">@&quot;key1&quot;</span>,<span class="hljs-string">@&quot;value2&quot;</span>,<span class="hljs-string">@&quot;key2&quot;</span>,<span class="hljs-string">@&quot;value3&quot;</span>,<span class="hljs-string">@&quot;key3&quot;</span>, <span class="hljs-literal">nil</span>];<br>  <br><span class="hljs-comment">//字面量</span><br><span class="hljs-built_in">NSDictionary</span>* peronDic =@&#123;<span class="hljs-string">@&quot;key1&quot;</span>:<span class="hljs-string">@&quot;value1&quot;</span>,<span class="hljs-string">@&quot;key2&quot;</span>:<span class="hljs-string">@&quot;value2&quot;</span>,<span class="hljs-string">@&quot;key3&quot;</span>:<span class="hljs-string">@&quot;value3&quot;</span>&#125;;<br>   <br></code></pre></td></tr></table></figure>
<blockquote>
<p>字面量的缺点：除了字符串之外，所创建出来的对象必须属于<code>Foundation</code>框架才行。如果是自定义了这些类的子类，则无法用字面量语法创建其对象。要想创建自定义子类的实例，必须用非字面量语法。由于<code>NSArray,NSDictionary,NSNumber</code>都是业已定型的子簇，因此很少会有人自定义子类。创建字符串时可以使用自定义的子类，然而必须要修改编译器的选项才行，除非你清楚这样做的后果。否则不鼓励。</p>
</blockquote>
<hr>
<h3 id="多用类型常量，少用-define-预处理指令"><a href="#多用类型常量，少用-define-预处理指令" class="headerlink" title="多用类型常量，少用#define 预处理指令"></a>多用类型常量，少用#define 预处理指令</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AMin 1.9  <span class="hljs-comment">//预处理指令</span></span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">CGFloat</span> aMin = <span class="hljs-number">1.8</span>;  <span class="hljs-comment">//类型常量</span><br><br><br></code></pre></td></tr></table></figure>
<ul>
<li><p>类型常量包含<strong>类型信息</strong>，好处是清楚地描述了常量的含义。由此可知该常量类型<code>CGFloat</code>，后续阅读代码的人比较理解其意图。</p>
</li>
<li><p>若不打算公开某个常量，则应将其定义在使用该常量的实现文件里。</p>
</li>
<li>变量一定要用<code>static</code>与<code>const</code>声明。试图修改由<code>const</code>修饰符所声明的变量，那么编译器会报错。</li>
<li>有时候需要对外公开某个常量，比如说通知名称，而这个名称就可以声明为一个外界可见的常值变量。此类常量需放在<code>全局符号表</code>中，以便可以在定义该常量的编译单元之外使用<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// In the header file</span><br><span class="hljs-keyword">extern</span> <span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> EFTDPlatoJobs<br><br><span class="hljs-comment">//In the implementation file</span><br><br><span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> EFTDPlatoJobs=<span class="hljs-string">@&quot;PlatoJobs&quot;</span>;<span class="hljs-comment">//常量类型应从右至左解读</span><br><br><br></code></pre></td></tr></table></figure>
此类常量必须定义一次，而且只能定义一次，通常将其定义在与声明该常量的头文件相关的实现文件里。<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">//PlatoJobsManager.h</span><br><br><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> PJLoginManagerNoticeff;<br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">PJLoginManager</span> : <span class="hljs-title">NSObject</span></span><br><br>-(<span class="hljs-keyword">void</span>)login;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//PlatoJobsManager.m</span><br><br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;PJLoginManager.h&quot;</span></span><br><br><span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> PJLoginManagerNoticeff =<span class="hljs-string">@&quot;PlatoJobsLoginNotification&quot;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">PJLoginManager</span></span><br><br>-(<span class="hljs-keyword">void</span>)login&#123;<br><br><span class="hljs-comment">//Perform login method</span><br><br>&#125;<br><br>-(<span class="hljs-keyword">void</span>)pj_didLogin&#123;<br><br>[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter]postNotificationName:PJLoginManagerNoticeff object:<span class="hljs-literal">nil</span>];<br>  <br>&#125;<br><br><span class="hljs-comment">//避免常量名字冲突，最好用与之相关的类名做前缀。</span><br><br><span class="hljs-keyword">@end</span><br><br></code></pre></td></tr></table></figure>
那么其他类型的常量也是如此</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// PJAnimatView.h</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">NSTimeInterval</span> PJAniationDuration;<br><br><span class="hljs-comment">// PJAnimatView.m</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">NSTimeInterval</span> PJAniationDuration = <span class="hljs-number">0.8</span>;<br><br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>不要使用预处理指令定义常量，如果有人重新定义了此值，编译器也不会警告，这将导致应用程序中的常量值不一致。</li>
<li>实现文件中使用 <code>static const</code>定义的只在编译单元内可见的常量，无须为其加前缀，要加就加<code>k</code>加一区分。</li>
<li><code>extern</code>来声明的全局常量，要在其前加类名前缀，来做区分，而且好查找。</li>
</ul>
</blockquote>
<hr>
<h3 id="用枚举便是状态、选项、状态码-enum"><a href="#用枚举便是状态、选项、状态码-enum" class="headerlink" title="用枚举便是状态、选项、状态码 enum"></a>用枚举便是状态、选项、状态码 <code>enum</code></h3><p>枚举只是一种常量命名方式。某个对象经历的各种状态就可以定义为一个简单的枚举集。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">//NS_ENUM 定义的枚举</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">NS_ENUM</span>(<span class="hljs-built_in">NSUInteger</span>, PlatoJobsConnectState) &#123;<br>    PlatoJobsConnectStateDisconnected,<br>    PlatoJobsConnectStateConnecting,<br>    PlatoJobsConnectStateConnected,<br>&#125;;<br><br><span class="hljs-comment">//NS_OPTIONS 定义的枚举</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">NS_OPTIONS</span>(<span class="hljs-built_in">NSUInteger</span>, PlatoJobsDirection)&#123;<br>    <br>    PlatoJobsDirectionUp =<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>,<br>    <br>    PlatoJobsDirectionDown = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>,<br>    <br>    PlatoJobsDirectionLeft = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span>,<br>    <br>    PlatoJobsDirectionRight = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>,<br><br>&#125;;<br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">NS_OPTIONS</span>(<span class="hljs-built_in">NSUInteger</span>, <span class="hljs-built_in">UIViewAutoresizing</span>) &#123;<br>    <span class="hljs-built_in">UIViewAutoresizingNone</span>                 = <span class="hljs-number">0</span>,<br>    <span class="hljs-built_in">UIViewAutoresizingFlexibleLeftMargin</span>   = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>,<br>    <span class="hljs-built_in">UIViewAutoresizingFlexibleWidth</span>        = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>,<br>    <span class="hljs-built_in">UIViewAutoresizingFlexibleRightMargin</span>  = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>,<br>    <span class="hljs-built_in">UIViewAutoresizingFlexibleTopMargin</span>    = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>,<br>    <span class="hljs-built_in">UIViewAutoresizingFlexibleHeight</span>       = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>,<br>    <span class="hljs-built_in">UIViewAutoresizingFlexibleBottomMargin</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span><br> &#125;;<br><br><br><br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>应该用枚举来表示状态机的状态，传递给方法的选项以及状态码等值，给这些值起个易懂的名字。</li>
<li>如果把传递给某个方法的选项表示为枚举类型，而多个选项又可以同时使用，那么就将各选项值定义为2的幂，以便通过位或操作将其组合起来。</li>
<li><code>NS_ENUM</code> 和 <code>NS_OPTIONS</code>宏来定义枚举类型，并指明底层数据类型。这么做可以确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。</li>
<li>在处理枚举类型的switch语句中不要实现default分支。这样的话，加入新枚举之后，编译器就会提示开发者：switch语句并没有处理所有枚举。</li>
</ul>
</blockquote>
<p><code>我们总是习惯在 switch 语句中加上 default 分支。然而，若是用枚举来定义状态机（state machine）,则最好不要有 default 分支。这样的话，如果稍后又加了一种状态，那么编译器就会发出警告信息，提示新加入的状态并未在 switch 分支中处理。假如写上了 default 分支，那么它就会处理这个新状态，从而导致编译器不发出警告信息。用 NS_ENUM 定义其他枚举类型时也要注意此问题。例如，在定义代表 UI 元素的枚举时，通常要确保 switch 语句能正确处理所有样式。</code></p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>书阅</category>
      </categories>
      <tags>
        <tag>字面量</tag>
        <tag>类型常量</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>Lookin 的使用</title>
    <url>/2019/11/15/Lookin-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><img src="6lookin7.jpg" alt="Preview" title="Preview"></p>
<p>Lookin 可以查看与修改 iOS App 里的 UI 对象，类似于 Xcode 自带的 UI Inspector 工具，或另一款叫做 Reveal 的软件。<br>官网：<a href="https://lookin.work/">https://lookin.work/</a></p>
<p>如果这是你的 iOS 项目第一次使用 Lookin，则需要先把 Lookin 的 iOS Framework 嵌入到你的 iOS 项目中，教程：<br><a href="https://lookin.work/faq/integration-guide/">https://lookin.work/faq/integration-guide/</a></p>
<p>如果你只想先大概体验一下 Lookin 的功能，则可以下载下面这个已经配置好的项目，直接编译运行即可使用 Lookin 查看：<br><a href="https://cdn.lookin.work/download/QMUI-Demo-1-0-0.zip">https://cdn.lookin.work/download/QMUI-Demo-1-0-0.zip</a></p>
<hr>
<p><img src="mona-heart-hug-facebook.png" alt=""></p>
<p>You can inspect and modify views in iOS app via Lookin, just like UI Inspector in Xcode, or another app called Reveal.<br>Website：<a href="https://lookin.work/">https://lookin.work/</a></p>
<p>To use Lookin, you need to embed the iOS Framework of Lookin into your iOS project. Tutorial:<br><a href="https://lookin.work/faq/integration-guide/">https://lookin.work/faq/integration-guide/</a></p>
<p>If you just want to take a glance, you can download the sample iOS project below which has been configured properly already to enable Lookin:<br><a href="https://cdn.lookin.work/download/QMUI-Demo-1-0-0.zip">https://cdn.lookin.work/download/QMUI-Demo-1-0-0.zip</a></p>
<p><a href="https://github.com/QMUI/LookinServer">项目地址</a></p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>UI</category>
      </categories>
      <tags>
        <tag>Lookin</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>大龄程序员的职业规划</title>
    <url>/2019/11/15/%E5%A4%A7%E9%BE%84%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>程序员30岁以上,是可以继续技术生涯的. 我身边有很多邻近40+,还在做技术.</p>
<p><strong><em>如果你喜欢做技术,又能扛得住环境的噪音, 年龄其实不是问题.</em></strong> 遗憾的是,其实很多人并不喜欢软件开发这条技术路, 心里早已存在干几年就要转型的念头, 于是总是容易被外界喧嚣推动的左右摇摆.</p>
<p>假设要继续做技术,想要有持续的职业生命力,这里有2条建议可供参考:</p>
<ol>
<li>大龄程序员选择公司的3大关键点</li>
<li>保持竞争力的2个建议.<h3 id="一-大龄程序员选择公司的3个关键点"><a href="#一-大龄程序员选择公司的3个关键点" class="headerlink" title="一.大龄程序员选择公司的3个关键点"></a>一.大龄程序员选择公司的3个关键点</h3></li>
</ol>
<h4 id="第一-是关于公司规模的"><a href="#第一-是关于公司规模的" class="headerlink" title="第一,是关于公司规模的."></a>第一,是关于公司规模的.</h4><p>大龄开发者尽量不要选择小微创业公司,当然不排除你创业或合伙创业可能性. 原因如下:</p>
<ol>
<li>极其不稳定,一年半载就挂掉的公司占很大比例,会导致你频繁换工作,而且年龄会越来越大,找工作就会越来越难.</li>
<li>多数小微创业公司,目的是生存,偏向应用类产品. 希望程序员能抗压,加班,一人多用,快速出活,他们并不喜欢大龄开发者. (除非你的技术带头人),因为你的10年开发经验和3年经验在应用项目中干的事情是差不多的.</li>
<li>技术创新和技术壁垒的构建,需要大把金钱和人力资源,很多小公司压根提供不了这样的环境.<br>建议: 优先选择中型,大型公司,或者已经在行业内优秀产品的小公司.</li>
</ol>
<h4 id="第二-分析公司是否重视技术"><a href="#第二-分析公司是否重视技术" class="headerlink" title="第二,分析公司是否重视技术"></a>第二,分析公司是否重视技术</h4><p>即便选择了中大型公司或者有好产品的小公司,也要看看在这些公司里,技术部门的重要性,即要明确公司,公司是技术导向,市场导向,运营导向,产品导向;</p>
<p>选择顺序: 技术导向,运营导向,产品导向,市场导向.</p>
<p>因为在一家公司,技术越被重视,技术人员的知识,技术,经验等方面的积累也越被重视,也越能认可大龄程序员的价值.</p>
<h4 id="第三-观察目标公司的年龄分布"><a href="#第三-观察目标公司的年龄分布" class="headerlink" title="第三,观察目标公司的年龄分布"></a>第三,观察目标公司的年龄分布</h4><p>我们不能光听公司如何说自己欢迎大龄程序员,要看他现有的技术团队成员的年龄分布.</p>
<p>欢迎大龄程序员的团队,里面一定有若干大龄程序员.<br>不欢迎大龄程序员的团队,除了负责人,基本上都是小鲜肉.</p>
<p>选择那些团队中有大佬程序员的团队,可能更靠谱. 当然,如果你这方面技术专家,可以忽略这一条.</p>
<h3 id="二-保持竞争力的2条建议"><a href="#二-保持竞争力的2条建议" class="headerlink" title="二.保持竞争力的2条建议"></a>二.保持竞争力的2条建议</h3><ol>
<li>在某个细分技术方向上精研, 建立标签. 让团队内提到这个方向就想到你,提到你就想到某个技术方向,有问题都来咨询你. 这样能凸显出来,影响力和重要性增大; 建议开发者除了拓宽在团队影响,也需要在业界产生一定影响力.</li>
<li>重视业务,成为业务领域的行家. 因为程序员的竞争力,最起码有技术和业务组成,两条腿走路,比一条腿更稳健.<blockquote>
<p>总结 :首先明确自己对于职业的期待, 如果你只把当做养家糊口的工具,它也只能给你这样的回馈.如果你真心能耐住寂寞,找到自身技术的方向.并在这个方向研究下去. 每一个专业技术人才选择会比只懂普通应用开发的前景和选择更多.<br>不断的去思考, 35岁我失去年龄红利期之后,我的竞争力在哪儿? 如果你想不到,就花些时间学习了解你的圈子里有哪些可以供你系统研究的方向,并选定其中一个深耕下去. 相信结果不会比今天的你差.<br>见过很多遇到瓶颈器非常焦虑的开发者,但是迟迟不做出行动和选择. 我想说,与其等着,不如直面而上. 不一定会成功,但是很酷!</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>职场</category>
      </categories>
      <tags>
        <tag>职业规划</tag>
        <tag>公司</tag>
      </tags>
  </entry>
  <entry>
    <title>AV Foundation之视频捕捉（1）__关键概念</title>
    <url>/2019/11/17/AV-Foundation%E4%B9%8B%E8%A7%86%E9%A2%91%E6%8D%95%E6%8D%89%EF%BC%881%EF%BC%89-%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h4 id="一-、捕捉功能综述"><a href="#一-、捕捉功能综述" class="headerlink" title="(一)、捕捉功能综述"></a>(一)、捕捉功能综述</h4><p>  AV Foundation 照片和视频捕捉功能是从框架搭建之初就是它的强项。 从iOS 4.0 我们就可以直接访问iOS的摄像头和摄像头生成的数据（照片、视频）。目前捕捉功能仍然是苹果公司媒体工程师最关注的领域。 </p>
<p>   核心的捕捉类在iOS 和 OS X上是一致的。除了Mac OSX 为截屏功能定义了AVCaptureScreenInput 类。但iOS上由于沙盒的限制不提供该类。我们讨论的大部分功能都适应于OS X开发的。想尝试Mac开发的同学，可以挑战一下哦！</p>
<h4 id="1-1-1-捕捉会话"><a href="#1-1-1-捕捉会话" class="headerlink" title="1.1.1 捕捉会话"></a>1.1.1 捕捉会话</h4><p><code>AV Foundation</code>  捕捉栈核心类是<code>AVCaptureSession</code>。一个捕捉会话相当于一个虚拟的“插线板”。用于连接输入和输出的资源。</p>
<h4 id="1-1-2-捕捉设备"><a href="#1-1-2-捕捉设备" class="headerlink" title="1.1.2 捕捉设备"></a>1.1.2 捕捉设备</h4><p><code>AVCaptureDevice</code>为摄像头、麦克风等物理设备提供接口。大部分我们使用的设备都是内置于MAC或者iPhone、iPad上的。当然也可能出现外部设备。但是<code>AVCaptureDevice</code> 针对物理设备提供了大量的控制方法。比如控制摄像头聚焦、曝光、白平衡、闪光灯等。</p>
<h4 id="1-1-3-捕捉设备的输入"><a href="#1-1-3-捕捉设备的输入" class="headerlink" title="1.1.3 捕捉设备的输入"></a>1.1.3 捕捉设备的输入</h4><p>注意：为捕捉设备添加输入，不能添加到<code>AVCaptureSession</code> 中，必须通过将它封装到一个<code>AVCaptureDeviceInputs</code>实例中。这个对象在设备输出数据和捕捉会话间扮演接线板的作用。</p>
<h4 id="1-1-4-捕捉的输出"><a href="#1-1-4-捕捉的输出" class="headerlink" title="1.1.4 捕捉的输出"></a>1.1.4 捕捉的输出</h4><p><code>AVCaptureOutput</code> 是一个抽象类。用于为捕捉会话得到的数据寻找输出的目的地。框架定义了一些抽象类的高级扩展类。例如 <code>AVCaptureStillImageOutput</code> 和 <code>AVCaptureMovieFileOutput</code>类。使用它们来捕捉静态照片、视频。例如 <code>AVCaptureAudioDataOutput</code>和 <code>AVCaptureVideoDataOutput</code> ,使用它们来直接访问硬件捕捉到的数字样本。</p>
<h4 id="1-1-5-捕捉连接"><a href="#1-1-5-捕捉连接" class="headerlink" title="1.1.5 捕捉连接"></a>1.1.5 捕捉连接</h4><p><code>AVCaptureConnection</code>类.捕捉会话先确定由给定捕捉设备输入渲染的媒体类型，并自动建立其到能够接收该媒体类型的捕捉输出端的连接。</p>
<h4 id="1-1-6捕捉预览"><a href="#1-1-6捕捉预览" class="headerlink" title="1.1.6捕捉预览"></a>1.1.6捕捉预览</h4><p>如果不能在影像捕捉中看到正在捕捉的场景，那么应用程序用户体验就会很差。幸运的是框架定义了<code>AVCaptureVideoPreviewLayer</code> 类来满足该需求。这样就可以对捕捉的数据进行实时预览。</p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title>AV Foundation之视频捕捉（2）__创建预览视图</title>
    <url>/2019/11/17/AV-Foundation%E4%B9%8B%E8%A7%86%E9%A2%91%E6%8D%95%E6%8D%89%EF%BC%882%EF%BC%89-%E5%88%9B%E5%BB%BA%E9%A2%84%E8%A7%88%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<blockquote>
<p>前言在讲述<code>AVFoundation</code>框架之媒体捕捉。我将用一个小案例来开始整个知识点的引导以及疏通。我就不一一赘述相关的UI实现了。关于UI搭建部分，同学们可以在本篇文章末尾拿到百度网盘分享。你就可以在这个基础上进行编码了.<a href="https://platojobs.github.io/2019/11/17/AV-Foundation之视频捕捉（1）-关键概念/">AV Foundation 基础概念</a></p>
</blockquote>
<h4 id="2-1-1-创建预览视图"><a href="#2-1-1-创建预览视图" class="headerlink" title="2.1.1 创建预览视图"></a>2.1.1 创建预览视图</h4><p>图2-1是项目的用户界面的组成图示。我们把重点放在中间层<code>THPreview View</code>的实现上。因为它直接包含了<code>AVFoundation</code> 的用户界面。</p>
<p><img src="图2-1.png" alt="图2-1"></p>
<p>图2-1所示的THPreview View 类提供给用户用i 个摄像头当前拍摄内容的实时预览图。我们将使用AVCaptureVideoPreviewLayer方法实现这个行为。首先我们通过认识THPreview View 的接口开始了解如何实现。</p>
<p>代码实现：<br><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;AVFoundation/AVFoundation.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">THPreviewViewDelegate</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span><br>- (<span class="hljs-keyword">void</span>)tappedToFocusAtPoint:(<span class="hljs-built_in">CGPoint</span>)point;<span class="hljs-comment">//聚焦</span><br>- (<span class="hljs-keyword">void</span>)tappedToExposeAtPoint:(<span class="hljs-built_in">CGPoint</span>)point;<span class="hljs-comment">//曝光</span><br>- (<span class="hljs-keyword">void</span>)tappedToResetFocusAndExposure;<span class="hljs-comment">//点击重置聚焦和曝光</span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">THPreviewView</span> : <span class="hljs-title">UIView</span></span><br><span class="hljs-comment">//session用来关联AVCaptureVideoPreviewLayer和激活AVCaptureSession</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">strong</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-built_in">AVCaptureSession</span> *session;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">id</span>&lt;THPreviewViewDelegate&gt; delegate;<br><span class="hljs-comment">//是否聚焦</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>) <span class="hljs-built_in">BOOL</span> tapToFocusEnabled;<br><span class="hljs-comment">//是否曝光</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>) <span class="hljs-built_in">BOOL</span> tapToExposeEnabled;<br><br><span class="hljs-keyword">@end</span><br><br><br></code></pre></td></tr></table></figure><br>实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br>+ (Class)layerClass &#123;<br>    <span class="hljs-comment">// 返回AVCaptureVideoPreviewLayer对象</span><br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">AVCaptureVideoPreviewLayer</span> <span class="hljs-keyword">class</span>];<br>&#125;<br><br>- (<span class="hljs-built_in">AVCaptureSession</span>*)session &#123;<br>    <span class="hljs-comment">// 返回捕捉会话</span><br>    <span class="hljs-keyword">return</span> [(<span class="hljs-built_in">AVCaptureVideoPreviewLayer</span>*)<span class="hljs-keyword">self</span>.layer session];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)setSession:(<span class="hljs-built_in">AVCaptureSession</span> *)session &#123;<br>    <span class="hljs-comment">// 捕捉数据直接输出到图层中，保证会话状态同步   </span><br>    [(<span class="hljs-built_in">AVCaptureVideoPreviewLayer</span>*)<span class="hljs-keyword">self</span>.layer setSession:session];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)setupView &#123;<br><br>    [(<span class="hljs-built_in">AVCaptureVideoPreviewLayer</span> *)<span class="hljs-keyword">self</span>.layer setVideoGravity:<span class="hljs-built_in">AVLayerVideoGravityResizeAspectFill</span>];<br><br><br>    _singleTapRecognizer =<br>    [[<span class="hljs-built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> action:<span class="hljs-keyword">@selector</span>(handleSingleTap:)];<br><br>    _doubleTapRecognizer =<br>    [[<span class="hljs-built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> action:<span class="hljs-keyword">@selector</span>(handleDoubleTap:)];<br>    _doubleTapRecognizer.numberOfTapsRequired = <span class="hljs-number">2</span>;<br><br>    _doubleDoubleTapRecognizer =<br>    [[<span class="hljs-built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> action:<span class="hljs-keyword">@selector</span>(handleDoubleDoubleTap:)];<br>    _doubleDoubleTapRecognizer.numberOfTapsRequired = <span class="hljs-number">2</span>;<br>    _doubleDoubleTapRecognizer.numberOfTouchesRequired = <span class="hljs-number">2</span>;<br><br>    [<span class="hljs-keyword">self</span> addGestureRecognizer:_singleTapRecognizer];<br>    [<span class="hljs-keyword">self</span> addGestureRecognizer:_doubleTapRecognizer];<br>    [<span class="hljs-keyword">self</span> addGestureRecognizer:_doubleDoubleTapRecognizer];<br>    [_singleTapRecognizer requireGestureRecognizerToFail:_doubleTapRecognizer];<br><br>    _focusBox = [<span class="hljs-keyword">self</span> viewWithColor:[<span class="hljs-built_in">UIColor</span> colorWithRed:<span class="hljs-number">0.102</span> green:<span class="hljs-number">0.636</span> blue:<span class="hljs-number">1.000</span> alpha:<span class="hljs-number">1.000</span>]];<br>    _exposureBox = [<span class="hljs-keyword">self</span> viewWithColor:[<span class="hljs-built_in">UIColor</span> colorWithRed:<span class="hljs-number">1.000</span> green:<span class="hljs-number">0.421</span> blue:<span class="hljs-number">0.054</span> alpha:<span class="hljs-number">1.000</span>]];<br>    [<span class="hljs-keyword">self</span> addSubview:_focusBox];<br>    [<span class="hljs-keyword">self</span> addSubview:_exposureBox];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)handleSingleTap:(<span class="hljs-built_in">UIGestureRecognizer</span> *)recognizer &#123;<br>    <span class="hljs-built_in">CGPoint</span> point = [recognizer locationInView:<span class="hljs-keyword">self</span>];<br>    [<span class="hljs-keyword">self</span> runBoxAnimationOnView:<span class="hljs-keyword">self</span>.focusBox point:point];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.delegate) &#123;<br>        [<span class="hljs-keyword">self</span>.delegate tappedToFocusAtPoint:[<span class="hljs-keyword">self</span> captureDevicePointForPoint:point]];<br>    &#125;<br>&#125;<br><span class="hljs-comment">//屏幕坐标系转化为摄像头坐标系点</span><br>- (<span class="hljs-built_in">CGPoint</span>)captureDevicePointForPoint:(<span class="hljs-built_in">CGPoint</span>)point &#123;                      <span class="hljs-comment">// 3</span><br>    <span class="hljs-built_in">AVCaptureVideoPreviewLayer</span> *layer =<br>        (<span class="hljs-built_in">AVCaptureVideoPreviewLayer</span> *)<span class="hljs-keyword">self</span>.layer;<br>    <span class="hljs-keyword">return</span> [layer captureDevicePointOfInterestForPoint:point];<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h4 id="2-1-2-坐标空间转换"><a href="#2-1-2-坐标空间转换" class="headerlink" title="2.1.2 坐标空间转换"></a>2.1.2 坐标空间转换</h4><p>当使用<code>AVFoundation</code> 的捕捉API时，一定要理解屏幕坐标系和捕捉设备坐标系不同。iOS6.0之前的版本，要在这2个坐标空间进行转换非常困难。要精确的将屏幕坐标点转换为摄像头坐标点。开发者必须考虑诸如视频重力、镜像、图层变换和方向等因素进行综合计算。幸运的是，<code>AVCaptureVideoPreviewLayer</code>现在定义了一个转换方法让这一过程变得简单多了。</p>
<p><code>AVCaptureVideoPreviewLayer</code>定义了2个方法用于坐标系间进行转换：</p>
<p><code>captureDevicePointOfInterestForPoint:</code>获取屏幕坐标系的CGPoint 数据，返回转换得到的设备坐标系CGPoint数据。</p>
<p><code>pointForCaptureDevicePointOfInterest:</code>获取摄像头坐标系的CGPoint数据，返回转换得到的屏幕坐标系CGPoint 数据。<br><code>THPreviewView</code> 使用<code>captureDevicePointOfInterestForPoint:</code>方法将用户触点信息转换为摄像头设备坐标系的中的点。在项目中点击对焦和点击曝光功能实现会用到这个转换坐标点。</p>
<blockquote>
<p>文章重点，要弄明白预览视图的创建 和 坐标空间转换的方法。<br><a href="https://github.com/PlatoJobs/AVFoundationCustum">实例代码</a></p>
</blockquote>
]]></content>
      <categories>
        <category>iOS</category>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript学习图谱</title>
    <url>/2019/11/19/Javascript%E5%AD%A6%E4%B9%A0%E5%9B%BE%E8%B0%B1/</url>
    <content><![CDATA[<h4 id="Javascript学习的感觉："><a href="#Javascript学习的感觉：" class="headerlink" title="Javascript学习的感觉："></a>Javascript学习的感觉：</h4><blockquote>
<ul>
<li>A：本身知识很抽象、晦涩难懂，如：<code>闭包</code>、<code>内置对象</code>、<code>DOM</code>。</li>
</ul>
</blockquote>
<ul>
<li><p>B：本身内容很多，如函数库、对象库就一大堆。</p>
</li>
<li><p>C：混合多种编程思想。它里面不但牵涉面向过程编程思想，又有面向对象编程思想，同时，它的面向对象还和别的编程语言（如：<code>C++，JAVA，PHP</code>）不大一样。就好像又是新的一样，让你对曾经学的面向对象产生了怀疑……</p>
</li>
<li><p>D：辛苦学习后又看似和实际应用脱节。通常学了很久的js基础之后，变量、函数、对象你也都略知一二，但一到公司开发项目的时候，却又难以下手。因为公司在开发实际项目的时候通常都是直接用它的衍生库，如：<code>jquery，angular，boostrap，amaze，layui，ueditor</code>等，而这些库又多如牛毛，同时还有自己的难点。让你都不知道该学哪个好，甚至都怀疑自己学的是不是js了，好像有多个版本的js一样，总是学不完……</p>
</li>
</ul>
<h4 id="Javascript学习路"><a href="#Javascript学习路" class="headerlink" title="Javascript学习路"></a>Javascript学习路</h4><ul>
<li><p>1.首先要紧紧抓住它的地位</p>
<p>时刻都不能忘记，否则很容易犯“一叶障目不见泰山”的错误。不要学了很久就知道js是编程语言，就是写代码，而且特点就是乱七八糟就完了，那样是学不好js的。要时时抓住它的地位，确切的说是它在整个Web中的地位：它属于前端的核心，主要用来操控和重新调整<code>DOM</code>，通过修改<code>DOM</code>结构，从而来达到修改页面效果的目的。要用这个中心思想去指导后续的一切js的学习，并且形成条件反射。</p>
</li>
</ul>
<ul>
<li><p>2.要有一条清晰的学习路线</p>
<p>这个只能是过来人给你提供参考了。我的学习路线如下：</p>
<p>A：js基础部分，如：定义变量、函数、数组、字符串等的处理，内置函数、内置对象等；</p>
<p>B：js面向过程编程思想，封装出各个函数，试着用这些去做一些常见的小功能，如：选项卡、自定义多选按钮、自定义播放器、3D幻灯片；</p>
<p>C：js面向对象编程思想，试着去封装一些你自己的对象，提供出有意义的接口出来；</p>
<p>D：学了上述的内容，然后学常用的库，这里必须学<code>jquery</code>；<strong>不建议了</strong></p>
<p>E：学基于<code>jquery</code>之上的常见插件，如：<code>bootstrap，Layer</code>，富文本编辑器等；<strong>不建议了</strong></p>
<p>F：综合应用上面的多种库写实际项目的模板，多写几套。</p>
</li>
</ul>
<ul>
<li><p>3.从多角度去学习和领悟</p>
<p>充分调动你所学的东西，从多角度去做某一功能，如：以前你是从面向过程角度做的，现在改为从面向对象的角度再来做，或者继续做成可以直接使用的插件，提供属性、方法等出来。争取让你做的这个功能逐渐能使用到实际项目中来。这样的好处：既综合应用了你的所学，又能有实际意义。</p>
</li>
</ul>
<ul>
<li><p>4.注意培养信心</p>
<p>此时的你，不适合一来就看很复杂很炫的网页效果的源代码，也不适合一来就学jquery，angular，vue，<code>bootstrap</code>这些东西。这些内容包含了很多深奥的知识在里面，在没有任何基础的情况下直接学这些，会严重打击你的自信心。而此时你是弱小的，你需要的是培养信心，而不是反过来，否则结局很可能是“夭折”，离学有所成也就遥遥无期了。</p>
</li>
</ul>
<ol>
<li><p>多写总结</p>
<p>这种总结不但包括源代码、显示效果截图，还应该很容易犯的错误和对应的解决方法以及最后一两句精简的结论性语句。对自己写的总结不是写完了就了事了，要多回顾、多改进、多精简。到做项目的时候，应该是看里面的一两句话就知道是讲什么了，而不要再去看长篇大论了。</p>
</li>
</ol>
<ul>
<li><p>6.构建知识导图</p>
<p>这个可以让你越学越清晰，你可以按你喜欢的任何形式去做，只要自己印象深刻就行。</p>
</li>
</ul>
<blockquote>
<p> 注意：知识导图也应该是经常修改、修正，让它更合理、更清晰。</p>
</blockquote>
<p><img src="JavaScript变量.gif" alt="JavaScript变量"><br><img src="JavaScript运算符.gif" alt="JavaScript运算符"><br><img src="JavaScript数组.gif" alt="JavaScript数组"><br><img src="JavaScript流程语句.gif" alt="JavaScript流程语句"></p>
<p><img src="JavaScript字符串函数.gif" alt="JavaScript字符串函数"><br><img src="JavaScript函数基础.gif" alt="JavaScript函数基础"></p>
<p><img src="JavaScript基础DOM操作.gif" alt="JavaScript基础DOM操作"><br><img src="DOM对象.png" alt="JavaScript DOM对象"><br><img src="BOM浏览器对象模型.png" alt="BOM浏览器对象模型"><br><img src="JavaScript正则表达.gif" alt="JavaScript正则表达"></p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>学习图谱，Javascript知识</tag>
      </tags>
  </entry>
  <entry>
    <title>男生其实没多少选择</title>
    <url>/2019/12/15/%E7%94%B7%E7%94%9F%E5%85%B6%E5%AE%9E%E6%B2%A1%E5%A4%9A%E5%B0%91%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<blockquote>
<p>如果人生没有那么多的阴差阳错，是不是我们就真的可以在一起陪对方走一段路？尽管我不知道我们能不能够陪对方共度余生，但我总觉得我们之间应该会有一场不错的爱情。 喜欢上一个人的时候，我们常常说不清原因。但决定放弃一个人的时候，却都有迹可循。</p>
</blockquote>
<p>男生其实没多少选择的，要么放弃表白，要么表白失败后再放弃。聪明一点的，基本都不用表白了，女生对男的完全没好感不主动不回复不搭理，表白一百次也没用啊。<br>我加了一个女同事微信没通过，第二次再加，那女孩投诉她领导那然后她领导找到我领导过来训话了，不喜欢你就别骚扰好么？我靠，加下微信好友算哪门子骚扰？事情传开以后，我几乎变成了公司的笑柄，导致后面又新来了一个单身单纯又貌美如花的妹子，我都没心思去追了。<br>你以为现在的女孩有那么好追？看不上你，你追一万年也不搭理你！多少女孩子，一加微信，聊天不到十句就拉黑得？多少女孩子第一次约饭立马变成最后一次约饭的？多少女孩子已经无比冷漠绝对不允许你染指的？女孩子没想法，果断放弃。天涯何处无芳草，何必单恋一枝花？爱跪舔你去跪舔，老子坚决不做备胎。<br>第一次表白失败，百分之90的人会放弃。输了就是输了，死缠烂打有用的年代早TM过去了！之前你追姑娘，姑娘可能时间久了被打动。现在你追姑娘，姑娘追别的男孩子，你长四条腿也没有用啊，还不如你买个四轮胎的汽车 转身去吸引其他妹子呢。那些表白不放弃的，再多受点伤以后也会变聪明的。<br>舔狗没有好下场的，传说中有好下场的舔狗实在是可遇不可求，我们不指望自己有那运气了。其实，被不喜欢的人追，实在不好玩，觉得太委屈太无聊甚至太痛苦了。因为，我作为一个男的，以前也有妹子倒追我，但是因为妹子不是太好看，我告诉你，没有一个妹子得到的我的点头。我深有体会被不喜欢的人追并不好玩，除非我心理变态有意戏弄那些倒追的，但是，我舍不得不忍心也坚决不会那么干。真正有良知的姑娘，不会养那么多备胎甚至不忍心把其他男的当备胎。<br>可以永远不喜欢你，但是，起码告诉你止损啊。可惜，这样漂亮又善良的妹子实在是少之又少。拒绝别人的妹子，难道心里没点B数？不喜欢就是不喜欢，你拒绝了人家，还不让人家转身离去，你意欲何为？你给不了人家未来，就不要耽误人家青春，反正掏钱买单吃饭送礼物的又不是你。当然，表白失败不代表彻底失败，转身离开绝对不是什么错误决定，女孩子真的心里有你，绝对会主动再回复你跟你联系的。之前在山东济南，我追过一个张姓妹子，后面跟妹子逛街吃冒菜去书店，各种一起玩。妹子后面告诉我，她有男友了(实际上没有)，我一听，我靠，三个人的游戏还怎么玩？立马就撤退了，我不仅仅不再联系她，还立马切换了城市去了海南，两个人都不在一个城市了，理论上来讲，山高路远话也讲清楚说明白我们彻底凉凉了。然而，大概过了一个月，妹子主动QQ发消息过来了，说在大街上看到一个男的很像我，问我在哪里？我说不可能的，我在海南，你在济南，根本没有看到我背影的可能。后面妹子主动告诉我，她心里有我的，说有男友只是试探我。表白失败，基本百分之90以上就该放弃，转身离开了，不仅仅是不纠缠不多问不抱怨，可以找个酒馆或者咖啡店或者网吧疗下伤，真的花不了多少钱。<br>很多女孩子高估了自己在男孩子心里的地位，非你不可的男生要么少之又少要么仅存在偶像剧或者你自己的幻想心中。倒追我的妹子，基本都不到一个月甚至15天都不用，人家也会放弃会止损会权衡利弊啊。<br>反正，表白失败就走，妹子心里真的有你，绝对会主动联系你，担心你受伤，担心你转身喜欢其他人，担心你消极度日颓废不堪，，，那么多那么多的担心，只是因为她心疼。不心疼你的女孩，你追不上的，因为，她不心疼你，就是在心疼其他人，或者等待其他能撩动她心弦的男人。很多男同胞都走进了一个误区吧，就是看自己跟妹子聊的嗨妹子回复快，看自己请吃饭妹子欣然赴约，甚至看妹子给自己朋友圈点赞，就窃以为自己有戏只要勇敢表白一下就能收获幸福双宿双飞。<br>真的错了，你是真没看到妹子在自己喜欢的男子面前的表现，恨不得扑上去亲两口，那眼神像饿了三天的人看见鸡腿，那激动，像被判死刑的囚犯听到刑满释放一样欢呼雀跃，那主动，就像看见流星一样赶紧推开门窗要去许愿！很遗憾，如果妹子没主动为你做过什么，真的就大概率是你在单相思暗恋一个人演戏。有过被妹子倒追经验的，基本都会惊讶不已。妹子喜欢你的时候，可以吃饭主动买单展示她的慷慨柔情。<br>妹子喜欢你的时候，看电影她主动邀请你，你不需要拿出支付宝，她会主动联系你。妹子喜欢你的时候，你两天不联系她，她会心烦意乱情绪低落。妹子喜欢你的时候，你的心情情绪忧愁，她都能感觉到，她会心疼会担心，你不开心，她会放下一切来陪你。她会为了请你吃饭而拒绝其他男人请她吃饭，她会为了顾及你的感受对其他男人冷若冰霜，她会为了跟你一起的活动主动问你时间问你位置问你喜欢吃啥。<br>妹子主动的越少，你表白失败的概率越高。很简单的道理，妹子为了你连一百块钱都舍不得花，她会舍得为你付出24小时的青春？<br>做梦吧，很多渣男吸引到的妹子脑残到倒贴得心甘情愿，因为妹子觉得值啊！你不值钱，你发188红包请妹子看电影，妹子也是人在心不在的，有什么用呢？跪舔有用的话，就没有这么多单身狗了。<br>因为，你跪舔妹子的时候，妹子也有想跪舔的对象，所以，你跪舔的再卖力也没什么用。<br>你不是她的他，就走呗。是的话，一定会有后续的！</p>
]]></content>
      <categories>
        <category>情感</category>
      </categories>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title>OC内部可变对象和不可变对象的深(复制)拷贝问题</title>
    <url>/2020/03/09/OC%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E5%92%8C%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1-%E5%A4%8D%E5%88%B6-%E6%8B%B7%E8%B4%9D%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>OC内部：可变对象和不可变对象的深(复制)拷贝问题思考：</p>
<ul>
<li><p>不可变对象:<br>例如<code>NSString</code>对象，因为<code>NSString</code>对象是常量字符串,所以，不可以更改其内容,但是可以修改指向该字符串的指针指向。当对<code>NSString</code>对象做深拷贝时,如果是<code>copy</code>复制方式，其实就是浅复制，只是复制了同一个对象的指针；如果是<code>mutableCopy</code>复制方式，系统会分配一个新的内存空间用来存放复制出来的<code>NSMutableString</code>对象，此时地址是新的，内容是一样的，他们正在被不同的实例变量字符串指针指着。</p>
</li>
<li><p>可变对象：<br>例如<code>NSMutableString</code>对象，因为<code>NSMutableString</code>对象是可变字符串,所以，可以改变其内容。当<code>NSMutableString</code>对象做深拷贝时,系统会分配一个新的内存空间用来存放复制出来的<code>NSMutableString</code>对象，此时地址是新的，内容是一样的，他们正在被不同的实例变量字符串指针指着。</p>
</li>
</ul>
<blockquote>
<p>总结：对于系统的非容器类对象，我们可以认为，如果对一不可变对象复制，<code>copy</code>是指针复制（浅拷贝）和<code>mutableCopy</code>就是对象复制（深拷贝）。<br>   如果是对可变对象复制，都是深拷贝，但是copy返回的对象是不可变的的。<br>1：对于不可变对象，copy都是浅复制，即指针复制。mutableCopy 都是Alloc一个新对象返回。<br>2：对于可变对象，copy和mutableCopy都是Alloc新对象返回。<br>3：不论是可变还是不可变对象，copy返回的对象都是不可变的，mutableCopy返回的对象都是可变的。<br>4：容器内对象，不论是可变的还是不可变的，copy，mutableCopy返回的对象里所包含的对象的地址和之前都是一样 的，即容器内对象都是浅拷贝。</p>
</blockquote>
<h4 id="一、不可变对象的深复制"><a href="#一、不可变对象的深复制" class="headerlink" title="一、不可变对象的深复制"></a>一、不可变对象的深复制</h4><ul>
<li>Person.h<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span><br> <br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span> : <span class="hljs-title">NSObject</span>&lt;<span class="hljs-title">NSCopying</span>&gt;</span><br><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">copy</span>)<span class="hljs-built_in">NSString</span> *name;<br>-(<span class="hljs-keyword">id</span>)initWithName:(<span class="hljs-built_in">NSString</span> *)name;<br>-(<span class="hljs-keyword">void</span>)print;<br><span class="hljs-keyword">@end</span><br><br></code></pre></td></tr></table></figure>
<ul>
<li>Person.m<figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec"><br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;Person.h&quot;</span></span><br>  <br> <span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Person</span></span><br>-(<span class="hljs-keyword">id</span>)initWithName:(<span class="hljs-built_in">NSString</span> *)name<br> &#123;<br>    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">self</span>)<br>     &#123;<br>         _name = [name mutableCopy]; <span class="hljs-comment">//不可变深复制mutableCopy</span><br>        <span class="hljs-comment">//_name = [name copy];//不可变深复制copy</span><br>        <br>&#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br> &#125;<br> -(<span class="hljs-keyword">id</span>)copyWithZone:(<span class="hljs-built_in">NSZone</span> *)zone<br> &#123;<br>     <span class="hljs-keyword">return</span> [[Person alloc]initWithName:_name];<br> &#125;<br><span class="hljs-keyword">@end</span><br><br><br></code></pre></td></tr></table></figure></li>
<li>主函数测试</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//  main.m</span><br><br> <br><br><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span><br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;Person.h&quot;</span></span><br><span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])<br>&#123;<br>    <span class="hljs-keyword">@autoreleasepool</span><br>    &#123;<br>        <span class="hljs-built_in">NSMutableString</span> *name = [<span class="hljs-built_in">NSMutableString</span> stringWithString:<span class="hljs-string">@&quot;Jobs&quot;</span>];<br>        Person *p1 = [[Person alloc]initWithName:name];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@----%p&quot;</span>,name,p1.name);<br>        <br>        Person *p2 = [p1 <span class="hljs-keyword">copy</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@----%p&quot;</span>,name,p2.name);<br>        <br>        [name appendString:<span class="hljs-string">@&quot;Tom&quot;</span>];<br>        Person *p3 = [[Person alloc]initWithName:name];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@----%p&quot;</span>,name,p3.name);<br>        <br>        Person *p4 = [p3 <span class="hljs-keyword">copy</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@----%p&quot;</span>,name,p4.name);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li>测试结果<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-15</span> <span class="hljs-number">22</span>:<span class="hljs-number">14</span>:<span class="hljs-number">33.544</span> 测试[<span class="hljs-number">2042</span>:<span class="hljs-number">151149</span>] Jobs---<span class="hljs-number">-0x100206d10</span><br><br><span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-15</span> <span class="hljs-number">22</span>:<span class="hljs-number">14</span>:<span class="hljs-number">33.545</span> 测试[<span class="hljs-number">2042</span>:<span class="hljs-number">151149</span>] Jobs---<span class="hljs-number">-0x100300360</span><br><br><span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-15</span> <span class="hljs-number">22</span>:<span class="hljs-number">14</span>:<span class="hljs-number">33.545</span> 测试[<span class="hljs-number">2042</span>:<span class="hljs-number">151149</span>] JobsTom---<span class="hljs-number">-0x100300410</span><br><br><span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-15</span> <span class="hljs-number">22</span>:<span class="hljs-number">14</span>:<span class="hljs-number">33.545</span> 测试[<span class="hljs-number">2042</span>:<span class="hljs-number">151149</span>] JobsTom---<span class="hljs-number">-0x100400010</span><br><br>Program ended with exit code: <span class="hljs-number">0</span><br><br>以上结果为mutableCopy深复制的结果：复制后一样的内容，可是各自所在的地址值是不同的，说明了系统为新创建的对象开辟了内存，这就是真正意义的深复制。<br></code></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-15</span> <span class="hljs-number">22</span>:<span class="hljs-number">15</span>:<span class="hljs-number">08.773</span> 测试[<span class="hljs-number">2050</span>:<span class="hljs-number">151390</span>] Jobs---<span class="hljs-number">-0x100206d10</span><br><br><span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-15</span> <span class="hljs-number">22</span>:<span class="hljs-number">15</span>:<span class="hljs-number">08.774</span> 测试[<span class="hljs-number">2050</span>:<span class="hljs-number">151390</span>] Jobs---<span class="hljs-number">-0x100206d10</span><br><br><span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-15</span> <span class="hljs-number">22</span>:<span class="hljs-number">15</span>:<span class="hljs-number">08.775</span> 测试[<span class="hljs-number">2050</span>:<span class="hljs-number">151390</span>] JobsTom---<span class="hljs-number">-0x100207810</span><br><br><span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-15</span> <span class="hljs-number">22</span>:<span class="hljs-number">15</span>:<span class="hljs-number">08.775</span> 测试[<span class="hljs-number">2050</span>:<span class="hljs-number">151390</span>] JobsTom---<span class="hljs-number">-0x100207810</span><br><br>Program ended with exit code: <span class="hljs-number">0</span><br><br><br>以上结果为<span class="hljs-keyword">copy</span>深复制结果，可以看出复制后一样的内容，可是它们的地址值是一样，说明了这并不是真正意义的深复制，而是假深复制，即最终结果是只是复制了指针。<br></code></pre></td></tr></table></figure>
<h4 id="二、可变对象的深复制"><a href="#二、可变对象的深复制" class="headerlink" title="二、可变对象的深复制"></a>二、可变对象的深复制</h4></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//  Person.h</span><br><span class="hljs-comment">//  测试</span><br><br><br><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span> : <span class="hljs-title">NSObject</span>&lt;<span class="hljs-title">NSCopying</span>&gt;</span><br><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">copy</span>)<span class="hljs-built_in">NSMutableString</span> *name;<br>-(<span class="hljs-keyword">id</span>)initWithName:(<span class="hljs-built_in">NSMutableString</span> *)name;<br>-(<span class="hljs-keyword">void</span>)print;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//  Person.m</span><br><span class="hljs-comment">//  测试</span><br><br><br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;Person.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Person</span></span><br>-(<span class="hljs-keyword">id</span>)initWithName:(<span class="hljs-built_in">NSMutableString</span> *)name<br>&#123;<br>    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">self</span>)<br>    &#123;<br>        <span class="hljs-comment">//_name = [name copy];//可变深复制copy</span><br>        _name = [name mutableCopy];<span class="hljs-comment">//可变深复制mutableCopy</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br>-(<span class="hljs-keyword">id</span>)copyWithZone:(<span class="hljs-built_in">NSZone</span> *)zone<br>&#123;<br>    <span class="hljs-keyword">return</span> [[Person alloc]initWithName:_name];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//  main.m</span><br><span class="hljs-comment">//  测试</span><br><br><br><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span><br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;Person.h&quot;</span></span><br><span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])<br>&#123;<br>    <span class="hljs-keyword">@autoreleasepool</span><br>    &#123;<br>        <span class="hljs-built_in">NSMutableString</span> *name = [<span class="hljs-built_in">NSMutableString</span> stringWithString:<span class="hljs-string">@&quot;Jobs&quot;</span>];<br>        <br>        Person *p1 = [[Person alloc]initWithName:name];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@----%p&quot;</span>,name,name);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@----%p&quot;</span>,p1.name,p1.name);<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-15</span> <span class="hljs-number">22</span>:<span class="hljs-number">54</span>:<span class="hljs-number">12.110</span> 测试[<span class="hljs-number">1973</span>:<span class="hljs-number">145250</span>] Jobs---<span class="hljs-number">-0x1001002d0</span><br><span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-15</span> <span class="hljs-number">22</span>:<span class="hljs-number">54</span>:<span class="hljs-number">12.111</span> 测试[<span class="hljs-number">1973</span>:<span class="hljs-number">145250</span>] Jobs---<span class="hljs-number">-0x100106c90</span><br>Program ended with <span class="hljs-built_in">exit</span> code: <span class="hljs-number">0</span><br><br>以上结果为可变对象的复制，采用copy复制时，复制出的内容是一样的，但是它们的地址值是不相同的，所以这是真正意义的深复制。<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-15</span> <span class="hljs-number">22</span>:<span class="hljs-number">56</span>:<span class="hljs-number">05.744</span> 测试[<span class="hljs-number">1981</span>:<span class="hljs-number">145831</span>] Jobs---<span class="hljs-number">-0x1001147a0</span><br><span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-15</span> <span class="hljs-number">22</span>:<span class="hljs-number">56</span>:<span class="hljs-number">05.745</span> 测试[<span class="hljs-number">1981</span>:<span class="hljs-number">145831</span>] Jobs---<span class="hljs-number">-0x100114a40</span><br>Program ended with <span class="hljs-built_in">exit</span> code: <span class="hljs-number">0</span><br><br>以上结果为可变对象的复制，采用mutableCopy复制时，复制出的内容也是一样的,但是它们的地址值也是不同的，这也是真正意义的深复制。<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>copy</tag>
      </tags>
  </entry>
  <entry>
    <title>”音频编码格式“</title>
    <url>/2020/03/09/%E2%80%9D%E9%9F%B3%E9%A2%91%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E2%80%9C/</url>
    <content><![CDATA[<blockquote>
<p>我们通常从音乐App（如：酷狗音乐、QQ音乐）听歌时，会看到一首歌需要的存储空间大概是10M左右，对于手机磁盘来说这是可以接受的。但在网络中实时在线传播的话，这个数据量可能就太大了，所以必须对其进行压缩编码。<br>压缩编码的基本指标之一就是压缩比，压缩比通常小于1（否则就没有必要去做压缩）。</p>
</blockquote>
<ul>
<li>压缩算法</li>
</ul>
<blockquote>
<p>压缩算法包含无损压缩和有损压缩，常用压缩格式中，用的较多的是有损压缩</p>
</blockquote>
<ul>
<li>无损压缩 ：解压后的数据可以完全复原</li>
<li>有损压缩：解压后的数据不能完全复原，会丢失一部分信息，压缩比越小，丢失的信息就越多，信号还原后失真就会越大</li>
</ul>
<ul>
<li>压缩编码原理</li>
</ul>
<blockquote>
<p>压缩编码原理实际上是压缩掉冗余信号，冗余信号是指不能被人耳感知到的信号，包含人耳听觉范围之外的音频信号以及被掩蔽掉的音频信号<br>常用压缩编码格式</p>
</blockquote>
<ol>
<li>PCM编码<br>音频的裸数据格式就是脉冲编码调制(Pulse Code Modulation, PCM)数据，是 按照一定的格式记录采样和量化后的数字数据，描述一段PCM数据需要这几个概念：量化格式(sampleFormat)、采样率(sampleRate)、声道数(channel)</li>
<li>WAV编码<br>WAV编码的一种实现（有多种实现方式，但是都不会进行压缩操作）就是在PCM数据格式的前面加上44字节，分别用来描述PCM的采样率、声道数、数据格式等信息</li>
<li>MP3编码<br>MP3具有不错的压缩比，使用<code>LAME编码</code>（MP3编码格式的一种实现）的中高码率的MP3文件，听感上非常接近源WAV文件<br>特点：音质在128Kbit/s 以上表现还不错，压缩比比较高，大量软件和硬件都支持，兼容性好<br>使用场合：高比特率下对兼容性有要求的音乐欣赏</li>
<li>AAC编码<br>AAC是新一代的音频有损压缩技术，通过一些附件的编码技术（比如PS、SBR等），衍生出了LC-AAC、HE-AAC、HE-AAC v2三种主要的编码格式。<code>LC-AAC</code>是比较传统的AAC，相对而言，其主要应用于中高码率场景的编码（≥ 80Kbit/s） ；HE-AAC(相当于AAC+SBR)主要应用于中低码率场景的编码（≤80Kbit/s)；而<code>HE-AACv2</code>（相当于AAC+SBR+PS)主要用于低码率场景的编码（≤48Kbit/s)。大部分编码器都设置为≤48Kbit/s自动启用PS技术，而&gt;48Kbit/s则不加PS，相当于普通的HE-AAC<br>特点：在小于128Kbit/s的码率下表现优异，并且多用于视频中的音频编码<br>使用场合：128Kbit/s以下的音频编码，多用于视频中音频轨的编码</li>
<li>Ogg<br>一种非常有潜力的编码，在各种码率下都有比较优秀的表现，尤其在中低码率场景下。Ogg除了音质好之外，Ogg有着非常出色的算法，可以用更小的码率达到更好的音质，128Kbit/s的Ogg比192Kbit/s甚至更高码率的MP3还要出色<br>特点：可以用比MP3更小的码率实现比MP3更好的音质，高中低码率下均有良好表现<br>缺点：兼容性不够好，流媒体特性不支持，目前没有美图服务软件的支出，因此基于Ogg的数字广播还无法实现，Ogg目前受支持的情况还不够好，无论是软件上的还是硬件上的支持，都无法和MP3箱体并论<br>适用场合：语音聊天的音频消息场景</li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>加密算法</title>
    <url>/2020/03/09/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="一、对称密钥算法"><a href="#一、对称密钥算法" class="headerlink" title="一、对称密钥算法"></a>一、对称密钥算法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>对称加密（Symmetric-key algorithm）</code>是指加解密用同一个密钥的算法，根据具体实现分为流加密和分组加密两种类型：</p>
<ul>
<li><code>流加密（Stream cipher）</code>是对称加密常用的一种实现方法，加密和解密双方使用相同伪随机加密数据流，一般都是逐位异或随机密码本的内容。</li>
<li><code>分组加密加密（Block cipher）</code>，也叫<strong>块加密</strong>，将明文分成多个等长的模块（block），使用确定的算法和对称密钥对每组分别加密解密。现代分组加密建立在迭代的思想上产生密文。迭代产生的密文在每一轮加密中使用不同的子密钥，而子密钥生成自原始密钥。</li>
</ul>
<blockquote>
<p>对称加密普遍比非对称加密速度要快，实现更简单，适合大量内容的加密</p>
</blockquote>
<h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><p><code>DES (Data Encryption Standard)</code> 是一种分组加密算法</p>
<p>DES算法的入口参数有三个:Key,Data,Mode，Key是密钥密钥占7个字节56位（64位里另外8位是用来校验的），Data是加密内容，占8个字节64位，Mode是加密还是解密。</p>
<p>DES算法于1976被确定，现在已经被认为不够安全，主要原因是56位的密钥过短。据说这个算法因为包含一些机密设计元素，被怀疑内含美国国家安全局（NSA）的后门。</p>
<p>DES算法有个拓展算法叫3DES，就是对数据块进行三次DES加密，增加爆破成本，但本质上也不够安全。</p>
<h3 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h3><p><code>RC4 (Rivest Cipher 4)</code>是一种流加密算法</p>
<p>RC4起源于1987年，现在已经被认为不够安全。<br>RC4由伪随机数生成器和异或运算组成。RC4的密钥长度可变，范围是[1,255]。RC4一个字节一个字节地加解密。给定一个密钥，伪随机数生成器接受密钥并产生一个S盒。S盒用来加密数据，而且在加密过程中S盒会变化。</p>
<p>由于异或运算的对合性，RC4加密解密使用同一套算法。这个算法实现起来很简单，只用了最基本的加、异或、循环，话说我大学时某个课程设计的做的加密算法就是简化版的RC4。</p>
<p>之后还出现了RC5、RC6加密算法，但RC5和RC6都是分组加密，和RC4原理并不一样。</p>
<h3 id="RC5"><a href="#RC5" class="headerlink" title="RC5"></a>RC5</h3><p><code>RC5 （Rivest Cipher 5）</code> 是一种分组加密算法，它和RC2，RC4，RC6都是同一个叫Ronald Rivest的人设计的。</p>
<p>相比RC4，RC5的密钥成了128位，但RC5仍然只需要基础的加、异或、循环运算，可以在很多硬件上实现。RC5有三个参数：字的大小，循环轮数（round），密钥中的8位字节个数，所以可以说RC5是一种可变加密算法。实际上循环轮数12轮以下的RC5都被认为是不安全的，会被差分分析法（Differential cryptanalysis）攻击，18-20轮才足够安全。</p>
<p>目前来说，RC5还是挺安全的，因为实现简单，消耗资源少，在一些传感器、嵌入式设备上使用很合适。</p>
<h3 id="RC6"><a href="#RC6" class="headerlink" title="RC6"></a>RC6</h3><p><code>RC6 （Rivest Cipher 6）</code> 是RC5的加强版，也属于分组加密算法。</p>
<p>RC6算法在RC5算法基础之上针对RC5算法中的漏洞，主要是循环移位的位移量并不取决于要移动次数的所有比特，通过采用引入乘法运算来决定循环移位次数的方法，对RC5算法进行了改进，从而大大提高了RC6算法的安全性。</p>
<p>RC6曾作为AES（高级加密标准）备选算法之一，但最终AES选择了Rijndael算法。</p>
<h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><p>最后压轴出场的是最著名的<code>单密钥对称加密</code>算法AES (Rijndael)，AES是Advanced Encryption Standard的缩写，是美国国家标准与技术研究院2001年发布的新加密标准。</p>
<p>AES现在就是指的限定了区块长度和密钥长度的Rijndael算法，同样属于分组加密算法，该算法是两位比利时学者1998年发布的。起初还有很多算法参与了AES甄选，最终Rijndael凭借高安全性和清晰的数学结构而被选用。</p>
<p>AES将Rijndael算法的区块长度固定为128位，密钥长度可选128，192或256比特（Rijndael原版支持128-256，n*32的区块长度和密钥长度）。</p>
<p>AES算法包括4个步骤：</p>
<ol>
<li><code>AddRoundKey</code>—矩阵中的每一个字节都与该次回合密钥（round key）做XOR运算；每个子密钥由密钥生成方案产生。</li>
<li><code>SubBytes</code>—通过一个非线性的替换函数，用查找表的方式把每个字节替换成对应的字节。</li>
<li><code>ShiftRows</code>—将矩阵中的每个横列进行循环式移位。</li>
<li><code>MixColumns</code>—为了充分混合矩阵中各个直行的操作。这个步骤使用线性转换来混合每内联的四个字节。最后一个加密循环中省略MixColumns步骤，而以另一个AddRoundKey替换。</li>
</ol>
<p>截止现在（2016），AES在算法层面上是安全的。2005年有人公布过一种缓存时序攻击法，但使用场景非常极端。</p>
<h2 id="二、非对称秘钥算法"><a href="#二、非对称秘钥算法" class="headerlink" title="二、非对称秘钥算法"></a>二、非对称秘钥算法</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><code>公钥加密</code>的思想于1974年被提出，相比对称加密无需共享密钥，更加安全。但是没法加密大量数据，一般用来加密对称加密的密钥，而用对称加密加密大量数据。<br>非对称加密的原理如下：</p>
<ul>
<li>消息发送方A在本地构建密钥对，公钥和私钥；</li>
<li>消息发送方A将产生的公钥发送给消息接收方B；</li>
<li>B向A发送数据时，通过公钥进行加密，A接收到数据后通过私钥进行解密，完成一次通信；</li>
<li>反之，A向B发送数据时，通过私钥对数据进行加密，B接收到数据后通过公钥进行解密。</li>
</ul>
<h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p><code>RSA</code>算法是最著名的非对称加密算法。RSA是1977年提出的，名字来源于Rivest、Shmir和Adleman三位作者。<br>我们平时用到的SSL协议，TLS协议都采用了该算法加密，<code>SSH（Secure Shell）</code>也是基于RSA实现的。</p>
<p>RSA的数学基础是极大整数的因数分解，具体实现过程如下：</p>
<ul>
<li>随意选择两个大的质数p和q，p不等于q，计算N=pq。</li>
<li>根据欧拉函数，求得r=varphi (N) = varphi(p) * varphi(q)=(p-1)(q-1)</li>
<li>选择一个小于r的整数e，使e与r互质。并求得e关于r的模反元素，命名为d。</li>
<li>(N,e)是公钥，(N,d)是私钥。</li>
<li>加密时，加密的块 n^e ≡ c(MOD N)，得到的c就是密文。解密时，c^d ≡ n(MOD N)。</li>
</ul>
<p>要破解RSA要解决怎么把一个极大数分解为两个质数p和q，然后通过欧拉函数再得到公钥和私钥。但极大数因数分解目前还没什么好办法，所以只要N足够大，RSA在算法层面上就是安全的。</p>
<p>当N的长度为256时，用普通电脑花几小时即可以分解，当N长度为512时需要花数月时间分解，1024时需要大型分布式系统才能分解，长度到2046则可以确保是完全安全的。目前已有记录里，被分解的极大数最大位数是768位，于2009年被分解。</p>
<p>RSA也常被用来做数字签名，在消息内附加一个私钥加密过的散列值（Message digest），以此来确保消息发送人是可靠的。<br><strong>公钥私钥对生成</strong></p>
<figure class="highlight vala"><table><tr><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 1.该命令会生成1024位的私钥,此时我们就可以在当前路径下看到rsa_private_key.pem文件了.</span><br>genrsa -out rsa_private_key.pem <span class="hljs-number">1024</span><br><span class="hljs-meta"># 2.生成的密钥不是pcs8格式，我们需要转成pkcs8格式</span><br>pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM -nocrypt<br><span class="hljs-meta"># 3.生成 rsa 公钥</span><br>rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem<br><br></code></pre></td></tr></table></figure>
<h3 id="椭圆曲线算法"><a href="#椭圆曲线算法" class="headerlink" title="椭圆曲线算法"></a>椭圆曲线算法</h3><p>椭圆曲线算法（Elliptic curve cryptography）也是一种非对称加密算法，于1985年被提出，以下简称ECC。<br>相比RSA，同等破解难度时ECC的秘钥更短。另外，ECC可定义椭圆曲线群的双线性映射，该特性可能将来被用来实现身份基加密体制（Identity-Based Encryption，IBE）。</p>
<p>ECC的数学基础是求椭圆曲线离散对数问题。实现比较复杂我就不写了，因为我也看不懂(⊙﹏⊙)b。 也正因为实现复杂，ECC的加解密速度慢，消耗资源也更多。</p>
<p>ECC也同样可以实现数字签名，叫做ECDSA。</p>
<p>ECC的秘钥长度最小要求是160位，建议是163位。目前已有的破解记录是109位，一万台机器破解了一年半。所以ECC在算法层面是可以保证安全的。</p>
<h3 id="ElGamal"><a href="#ElGamal" class="headerlink" title="ElGamal"></a><a href="https://yelog.org/#ElGamal" title="ElGamal"></a>ElGamal</h3><p>ElGamal加密算法是一种用于对采用Diff-Hellman方式进行交换的公钥进行加密，常被用于数字签名和密钥加密的算法，ElGamal的数学基础是有限域上的离散对数问题。</p>
<p>选择一个素数p和两个随机数g 、x （g、 x &lt; p ），计算 y ≡ g^x（ mod p ） ，则其公钥为 y, g 和p ，私钥是x ，g和p可由一组用户共享。</p>
<p>ElGamal方法中一个明文对应两个加密结果(g^a和g^b)，因此密文空间的大小是明文空间大小的两倍，也就是说纵观整个通信过程，收发密文的大小是实际明文大小的两倍。</p>
<h2 id="三、哈希算法"><a href="#三、哈希算法" class="headerlink" title="三、哈希算法"></a>三、哈希算法</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>我们经常说MD5加密，但追根究底的话，MD5应该是哈希函数（Hash Function），而哈希函数并不等同于加密（Encrypt），不过我们平常也把哈希叫做加密。哈希函数也叫散列函数，散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用来代表一个短的随机字母和数字组成的字符串。</p>
<p>说人话就是哈希（Hash）是将目标文本转换成具有相同长度的、不可逆的杂凑字符串，而加密（Encrypt）是将目标文本转换成具有不同长度的、可逆的密文。</p>
<p>哈希主要用来校验身份，错误检查，完整性检查。</p>
<h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><p>MD5（Message-Digest5 Algorithm）即消息摘要算法，是最著名、应用最为广泛的一种哈希算法，于1992年被公开。MD5之前还有MD4、MD3、MD2等哥哥算法，MD5是最终的改进版。</p>
<p>MD5输入不定长度信息，输出固定长度为128-bits的散列</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>AES</tag>
        <tag>RSA</tag>
        <tag>MD5</tag>
      </tags>
  </entry>
  <entry>
    <title>MVP架构</title>
    <url>/2020/03/27/MVP%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h1><p>MVP模式是MVC模式的一个演化版本（好像所有的模式都是出自于MVC~~），MVP全称Model-View-Presenter。顾名思义，</p>
<p>Model：与MVC中的model没有太大的区别。主要提供数据的存储功能，一般都是用来封装网络获取的json数据的集合。Presenter通过调用Model进行对象交互。</p>
<p>View：这里的View与MVC中的V又有一些小差别，这个View可以是viewcontroller、view等控件。Presenter通过向View传model数据进行交互。</p>
<p>Presenter：作为model和view的中间人，从model层获取数据之后传给view，使得View和model没有耦合。</p>
<p>说了那么多，总得来说MVP的好处就是解除view与model的耦合，使得view或model有更强的复用性。</p>
<h1 id="MVP模式下的三个特性的分析"><a href="#MVP模式下的三个特性的分析" class="headerlink" title="MVP模式下的三个特性的分析"></a>MVP模式下的三个特性的分析</h1><ul>
<li>任务均摊 — 我们将最主要的任务划分到 Presenter 和 Model，而 View 的功能较少；</li>
<li>可测试性 — 非常好，由于一个功能简单的 View 层，所以测试大多数业务逻辑也变得简单；</li>
<li>易用性 — 代码量比 MVC 模式的大，但同时 MVP 的概念却非常清晰。</li>
</ul>
<p>iOS MVP 示意图</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2139357-ccd2a84fe9568245.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200" alt="img"></p>
<p>在这里输入图片标题</p>
<ul>
<li>就 MVP 而言，UIViewController 的子类实际上就是 Views 并不是 Presenters。这点区别使得这种模式的可测试性得到了极大的提高，付出的代价是开发速度的一些降低，因为必须要做一些手动的数据和事件绑定。<br>还有一些其他形态的 MVP — 监控控制器的 MVP。这个变体包含了 View 和 Model 之间的直接绑定，但是 Presenter 仍然来管理来自 View 的动作事件，同时也能胜任对 View 的更新。</li>
</ul>
<h1 id="规范的MVP设计模式"><a href="#规范的MVP设计模式" class="headerlink" title="规范的MVP设计模式"></a>规范的MVP设计模式</h1><ul>
<li>Model 层应该不仅仅是创建一个数据对象，还应该包含网络请求，以及数据 SQLite 的 CRUD 操作（比如 iOS 平台，一般以 FMDB 框架直接操作 sql，或者用 CoreData) 。一般可以将数据对象是否需要缓存设计成一个字段 isCache，或者针对整个项目设计一个开存储关，决定整个项目是否需要数据缓存。我们常见的新闻类 App，在离线的时候看到的数据，都是做了缓存处理的。比如一些金融类的 App，实时性比较高，是不做缓存的。</li>
<li>View 层比较简单明了，就是 View 的一些封装、重用。在一款精心设计过的 App 里面，应该有很多 View 是可以封装重用的。比如一些自己的 TableViewCell，自己设计的 Button，一些 View（包含一些子 View，UI 精心设计过，在项目里多处出现的）等等。</li>
<li>Presenter 层并不涉及数据对象的网络请求和 SQLite 操作，只是 Model 层和 View 层的一个桥梁。Presenter 层就不至于太臃肿，容易看懂。一些大的 App，或因为上线时间比较久了，经历过众多程序员的修补，或因前期并未做好架构，以至于打开一个类，几千行的代码，看着自己都晕。</li>
</ul>
<h1 id="MVP的优势"><a href="#MVP的优势" class="headerlink" title="MVP的优势"></a>MVP的优势</h1><ul>
<li>模型与视图完全分离，我们可以修改视图而不影响模型</li>
<li>可以更高效地使用模型，因为所有的交互都发生在一个地方——Presenter内部</li>
<li>我们可以将一个Presener用于多个视图，而不需要改变Presenter的逻辑。这个特性非常的有用，因为视图的变化总是比模型的变化频繁。</li>
<li>如果我们把逻辑放在Presenter中，那么我们就可以脱离用户接口来测试这些逻辑（单元测试）</li>
</ul>
<h1 id="MVP的问题"><a href="#MVP的问题" class="headerlink" title="MVP的问题"></a>MVP的问题</h1><ul>
<li>由于对视图的渲染放在了Presenter中，所以视图和Persenter的交互会过于频繁.</li>
<li>还有一点你需要明白，如果Presenter过多地渲染了视图，往往会使得它与特定的视图的 联系过于紧密。一旦视图需要变更，那么 Presenter也需要变更了。比如说，原本用来呈现Html的Presenter现在也需要用于呈现Pdf了，那么视图很有可能也需要变更。</li>
</ul>
<h1 id="MVPDemo"><a href="#MVPDemo" class="headerlink" title="MVPDemo"></a>MVPDemo</h1><p>参考了<a href="https://www.jianshu.com/p/abea207c23e7">http://www.jianshu.com/p/abea207c23e7</a>里面给出的一个例子，这里向作者表示感谢。<br>先说下例子的核心思想就是：每个模块会有一个Presenter，Presenter里面包含了View（ViewController）和Model。获取数据（例如网络请求等）之后，进行View的展示和ViewController内部的逻辑处理。</p>
<p>下面我们结合代码来看：</p>
<h3 id="首先来看项目的文件结构："><a href="#首先来看项目的文件结构：" class="headerlink" title="首先来看项目的文件结构："></a>首先来看项目的文件结构：</h3><p><img src="https:////upload-images.jianshu.io/upload_images/2139357-c27301eb2e313e6b.png?imageMogr2/auto-orient/strip|imageView2/2/w/254" alt="img"></p>
<p>MVP文件结构</p>
<p>代码给出了一个控制器作为例子，大家可以看到，home里面包含了四个文件夹，model、controller、presenter、view。home当中的HomePresenter是继承presenter的，HomePresenter根据业务的不同来实现自己的presenter。</p>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>网络的底层还是用AFNetWorking来实现，HttpClient具体的封装大概为</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2139357-8ee4cc619f807050.png?imageMogr2/auto-orient/strip|imageView2/2/w/841" alt="img"></p>
<p>网络层</p>
<p>这里说明一下，这里用delegate而不用block做回调是因为后面的HomePresenter需要对返回的数据进行处理，为了然后结构更加清晰，遵守一个函数一个功能的原则。后面还会再说一下。HttpClient提供了赋值responseHandle的init函数，外部可以通过init函数来绑定responseHandle协议。</p>
<p>再来看一下上面那个responseHandle这个proctocol的结构：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2139357-479b2c83756413b3.png?imageMogr2/auto-orient/strip|imageView2/2/w/486" alt="img"></p>
<p>responseHandle</p>
<p>目前只写了success和fail两个回调，这里为了方便演示，只写了一个参数，这个一块大伙可以根据自己的业务需求来写。</p>
<p>结合HttpClient来看一下，我们分别在AFNetWorking请求成功、失败的回调当中处理delegate。简单说，HttpResponseHandle就是嫁接presenter和HttpClient的协议~~</p>
<p>接下来看一下父类Presenter的设计。先看接口：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2139357-4523e9879ead4b97.png?imageMogr2/auto-orient/strip|imageView2/2/w/387" alt="img"></p>
<p>Presenter.h</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2139357-499e644734a4d341.png?imageMogr2/auto-orient/strip|imageView2/2/w/394" alt="img"></p>
<p>Presenter.m</p>
<p>这里采用了泛型，简单说泛型就是有点类似objective-c中的id类型，大伙可以自行Google一下。父类Presenter主要是提供绑定View和解绑View的功能。</p>
<p>基于网络请求设计的HttpPresenter，HttpPresenter继承与Presenter，遵守HttpResponseHandle协议，并且拥有自己的泛型，HttpClient成员变量。供外部调用HttpClient，降低耦合性。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2139357-85bc39308fa8f49b.png?imageMogr2/auto-orient/strip|imageView2/2/w/790" alt="img"></p>
<p>HttpPresenter.m</p>
<p>HttpPresenter.m</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>大致就可以分为这几层了，看一下怎么应用到实例中。</p>
<p>上文的文件目录中可以看出我们每个功能模块都有presenter这个文件夹，对每个模块的presenter都是为这个模块服务，我们可以把请求、储存数据的活动放在这里。并且在这层presenter中处理model数据。为了使controller得到的数据能直接使用，可以多写一个protocol，来承上启下，HomeViewProtocol就为了这个产生。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">HomeViewProtocol</span> </span><br><br>- (<span class="hljs-keyword">void</span>)onGetMovieListSuccess:(HomeModel*)homeModel;<br><br>- (<span class="hljs-keyword">void</span>)onGetMovieListFail:(<span class="hljs-built_in">NSInteger</span>) errorCode des:(<span class="hljs-built_in">NSString</span>*)des;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>
<p>先看了protocol，HomePresenter看起来就清晰多了吧</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2139357-f4e00bd243fd1362.png?imageMogr2/auto-orient/strip|imageView2/2/w/774" alt="img"></p>
<p>HomePresenter.m</p>
<p>在看一下controller的调用，初始化HomePresenter，然后绑定一下自己的视图，</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2139357-0191085a6dced8af.png?imageMogr2/auto-orient/strip|imageView2/2/w/766" alt="img"></p>
<p>controller对presenter的调用</p>
<p>遵循HomeViewProtocol</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2139357-6eb68ef9e026014c.png?imageMogr2/auto-orient/strip|imageView2/2/w/776" alt="img"></p>
<p>controller实现HomeViewProtocol协议</p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>关于db这层还没有写好，大家可以自由发挥，按照网络这种方式，放在业务的presenter里面就可以啦，后续有时间会附上一个基于FMDB的<br>如果同学们有更好的方案，随时欢迎指正~<br>附上github地址：<a href="https://link.jianshu.com/?t=https://github.com/baoshanf/MVP-iOS">https://github.com/baoshanf/MVP-iOS</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>Git的诞生</title>
    <url>/2020/03/29/Git%E7%9A%84%E8%AF%9E%E7%94%9F/</url>
    <content><![CDATA[<p>很多人都知道，<code>Linus</code>在1991年创建了开源的<code>Linux</code>，从此，<code>Linux</code>系统不断发展，已经成为最大的服务器系统软件了。</p>
<p><code>Linus</code>虽然创建了<code>Linux</code>，但<code>Linux</code>的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？</p>
<p>事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！</p>
<p>你也许会想，为什么<code>Linus</code>不把<code>Linux</code>代码放到版本控制系统里呢？不是有<code>CVS、SVN</code>这些免费的版本控制系统吗？因为<code>Linus</code>坚定地反对<code>CVS</code>和<code>SVN</code>，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比<code>CVS、SVN</code>好用，但那是付费的，和<code>Linux</code>的<strong>开源精神</strong>不符。</p>
<p>不过，到了2002年，<code>Linux系统</code>已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统<code>BitKeeper</code>，<code>BitKeeper</code>的东家<code>BitMover</code>公司出于人道主义精神，授权<code>Linux</code>社区免费使用这个版本控制系统。</p>
<p><strong>安定团结的大好局面在2005年就被打破了</strong>，原因是<code>Linux社区</code>牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发<code>Samba</code>的<code>Andrew</code>试图破解<code>BitKeeper</code>的协议（这么干的其实也不只他一个），被<code>BitMover</code>公司发现了（<code>监控工作做得不错</code>！），于是BitMover公司怒了，要收回<code>Linux社区</code>的<strong>免费使用权</strong>。</p>
<p>Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：</p>
<p><code>Linus</code>花了两周时间<strong>自己用C写了一个分布式版本控制系统</strong>，这就是<code>Git</code>！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。</p>
<p><code>Git迅速成为最流行的分布式版本控制系统</code>，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p>
<p>历史就是这么偶然，如果不是当年<code>BitMover公司</code>威胁<code>Linux社区</code>，可能现在我们就<strong>没有免费而超级好用的Git了</strong>。</p>
<p><strong>分布式版本控制系统除了<code>Git</code>以及促使<code>Git</code>诞生的<code>BitKeeper</code>外，还有类似<code>Git</code>的<code>Mercurial</code>和<code>Bazaar</code>等。这些<code>分布式版本控制系统</code>各有特点，但<code>最快、最简单</code>也<code>最流行</code>的依然是Git！</strong></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>brew install cask</title>
    <url>/2020/04/01/brew-install-cask/</url>
    <content><![CDATA[<p><img src="https://gitee.com/platojobs/images/raw/master/gitartos20200401113006.jpg" alt=""><br><code>Homebrew Cask</code> 是<code>Homebrew</code>的扩展，借助它可以方便地在 <code>macOS</code> 上安装图形界面程序，即我们常用的各类应用。<code>Homebrew</code>中文含义为自制、自酿酒，Cask 中文含义为桶、木桶，桶装酒是一种成品，也就是说每一个 homebrew cask 都可以直接使用的，比如 Atom 的 Cask 名称为 atom，那么就可以使用如下命令安装：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">brew cask install atom<br></code></pre></td></tr></table></figure>
<p>今天为了安装<a href="https://github.com/ripperhe/Bob">Bob 是一款 Mac 端翻译软件，支持划词翻译和截图翻译，当然，手动输入进行翻译也是可以的。</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">platojobs@PlatoJobsdeMacBook-Pro ~ % brew cask install bob<br>==&gt; Downloading https:<span class="hljs-comment">//github.com/ripperhe/Bob/releases/download/v0.4.0/Bob.app</span><br>==&gt; Downloading from https:<span class="hljs-comment">//github-production-release-asset-2e65be.s3.amazonaws</span><br>######################################################################## <span class="hljs-number">100.0</span>%<br>==&gt; Verifying SHA-256 checksum for Cask &#x27;bob&#x27;.<br>==&gt; Installing Cask bob<br>==&gt; Moving App &#x27;Bob.app&#x27; to &#x27;/Applications/Bob.app&#x27;.<br>🍺  bob was successfully installed!<br>platojobs@PlatoJobsdeMacBook-Pro ~ % <br><br><br><br><br><br><br><br><br><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>brew</tag>
      </tags>
  </entry>
  <entry>
    <title>跳槽要不要找猎头</title>
    <url>/2020/04/21/%E8%B7%B3%E6%A7%BD%E8%A6%81%E4%B8%8D%E8%A6%81%E6%89%BE%E7%8C%8E%E5%A4%B4/</url>
    <content><![CDATA[<p><img src="http://q96fa88b1.bkt.clouddn.com/zhiye.jpg" alt=""></p>
<blockquote>
<p>讲话无凭无据，你可不要太当真哦，转载文章</p>
</blockquote>
<p>工作没几年的时候，觉得猎头是一个可高级的岗位了，能被勾搭上都觉得自己身价陡增，倍儿有面子。<br>是的，我当年就是这么想的。</p>
<p>QQ 好友里躺了好几百个猎头，每次打开都一排排的粉色头像在晃动，仿佛在跟我说：Scott，快来快来，这里有一个 Offer 等着你，基于你现在  10k 的薪资，再涨 8 千…</p>
<p>直到我开始自己创业的时候，我才发觉自己多么单纯。</p>
<p>跟上百的猎头聊下来，他们也帮我推荐了工作，不可否认，有许多很专业的猎头（功课做得足，专业知识够，沟通技巧高…），是非常值得托付终（Jian）身（Li）的人。</p>
<p>但同时，市面上充斥这各种层次不齐的半路猎头，他们可能只是对你好奇，过来打击一下你，过来讥讽一下你，过来挑逗一下你，过来装模作样了解一下你，甚至过来只是例行公事的骚扰一下你，拿走你的简历转手送人，更有甚者，想要来跟你做一笔交易，你入职她会陪你吃花酒…(嘘！我不能透漏更多了)</p>
<p>基于这个现实，前端跳槽要不要找猎头呢？</p>
<p>我的答案是，当你在社区有影响力的时候，不要找，当你技术水平还不足的时候，不要找，当你不了解目标公司用人标准的时候，不要找。<br>为什么呢？<br>如果你影响力比较大，社区很多人都了解你的时候，你在很多公司都有人脉的时候，你想一下，自己内推自己过去入职率高，还是猎头推荐你过去入职率高？<br>答案显然是自己找朋友内推成功率高，因为没有谁比你朋友更了解你了。<br>如果你技术还不够好，或者对目标公司用人标准不够了解的时候，仓促找了猎头投了简历，可能会碰到这种结果：<br>• 面试过关，但不发 <code>Offer</code><br>好诡异的结果，原因是你可能面试刚刚摸到了公司的用人标准线，公司咬咬牙是想把你招进来的，结果一想到要支付猎头一大笔介绍费，就退却了（毕竟对于很多公司，能省一点省一点，何况这笔费用还不菲）。<br>那什么时候找猎头呢？就是技术水平还不错（最好是已经到了技术专家，也就是 P7 的水平以上），在社区里比较沉默影响力不够，或者目标是去一家外企的时候，可以考虑猎头。<br>那怎么联系猎头呢？放心，只要你有一点点风声出去，猎头都会来找你的。<br>那如何甄别猎头呢？你只需要考一考他/她对前端职业的了解程度，听听他/她对这个职业的理解深度，以及他/她能如数家珍出多少个前端社区有影响力的人，并且知道他们分别在什么公司带什么团队大概什么层级，以及他/她能基本分得清<code>`Java</code> 和<code>Javascript</code>，分得清 <code>Vue/Angular/React</code>，分得清前端和大前端，知道这一两年的前端风向是什么，是 BFF 还是Serverless，如果他/她能大概说的清楚，那么这个猎头可以再深度对接对接了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">真正专业的猎头，不会打击你，<br>而是会给你提供事实案例和有价值的建议，<br>真正专业的猎头，更不会嘲讽你，<br>而是会帮你理清楚目标职位跟你的实力有距离的时候，<br>你所面临的利害关系（比如一旦被面试唰下来，在这家公司再被捞起来的概率可能是大幅降低的），<br>真正专业的猎头，是会认真跟你交朋友的，<br>因为当下的你可能还只是弱鸡，三年后可能就一鸣惊人了，至少我见过的好的猎头，<br>会带候选人一起参加面试，会跟有交情的主面试官打个客套，<br>甚至会给候选人带吃的喝的全程陪护<br>（考虑到有的高级岗位会面试一个上午加半个下午的情况）。<br><br></code></pre></td></tr></table></figure></p>
<blockquote>
<p>一不小心说这么多，大家听听就好，千万别当真哦,纯属转载，切勿当真。</p>
</blockquote>
]]></content>
      <categories>
        <category>职场</category>
      </categories>
      <tags>
        <tag>职场</tag>
      </tags>
  </entry>
  <entry>
    <title>小桃的职业</title>
    <url>/2020/04/22/%E5%B0%8F%E6%A1%83%E7%9A%84%E8%81%8C%E4%B8%9A/</url>
    <content><![CDATA[<blockquote>
<p>收到小桃寄回来的两万块钱，给娘交了住院费，安顿好娘之后，良子决定到城里去看小桃。</p>
</blockquote>
<p><code>小桃</code>走的时候，两人<code>刚结婚</code>才半年，可是娘病了，<code>良子</code>拗不过小桃，就同意了小桃到城里打工。小桃出去后，不到两年就给家里挣了两万块钱，良子就觉得不对劲。尤其是从<code>柱子</code>手里接过汇款单的时候，看着柱子别有意味的神情，良子心里更有一种越发不踏实的感觉。</p>
<p><code>良子</code>就安排了放暑假在家的小妹到医院照顾娘，独自一个人去了城里。良子没有提前给小桃打电话，因为直到现在，良子还是搞不清楚小桃在城里到底是做什么工作的，<code>为什么会赚到那么多钱</code>。<strong>会不会像村里其他那些女孩子一样呢</strong>? 在城里干着什么见不得人的事，要是那样的话，<code>良子</code>是绝对不会饶了她的，良子心里想着。<br>小桃的职业在良子心里永远是一个疙瘩。良子问过小桃很多次，小桃总是岔开了话题，要么就是用沉默来代替回答。良子被小桃的职业折磨得快要疯了。<strong>良子想，要是小桃真是在外面当小姐或被有钱人包养了就和她离婚。</strong></p>
<p><img src="http://q96fa88b1.bkt.clouddn.com/20200519.jpg" alt=""><br><code>城里的路真是难找啊</code>，费了好大的劲，良子终于找到了美院。良子只隐隐约约地知道，小桃在美院打工。这么大的美院，上哪去找小桃呢？良子犯了难，找人问，可是别人都听不懂良子的方言，良子只好坐在小路边抽起了闷烟。<br>突然前面出现了一个身影，<code>良子</code>定睛一看，那个人像极了<code>小桃</code>。<code>良子</code>就闪进了旁边的一座假山背后，等到小桃走过之后，远远地跟了上去。</p>
<p>走到一座楼前，<code>良子</code>看见小桃和一个大胡子男人打了招呼，跟着大胡子上了楼，进了一间屋子，然后就见大胡子拉上了窗帘。<code>良子</code>的心不由得一下子沉下去，良子气极了，原来村里人的传言没错啊。良子两眼通红，使劲地撞开了那扇关着的门。</p>
<p>啊！良子看见小桃正<code>一丝不挂</code>地坐在屋子前边的一个台子上，看见良子进来，惊慌失措地叫了起来。<br>台下站着大胡子，还有几十个年轻人，正举着画笔画着小桃的裸体。良子疯了似的扑向小桃，但被大胡子拉住了。</p>
<p>良子气愤地回去了。<code>良子</code>回去就一言不发地把家里的房子抵押给信用社，托柱子帮忙贷了两万块钱，然后去城里找小桃。良子把钱扔在小桃面前，怒气冲冲地说，从今往后咱们两清了，你爱让大胡子怎么摆弄都行！</p>
<p><code>小桃</code>哭着拉住良子说，良子哥，我没有对不起你，我只是为了咱娘的病，还有小妹上学，哪样都需要钱哪！<br>良子说，为了钱你就可以让人围着看你的精身子吗？你不知道羞耻，我良子还要脸面！咱们明天就回去离婚！<br>第二天，良子就拉着小桃要离婚。小桃哭着跪在良子面前，死活不肯。就在僵持不下的时候，小妹托人捎信说娘快不行了，让良子赶快回去。</p>
<p>良子回去的时候，发现小桃偷偷地跟了回来。回来的时候，娘却去世了。<code>办丧事</code>的时候，<code>良子</code>死活不让小桃给娘戴孝。良子瞪着血红的眼睛对小桃说，滚回城里去，俺娘没有你这样不要脸的媳妇！<br>小桃哭着走了。办完娘的丧事，小妹的高考录取通知书却到了。看着通知书上的学费，良子一下子不知道怎样才好。</p>
<p>再到城里时，是接到小桃遭遇车祸的死讯之后。良子本来是硬着心不去的，可是想到毕竟人已经不在了，没有必要跟死人计较。</p>
<p><code>从城里的警察手里领到赔偿款，听警察说小桃喝醉后被车撞的，对车祸也负有一定的责任</code>。<code>良子</code>突然感到对不起小桃，整理小桃的遗物时，良子发现了小桃留给良子的最后一封信。小桃说，<code>良子哥</code>，看来我只有用死来证明自己的清白了，我死后，车主给的赔偿款可以供小妹上完学，还可以用来把房子盖一下，以后还可以再找一个对你好的女人……</p>
<p><code>良子</code>哭了，<code>良子</code>哭着找到了大胡子。大胡子说，多可惜呀，<code>小桃</code>只是一个职业模特，她没做错什么，是你害了她呀！</p>
<blockquote>
<p><code>良子</code>一下子哭晕了过去。</p>
</blockquote>
]]></content>
      <categories>
        <category>小说</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>闲暇</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法（一）</title>
    <url>/2020/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p><img src="http://q96fa88b1.bkt.clouddn.com/gjk.jpg" alt=""></p>
<h2 id="1-数据结构与算法-C语言"><a href="#1-数据结构与算法-C语言" class="headerlink" title="1.数据结构与算法-C语言"></a>1.数据结构与算法-C语言</h2><h3 id="1-1-数据结构的数据、数据元素、数据项、数据对象"><a href="#1-1-数据结构的数据、数据元素、数据项、数据对象" class="headerlink" title="1.1 数据结构的数据、数据元素、数据项、数据对象"></a>1.1 数据结构的数据、数据元素、数据项、数据对象</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 数据: 程序的操作对象,用于描述客观事物.</span><br><span class="hljs-comment"> 数据的特点: 1️⃣ 可以输入到计算机 2️⃣ 可以被计算机处理</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> 数据项: 一个数据元素由若干数据项组成</span><br><span class="hljs-comment"> 数据元素: 组成数据的对象的基本单位</span><br><span class="hljs-comment"> 数据对象: 性质相同的数据元素的集合(类似于数组)</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> 结构: 数据元素之间不是独立的,存在特定的关系.这些关系即是结构;</span><br><span class="hljs-comment"> 数据结构:指的数据对象中的数据元素之间的关系</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">//声明一个结构体类型</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Teacher</span>&#123;</span>     <span class="hljs-comment">//一种数据结构</span><br>    <span class="hljs-keyword">char</span> *name;     <span class="hljs-comment">//数据项--名字</span><br>    <span class="hljs-keyword">char</span> *title;    <span class="hljs-comment">//数据项--职称</span><br>    <span class="hljs-keyword">int</span>  age;       <span class="hljs-comment">//数据项--年龄</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;<br>   <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Teacher</span> <span class="hljs-title">t1</span>;</span>     <span class="hljs-comment">//数据元素;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Teacher</span> <span class="hljs-title">tArray</span>[10];</span> <span class="hljs-comment">//数据对象;</span><br>    <br>    t1.age = <span class="hljs-number">18</span>;       <span class="hljs-comment">//数据项</span><br>    t1.name = <span class="hljs-string">&quot;CC&quot;</span>;    <span class="hljs-comment">//数据项</span><br>    t1.title = <span class="hljs-string">&quot;讲师&quot;</span>;  <span class="hljs-comment">//数据项</span><br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;老师姓名:%s\n&quot;</span>,t1.name);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;老师年龄:%d\n&quot;</span>,t1.age);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;老师职称:%s\n&quot;</span>,t1.title);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="1-2-数据结构"><a href="#1-2-数据结构" class="headerlink" title="1.2 数据结构"></a>1.2 数据结构</h3><p><img src="https://gitee.com/platojobs/images/raw/master/gitartos20200415193101.png" alt=""></p>
<h4 id="1-2-1-逻辑结构划分"><a href="#1-2-1-逻辑结构划分" class="headerlink" title="1.2.1 逻辑结构划分"></a>1.2.1 逻辑结构划分</h4><blockquote>
<p>数据结构的逻辑结构：按逻辑分为：集合结构，线性结构，树形结构，图形结构等</p>
</blockquote>
<h5 id="1-2-1-集合结构"><a href="#1-2-1-集合结构" class="headerlink" title="1.2.1 集合结构"></a>1.2.1 集合结构</h5><blockquote>
<p>集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系，它们之间唯一的相同点就是”同属于一个集合”。</p>
</blockquote>
<h5 id="1-2-2-线性结构"><a href="#1-2-2-线性结构" class="headerlink" title="1.2.2 线性结构"></a>1.2.2 线性结构</h5><blockquote>
<p>线性结构中的数据元素之间的关系是一对一的。常用的线性结构有：线性表、栈、队列、双队列、数组、串。</p>
</blockquote>
<h5 id="1-2-3-树形结构"><a href="#1-2-3-树形结构" class="headerlink" title="1.2.3 树形结构"></a>1.2.3 树形结构</h5><blockquote>
<p>树形结构中的数据元素是一对多的层级关系。常见的树形结构: 二叉树、B树、哈夫曼树、红黑树等</p>
</blockquote>
<h5 id="1-2-4-图形结构"><a href="#1-2-4-图形结构" class="headerlink" title="1.2.4 图形结构"></a>1.2.4 图形结构</h5><blockquote>
<p>图形结构中的数据元素之间的关系是多对多的。常见的图形结构：邻近矩阵、邻接表。</p>
</blockquote>
<h4 id="1-2-2-物理结构划分"><a href="#1-2-2-物理结构划分" class="headerlink" title="1.2.2 物理结构划分"></a>1.2.2 物理结构划分</h4><blockquote>
<p>物理结构划分分为：顺序存储结构，链式存储结构。</p>
</blockquote>
<h5 id="1-2-2-1-顺序结构"><a href="#1-2-2-1-顺序结构" class="headerlink" title="1.2.2.1 顺序结构"></a>1.2.2.1 顺序结构</h5><blockquote>
<p>顺序存储结构：指把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。比如一个数组，它的元素是一个接一个，在内存空间中的地址也是连续的，我们可以通过数组的下标访问每一个元素，也可以使用地址递增的方式访问</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">//顺序表结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KSequenceList</span> &#123;</span><br>    KElementType *data;<br>    <span class="hljs-keyword">int</span> length;<br>&#125;KSList;<br></code></pre></td></tr></table></figure>
<h5 id="1-2-2-2-链式结构"><a href="#1-2-2-2-链式结构" class="headerlink" title="1.2.2.2 链式结构"></a>1.2.2.2 链式结构</h5><blockquote>
<p> 是把数据元素放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置。</p>
</blockquote>
<h3 id="1-3-抽象数据类型的表示和实现"><a href="#1-3-抽象数据类型的表示和实现" class="headerlink" title="1.3 抽象数据类型的表示和实现"></a>1.3 抽象数据类型的表示和实现</h3><ul>
<li><strong>抽象</strong>：是抽取出事物具有的普遍的本质。它是抽出问题的特征二忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏繁杂的细节，只保留实现目标必需要的信息。</li>
<li><strong>抽象数据类型</strong>：是指一个数学模型以及定义在该模型上的一组操作；例如，我们在编写计算机绘图软件系统是，经常会使用到坐标。也就是说，会经常使用x,y来描述纵横坐标。而在3D系统中，Z深度就会出现。既然这3个整型数字是始终出现在一起，那么就可以定义成一个Point的抽象数据类型。它有x,y,z三个整型变量。这样开发者就非常方便操作Point数据变量。</li>
</ul>
<blockquote>
<p>抽象数据类型可以理解成实际开发里经常使用的结构体和类；根据业务需求定义合适的数据类型和动作。</p>
</blockquote>
<h3 id="1-4-算法和算法分析"><a href="#1-4-算法和算法分析" class="headerlink" title="1.4 算法和算法分析"></a>1.4 算法和算法分析</h3><blockquote>
<p>算法就是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每个指令表示一个或者多个操作。</p>
</blockquote>
<h4 id="1-4-1-算法特性"><a href="#1-4-1-算法特性" class="headerlink" title="1.4.1  算法特性"></a>1.4.1  算法特性</h4><p>算法有以下特性：</p>
<p>输入输出： 算法具有零个或者多个输入，至少有一个或多个输出。<br>有穷性：有穷性指的是算法在执行有限的步骤之后，自动结束而不会出现无限循环,且每一个步骤都在可接受的时间内完成。<br>确定性：确定性是指算法的每一个步骤都具有确定的含义，不能出现二义性。 算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果。<br>可行性：算法的每一步都必须是可行的，即每一步都能通过执行有限次数完成</p>
<h4 id="1-4-2-算法设计"><a href="#1-4-2-算法设计" class="headerlink" title="1.4.2  算法设计"></a>1.4.2  算法设计</h4><p>算法设计要求：</p>
<ul>
<li><code>正确性</code>：算法的正确性是指算法至少应该具有输入，输出和加工处理无歧义性，能正确反映问题的需求、能够得到问题的正确答案。正确性分为4个层次: - 算法程序没有语法错误; - 算法程序对于合法的输入数据能够产生满足要求的输出结果; - 算法程序对于非法的输入数据能够得出满足规格说明的结果; - 算法程序对于精心选择的,甚至刁钻的测试数据都有满足要求的输出结果;</li>
<li><code>可读性</code>：: 算法设计的另一个目的是为了便于阅读，理解和交流。可读性高有助于人们理解算法，晦涩难懂的算法往往隐含错误，不容易发现，并且难于调试和修改。</li>
<li><code>健壮性</code>：一个好的算法还应该能对输入数据的不合法的情况做出合适的处理，考虑边界性，也是在写代码经常要做的一个处理。当输入数据不合法时，算法也能做出相关处理，而不是产生异常和莫名其妙的结果。</li>
<li><code>时间效率高和存储量低</code>：用最少的存储空间和最少的时间，办成同样的事，就是好算法</li>
</ul>
<h3 id="1-5-算法的空间复杂度"><a href="#1-5-算法的空间复杂度" class="headerlink" title="1.5 算法的空间复杂度"></a>1.5 算法的空间复杂度</h3><h4 id="1-5-1-时间复杂度"><a href="#1-5-1-时间复杂度" class="headerlink" title="1.5.1 时间复杂度"></a>1.5.1 时间复杂度</h4><blockquote>
<p>算法的时间复杂度的定义如下： 在进行算法分析时，语句的总执行次数T(n)是关于问题规模n的函数，进而分析T(n)随着n变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，即为T(n) = O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。 大写O( )来体现算法时间复杂度的记法，我们称之为大O记法。</p>
<p><strong>推导大O阶的方法</strong>：</p>
<ul>
<li>用常数1取代运行时间中所有加法常数</li>
<li>在修改后的运行次数函数中，只保留最高阶项</li>
<li>如果在最高阶项存在且不是1，则去除与这个项相乘的常数;<h5 id="1-5-1-1-常数阶"><a href="#1-5-1-1-常数阶" class="headerlink" title="1.5.1.1 常数阶"></a>1.5.1.1 常数阶</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>, n = <span class="hljs-number">100</span>;<br>sum = (<span class="hljs-number">1</span> + n) * n / <span class="hljs-number">2</span>;<br>printf(<span class="hljs-string">&quot;%d&quot;</span>, sum);<br><br></code></pre></td></tr></table></figure>
这个算法的每行代码都会执行一次，运行次数函数是f(n) = 3，依据推导大O阶的方法，第一步就是将常数替换为1，由于没有最高阶项，所以该算法的时间复杂度为O(1)。需要注意的是，常数阶的算法不管常数是多少，我们都记做O(1)，并没有O(2)、O(3)之类的复杂度。<h5 id="1-5-1-2-线性阶"><a href="#1-5-1-2-线性阶" class="headerlink" title="1.5.1.2 线性阶"></a>1.5.1.2 线性阶</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-comment">//  时间复杂度为O(1)的操作   </span><br>&#125;<br></code></pre></td></tr></table></figure>
分析算法的复杂度，就是要分析循环结构的运行情况。上述代码的时间复杂度为O(n)，是因为循环体中的代码要执行n次。</li>
</ul>
</blockquote>
<h5 id="1-5-1-3-对数阶"><a href="#1-5-1-3-对数阶" class="headerlink" title="1.5.1.3 对数阶"></a>1.5.1.3 对数阶</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>    i = i * <span class="hljs-number">2</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<blockquote>
<p>在循环体内，i每次都乘以2倍，即为2^x = n，可以得出次数x为以2为低n的对数x = log2n。根据推导大O阶的方法，去除最高阶项的常数，即为O(logn)。</p>
</blockquote>
<h5 id="1-5-1-4-平方阶"><a href="#1-5-1-4-平方阶" class="headerlink" title="1.5.1.4 平方阶"></a>1.5.1.4 平方阶</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-comment">//  时间复杂度为O(1)的操作   </span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>循环嵌套n*n，时间复杂度为O(n^2)。</p>
</blockquote>
<p><img src="https://gitee.com/platojobs/images/raw/master/gitartos20200415193100.png" alt=""></p>
<blockquote>
<p><strong>时间复杂实际就是评估算法执行的次数</strong>:<br>O(1) &lt; O(log n) &lt; O(n) &lt; O(nlog n) &lt; O(n2) &lt; O(n3) &lt; O(2n) &lt; O(n!) &lt; O(n^n)</p>
</blockquote>
<hr>
<h5 id="1-5-1-5-示例demo："><a href="#1-5-1-5-示例demo：" class="headerlink" title="1.5.1.5 示例demo："></a>1.5.1.5 <strong>示例demo：</strong></h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-comment">/*大O表示法</span><br><span class="hljs-comment"> 1. 用常数1取代运行时间中所有常数 3-&gt;1 O(1)</span><br><span class="hljs-comment"> 2. 在修改运行次数函数中,只保留最高阶项 n^3+2n^2+5 -&gt; O(n^3)</span><br><span class="hljs-comment"> 3. 如果在最高阶存在且不等于1,则去除这个项目相乘的常数 2n^3 -&gt; n^3</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 时间复杂度术语:</span><br><span class="hljs-comment"> 1. 常数阶</span><br><span class="hljs-comment"> 2. 线性阶</span><br><span class="hljs-comment"> 3. 平方阶</span><br><span class="hljs-comment"> 4. 对数阶</span><br><span class="hljs-comment"> 5. 立方阶</span><br><span class="hljs-comment"> 6. nlog阶</span><br><span class="hljs-comment"> 7. 指数阶(不考虑) O(2^n)或者O(n!) 除非是非常小的n,否则会造成噩梦般的时间消耗. 这是一种不切实际的算法时间复杂度. 一般不考虑!</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/* 1. 常数阶时间复杂度计算 O(1) */</span><br><span class="hljs-comment">//1+1+1 = 3 O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testSum1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;                <span class="hljs-comment">//执行1次</span><br>    sum = (<span class="hljs-number">1</span>+n)*n/<span class="hljs-number">2</span>;            <span class="hljs-comment">//执行1次</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;testSum1:%d\n&quot;</span>,sum);<span class="hljs-comment">//执行1次</span><br>&#125;<br><br><span class="hljs-comment">//1+1+1+1+1+1+1 = 7 O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testSum2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;                <span class="hljs-comment">//执行1次</span><br>    sum = (<span class="hljs-number">1</span>+n)*n/<span class="hljs-number">2</span>;            <span class="hljs-comment">//执行1次</span><br>    sum = (<span class="hljs-number">1</span>+n)*n/<span class="hljs-number">2</span>;            <span class="hljs-comment">//执行1次</span><br>    sum = (<span class="hljs-number">1</span>+n)*n/<span class="hljs-number">2</span>;            <span class="hljs-comment">//执行1次</span><br>    sum = (<span class="hljs-number">1</span>+n)*n/<span class="hljs-number">2</span>;            <span class="hljs-comment">//执行1次</span><br>    sum = (<span class="hljs-number">1</span>+n)*n/<span class="hljs-number">2</span>;            <span class="hljs-comment">//执行1次</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;testSum2:%d\n&quot;</span>,sum);<span class="hljs-comment">//执行1次</span><br>    <br>&#125;<br><span class="hljs-comment">//x=x+1; 执行1次</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    x = x+<span class="hljs-number">1</span>;<br>&#125;<br><br><br><span class="hljs-comment">/*2.线性阶时间复杂度*/</span><br><span class="hljs-comment">//x=x+1; 执行n次 O(n)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        x = x+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//1+(n+1)+n+1 = 3+2n -&gt; O(n)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testSum3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i,sum = <span class="hljs-number">0</span>;               <span class="hljs-comment">//执行1次</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;   <span class="hljs-comment">//执行n+1次</span><br>        sum += i;                <span class="hljs-comment">//执行n次</span><br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;testSum3:%d\n&quot;</span>,sum);  <span class="hljs-comment">//执行1次</span><br>&#125;<br><br><span class="hljs-comment">/*3.对数阶*/</span><br><span class="hljs-comment">/*2的x次方等于n x = log2n  -&gt;O(logn)*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;         <span class="hljs-comment">//执行1次</span><br>    <span class="hljs-comment">//n = 10</span><br>    <span class="hljs-keyword">while</span> (count &lt; n) &#123;<br>        count = count * <span class="hljs-number">2</span>;<br>    &#125;<br>    <br>&#125;<br><br><br><span class="hljs-comment">/*4.平方阶*/</span><br><span class="hljs-comment">//x=x+1; 执行n*n次 -&gt;O(n^2)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n ; j++) &#123;<br>            x=x+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//n+(n-1)+(n-2)+...+1 = n(n-1)/2 = n^2/2 + n/2 = O(n^2)</span><br><span class="hljs-comment">//sn = n(a1+an)/2</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testSum4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; n; j++) &#123;<br>            sum += j;<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;textSum4:%d&quot;</span>,sum);<br>    <br>&#125;<br><br><span class="hljs-comment">//1+(n+1)+n(n+1)+n^2+n^2 = 2+3n^2+2n -&gt; O(n^2)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testSum5</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i,j,x=<span class="hljs-number">0</span>,sum = <span class="hljs-number">0</span>;           <span class="hljs-comment">//执行1次</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;     <span class="hljs-comment">//执行n+1次</span><br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123; <span class="hljs-comment">//执行n(n+1)</span><br>            x++;                   <span class="hljs-comment">//执行n*n次</span><br>            sum = sum + x;         <span class="hljs-comment">//执行n*n次</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;testSum5:%d\n&quot;</span>,sum);<br>&#125;<br><br><br><span class="hljs-comment">/*5.立方阶*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">1</span>;                         <span class="hljs-comment">//执行1次</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-comment">//执行n次</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span> ; j &lt; n; j++) &#123;   <span class="hljs-comment">//执行n*n次</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k++) &#123;<span class="hljs-comment">//执行n*n*n次</span><br>                sum = sum * <span class="hljs-number">2</span>;          <span class="hljs-comment">//执行n*n*n次</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;<br>    <br>    testSum1(<span class="hljs-number">100</span>);<br>    testSum2(<span class="hljs-number">100</span>);<br>    testSum3(<span class="hljs-number">100</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h4 id="1-5-2-空间复杂度"><a href="#1-5-2-空间复杂度" class="headerlink" title="1.5.2 空间复杂度"></a>1.5.2 空间复杂度</h4><p>算法的空间复杂度：</p>
<blockquote>
<p>算法的空间复杂度通过计算算法所需要的存储空间实现，算法空间复杂度的计算公式记做：S(n) = n(f(n)), 其中n为问题的规模， f(n) 为语句关于n 所占内存空间的函数。</p>
<h5 id="1-5-2-1-示例demo"><a href="#1-5-2-1-示例demo" class="headerlink" title="1.5.2.1 示例demo"></a>1.5.2.1 示例demo</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 程序空间计算因素:</span><br><span class="hljs-comment"> 1. 寄存本身的指令</span><br><span class="hljs-comment"> 2. 常数</span><br><span class="hljs-comment"> 3. 变量</span><br><span class="hljs-comment"> 4. 输入</span><br><span class="hljs-comment"> 5. 对数据进行操作的辅助空间</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> 在考量算法的空间复杂度,主要考虑算法执行时所需要的辅助空间.</span><br><span class="hljs-comment"> 空间复杂度计算:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> 问题: 数组逆序,将一维数组a中的n个数逆序存放在原数组中.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;<br>    <span class="hljs-comment">// insert code here...</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>);<br>   <br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;<br>    <br>    <span class="hljs-comment">//算法实现(1)</span><br>    <span class="hljs-keyword">int</span> temp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n/<span class="hljs-number">2</span> ; i++)&#123;<br>        temp = a[i];<br>        a[i] = a[n-i<span class="hljs-number">-1</span>];<br>        a[n-i<span class="hljs-number">-1</span>] = temp;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,a[i]);<br><br>    &#125;<br>    <br>    <span class="hljs-comment">//算法实现(2)</span><br>    <span class="hljs-keyword">int</span> b[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)&#123;<br>        b[i] = a[n-i<span class="hljs-number">-1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        a[i] = b[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,a[i]);<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>麦子</title>
    <url>/2020/04/22/%E9%BA%A6%E5%AD%90/</url>
    <content><![CDATA[<p><img src="http://q96fa88b1.bkt.clouddn.com/QJ8759771750.jpg" alt=""></p>
<blockquote>
<p>麦子不想长在麦田里。麦子想长在城市里，楼很高车很多的城市里。<br>麦子当然不是麦子。麦子是麦田边一座村庄里，一个女孩的名字。</p>
</blockquote>
<p>后来，麦子真的去了城市。麦子太想去城市了，高中书还没读完，别人一叫，麦子就放下正读的书，走了。</p>
<p>其实还没到城市，麦子进了离城市老远老远的一座工厂里。麦子在机器旁一站，一天就过去了。</p>
<p>星期天，麦子喜欢坐车往城里跑。麦子太喜欢城市了，麦子喜欢看城市车来车往高楼林立的模样，麦子喜欢看城市里大街上人来人往摩肩接踵的模样。麦子看着看着，就感觉心慌慌的，眼花花的。</p>
<p>麦子后来迷了路。<br>再后来麦子认识了一个小伙子。</p>
<a id="more"></a>
<p>小伙子看麦子的样子很城市，小伙子说话的声音很城市，小伙子走路的样子很城市，小伙子当然是城里人。<br>麦子和小伙子最初一前一后走在城市里。<br>麦子和小伙子后来手挽手走在城市里。</p>
<p>再后来，麦子就躺在小伙子的怀里。<br>再后来，小伙子就领麦子进了一间小房子。<br>麦子最初感觉很害怕，很疼，麦子后来就哭了，哭着哭着，麦子又笑了。<br>再后来，麦子找到小伙子，说，咱俩结婚吧，我将自己都给你了。<br>小伙子望着麦子，惊讶得张大了嘴，好像不是麦子在说话，而是麦田里麦棵上一穗麦子在说话。<br>小伙子后来哧哧笑着说，麦子麦子，你还真是一穗麦子！</p>
<p><img src="http://q96fa88b1.bkt.clouddn.com/maizi.jpg" alt=""></p>
<p>小伙子说完从身上掏出一沓钱，塞在麦子手里，让麦子走。<br>麦子一下就哭了，眼里流出泪来，麦子忽然看见城市的高楼大厦在她眼前突突突抖个不停，麦子睁开眼，小伙子早不见人影了。<br>将脸上的泪水擦干净后，麦子就不再叫麦子了，叫阿花阿芳阿丝阿丽阿猫阿狗反正不再叫麦子了。<br>麦子开始在城市的发廊发屋美容院按摩院酒店饭店和很多城里男人干那事，麦子不再感觉害怕不再感觉疼也不再哭泣或者笑，麦子就像一地熟透了的麦子，男人想咋割就咋割。</p>
<p>男人折腾完了，就给麦子递过钱，麦子大大方方伸手就接了。<br>麦子想，这就是城市，用我所有的换回我所需要的，城市真好！<br>麦子从一座城市走到另一座城市，麦子成了城市发廊发屋美容院按摩院酒店饭店间漂着的一粒麦子。<br>麦子感觉自己很快乐。<br>有一天，麦子回到了麦田边的村庄。麦子的嘴唇很城市地红着，麦子的头发很城市地黄着，麦子的裙子很城市地在风中飘着。麦子进了村庄，好多人愣愣地望着麦子，忽然一个个朝麦子大声喊着，麦子！麦子！</p>
<p>麦子一下愣愣的，心想他们喊谁呢？<br>后来，麦子才想起他们是喊自己呢。<br>麦子的心里一下潮潮的暖暖的。<br>麦子妈说，咱不去了，咱在村里种麦子。<br>麦子爸说，咱不去了，咱在村里割麦子。<br>麦子撇撇嘴，心说我才不想一辈子种麦子割麦子呢。</p>
<p>麦子一转身，就头也不回地走了。<br>后来，麦子还是回到了麦田边的村庄里。不是麦子在城市间漂累了，是麦子得了病，得了那种不敢叫人知道的病。<br>麦子整天整天躺在屋里，蔫蔫的，像一穗被雨淋得快要发霉的麦子。<br>麦子妈流着泪说，咱看好了，咱在村里种麦子。<br>麦子爸流着泪说，咱看好了，咱在村里割麦子。<br>麦子噙着泪点了点头。<br><img src="http://q96fa88b1.bkt.clouddn.com/maizi1.jpg" alt=""><br>麦子将自己在城市里挣的钱一张一张花完了，麦子的病还没看好。<br>麦子后来就不想活了，麦子用爸妈割麦的镰刀，将自己当成一棵熟透的麦稞子，偷偷割倒在村口的麦田里。<br>现在，麦子躺在村口的土坡上，麦子的身边，一大片一大片麦子，年年春天绿，年年夏天黄。</p>
]]></content>
      <categories>
        <category>小说</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>Oh My ZSH</title>
    <url>/2020/04/27/Oh-My-ZSH/</url>
    <content><![CDATA[<h4 id="1-Mac-下zsh使用-是自带zsh的，使用命令zsh-version"><a href="#1-Mac-下zsh使用-是自带zsh的，使用命令zsh-version" class="headerlink" title="1.Mac 下zsh使用 ,是自带zsh的，使用命令zsh --version"></a>1.Mac 下<code>zsh</code>使用 ,是自带<code>zsh</code>的，使用命令<code>zsh --version</code></h4><figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada"><br>➜  ~ zsh <span class="hljs-comment">--version</span><br>zsh <span class="hljs-number">5.7</span>.<span class="hljs-number">1</span> (x86_64-apple-darwin19.<span class="hljs-number">0</span>)<br>➜  ~ <br><br><br></code></pre></td></tr></table></figure>
<h4 id="2-切换默认shell为zsh"><a href="#2-切换默认shell为zsh" class="headerlink" title="2. 切换默认shell为zsh"></a>2. 切换默认<code>shell</code>为<code>zsh</code></h4><h5 id="2-1-cat-etc-shells-能够清楚的查看已经安装好的-shell-脚本列表"><a href="#2-1-cat-etc-shells-能够清楚的查看已经安装好的-shell-脚本列表" class="headerlink" title="2.1 cat /etc/shells  能够清楚的查看已经安装好的 shell 脚本列表"></a>2.1 <code>cat /etc/shells</code>  能够清楚的查看已经安装好的 shell 脚本列表</h5><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"> ~ cat <span class="hljs-regexp">/etc/</span>shells<br><span class="hljs-comment"># List of acceptable shells for chpass(1).</span><br><span class="hljs-comment"># Ftpd will not allow users to connect who are not using</span><br><span class="hljs-comment"># one of these shells.</span><br><br><span class="hljs-regexp">/bin/</span>bash<br><span class="hljs-regexp">/bin/</span>csh<br><span class="hljs-regexp">/bin/</span>dash<br><span class="hljs-regexp">/bin/</span>ksh<br><span class="hljs-regexp">/bin/</span>sh<br><span class="hljs-regexp">/bin/</span>tcsh<br><span class="hljs-regexp">/bin/</span>zsh<br><br></code></pre></td></tr></table></figure>
<h5 id="2-2-echo-SHELL-直接打印-shell-的环境变量"><a href="#2-2-echo-SHELL-直接打印-shell-的环境变量" class="headerlink" title="2.2 ~ echo $SHELL  直接打印 shell 的环境变量:"></a>2.2 <code>~ echo $SHELL</code>  直接打印 shell 的环境变量:</h5><p>我的已经切换过了，默认是<code>zsh:</code><br><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">~ echo <span class="hljs-variable">$SHELL</span><br><span class="hljs-regexp">/bin/</span>zsh<br></code></pre></td></tr></table></figure></p>
<h5 id="2-3-切换默认的-shell至-zsh-执行命令chsh-s-usr-local-bin-zsh"><a href="#2-3-切换默认的-shell至-zsh-执行命令chsh-s-usr-local-bin-zsh" class="headerlink" title="2.3 切换默认的 shell至 zsh: 执行命令chsh -s/usr/local/bin/zsh"></a>2.3 切换默认的 <code>shell</code>至 <code>zsh</code>: 执行命令<code>chsh -s/usr/local/bin/zsh</code></h5><figure class="highlight perl"><table><tr><td class="code"><pre><code class="hljs perl">chsh -<span class="hljs-regexp">s/usr/local/</span>bin/zsh<br><br></code></pre></td></tr></table></figure>
<blockquote>
<p>配置<code>zsh</code>是一件麻烦的事儿，爱折腾的程序猿怎么可能忍受？！ <code>oh-my-zsh</code>应运而生</p>
</blockquote>
<h4 id="3-oh-my-zsh-的诞生"><a href="#3-oh-my-zsh-的诞生" class="headerlink" title="3 oh-my-zsh 的诞生"></a>3 oh-my-zsh 的诞生</h4><h5 id="3-1-自动安装"><a href="#3-1-自动安装" class="headerlink" title="3.1 自动安装"></a>3.1 自动安装</h5><p>先用<code>HOMEBREW安装wget</code></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">wget https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/robbyrussell/</span>oh-my-zsh<span class="hljs-regexp">/raw/m</span>aster<span class="hljs-regexp">/tools/i</span>nstall.sh -O - | sh<br></code></pre></td></tr></table></figure>
<h5 id="3-2-手动安装"><a href="#3-2-手动安装" class="headerlink" title="3.2 手动安装"></a>3.2 手动安装</h5><p><code>git clonegit://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zshcp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</code></p>
<h5 id="3-3-all手动安装"><a href="#3-3-all手动安装" class="headerlink" title="3.3 all手动安装"></a>3.3 all手动安装</h5><p>在<a href="https://github.com/ohmyzsh/ohmyzsh">oh-my-zsh</a>的github主页，手动将<code>zip包</code>下载下来。</p>
<p>将<code>zip包</code>解压，拷贝至<code>~/.oh-my-zsh</code>目录。此处省略拷贝的操作步骤。</p>
<p>执行<code>cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</code></p>
<h5 id="3-4-配置文件，其余看官网吧，so-easy"><a href="#3-4-配置文件，其余看官网吧，so-easy" class="headerlink" title="3.4 配置文件，其余看官网吧，so easy!"></a>3.4 配置文件，其余看官网吧，<code>so easy!</code></h5>]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>swift类和结构体内存分配探索</title>
    <url>/2020/04/28/swift%E7%B4%AF%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<h4 id="1-类和-结构体-内存分配探索"><a href="#1-类和-结构体-内存分配探索" class="headerlink" title="1. 类和 结构体 内存分配探索"></a>1. 类和 结构体 内存分配探索</h4><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stuctandClassTest</span><span class="hljs-params">()</span></span> -&gt;()&#123;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Size</span> </span>&#123;<br>        <span class="hljs-keyword">var</span> width <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">var</span> heght <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span>&#123;<br>        <span class="hljs-keyword">var</span> x <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>        <span class="hljs-keyword">var</span> y <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br>    &#125;<br>    <span class="hljs-keyword">var</span> size <span class="hljs-operator">=</span> <span class="hljs-type">Size</span>()<br>    <span class="hljs-keyword">var</span> point <span class="hljs-operator">=</span> <span class="hljs-type">Point</span>()<br>    <br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;===+  %d&quot;</span>,<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">Size</span>&gt;.stride);<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;===+  %d&quot;</span>,<span class="hljs-type">MemoryLayout</span>&lt;<span class="hljs-type">Point</span>&gt;.stride);<br>    <br>    <span class="hljs-built_in">print</span>(class_getInstanceSize(<span class="hljs-built_in">type</span>(of: size))) <span class="hljs-comment">//获取真正的内存大小</span><br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-type">Mems</span>.ptr(ofRef: size))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-type">Mems</span>.memStr(ofRef: size))<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1----------------&quot;</span>)<br>    <br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-type">Mems</span>.ptr(ofVal: <span class="hljs-operator">&amp;</span>size))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-type">Mems</span>.memStr(ofVal: <span class="hljs-operator">&amp;</span>size))<br>       <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;2----------------&quot;</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-type">Mems</span>.ptr(ofVal: <span class="hljs-operator">&amp;</span>point))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-type">Mems</span>.memStr(ofVal: <span class="hljs-operator">&amp;</span>point))<br>    <br>    <br>&#125;<br><br>stuctandClassTest()<br><br><br><br></code></pre></td></tr></table></figure>
<h5 id="1-1打印结果"><a href="#1-1打印结果" class="headerlink" title="1.1打印结果"></a>1.1打印结果</h5><figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">===+  %d <span class="hljs-number">8</span><br>===+  %d <span class="hljs-number">16</span><br><span class="hljs-number">32</span><br><span class="hljs-number">0</span>x000000010053cfc0<br><span class="hljs-number">0</span>x000000<span class="hljs-number">01000082a8</span> <span class="hljs-number">0</span>x0000<span class="hljs-number">000200000002</span> <span class="hljs-number">0</span>x00000<span class="hljs-number">00000000001</span> <span class="hljs-number">0</span>x00000<span class="hljs-number">00000000002</span><br><span class="hljs-number">1</span>----------------<br><span class="hljs-number">0</span>x00007ffeefbff510<br><span class="hljs-number">0</span>x000000010053cfc0<br><span class="hljs-number">2</span>----------------<br><span class="hljs-number">0</span>x00007ffeefbff500<br><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000003</span> <span class="hljs-number">0</span>x00000<span class="hljs-number">00000000004</span><br><br></code></pre></td></tr></table></figure>
<h4 id="2-分析结果"><a href="#2-分析结果" class="headerlink" title="2. 分析结果"></a>2. 分析结果</h4><ul>
<li><code>0x00007ffeefbff510</code>（<code>size</code>）和<code>0x00007ffeefbff500</code>（<code>point</code>）的内存地址是挨着的，</li>
<li><p><code>size</code> 需要申请堆空间内存,堆空间的内存大小也就是<code>32字节</code>，大致流程如下：<br> 1.<code>_allocating_init()</code><br> 2.<code>_swift_allocObject</code><br> 3.<code>swift_slowAlloc</code><br> 4.<code>maloc</code></p>
</li>
<li><p><code>point</code>只是在栈空间，16个字节</p>
</li>
<li><p><code>size</code>堆空间的情况：<br>  <code>0x00000001000082a8</code>  ——<code>Size</code>类的信息</p>
<p>  <code>0x0000000200000002</code> —— 引用计数</p>
<p>  <code>0x0000000000000001</code> ——- 1</p>
<p>  <code>0x0000000000000002</code>———- 2</p>
</li>
</ul>
]]></content>
      <categories>
        <category>siwft</category>
      </categories>
      <tags>
        <tag>内存分配</tag>
      </tags>
  </entry>
  <entry>
    <title>pod install出现警告ruby的警告</title>
    <url>/2020/04/29/pod-install%E5%87%BA%E7%8E%B0%E8%AD%A6%E5%91%8Aruby%E7%9A%84%E8%AD%A6%E5%91%8A/</url>
    <content><![CDATA[<blockquote>
<p> <code>warning: Using the last argument as keyword parameters is deprecated; maybe ** should be added to the call</code></p>
</blockquote>
<h4 id="1-pod-install出现下面的问题👇-脚本用zsh"><a href="#1-pod-install出现下面的问题👇-脚本用zsh" class="headerlink" title="1. pod install出现下面的问题👇,脚本用zsh"></a>1. <code>pod install</code>出现下面的问题👇,脚本用<code>zsh</code></h4><figure class="highlight oxygene"><table><tr><td class="code"><pre><code class="hljs oxygene">/Users/gitartos/.rvm/rubies/ruby-<span class="hljs-number">2.7</span>.<span class="hljs-number">0</span>/lib/ruby/gems/<span class="hljs-number">2.7</span>.<span class="hljs-number">0</span>/gems/nanaimo-<span class="hljs-number">0.2</span>.<span class="hljs-number">6</span>/lib/nanaimo/writer/pbxproj.rb:<span class="hljs-number">13</span>: warning: <span class="hljs-keyword">Using</span> the last argument <span class="hljs-keyword">as</span> keyword parameters <span class="hljs-keyword">is</span> <span class="hljs-keyword">deprecated</span>; maybe ** should be added <span class="hljs-keyword">to</span> the call<br>/Users/gitartos/.rvm/rubies/ruby-<span class="hljs-number">2.7</span>.<span class="hljs-number">0</span>/lib/ruby/gems/<span class="hljs-number">2.7</span>.<span class="hljs-number">0</span>/gems/nanaimo-<span class="hljs-number">0.2</span>.<span class="hljs-number">6</span>/lib/nanaimo/writer.rb:<span class="hljs-number">35</span>: warning: The called <span class="hljs-function"><span class="hljs-keyword">method</span> `<span class="hljs-title">initialize</span>&#x27; <span class="hljs-title">is</span> <span class="hljs-title">defined</span> <span class="hljs-title">here</span></span><br><span class="hljs-function"><span class="hljs-title">Integrating</span> <span class="hljs-title">client</span> <span class="hljs-title">project</span></span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure>
<p>其实是ruby的问题</p>
<h4 id="2-在你的-zshrc文件中加入下面配置："><a href="#2-在你的-zshrc文件中加入下面配置：" class="headerlink" title="2. 在你的~/.zshrc文件中加入下面配置："></a>2. 在你的<code>~/.zshrc</code>文件中加入下面配置：</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">RUBYOPT</span>=-W0<br><br></code></pre></td></tr></table></figure>
<p>保存起来；</p>
<h4 id="3-Try-to-reloadZSHconfig-by-typing-就可以了。"><a href="#3-Try-to-reloadZSHconfig-by-typing-就可以了。" class="headerlink" title="3. Try to reloadZSHconfig by typing,就可以了。"></a>3. Try to reload<code>ZSH</code>config by typing,就可以了。</h4><p>使配置生效，再<code>pod install</code>,那就完美了，没出现<code>&lt;**1**&gt;</code>的问题了;</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle">Generating Pods <span class="hljs-keyword">project</span><br>Integrating client <span class="hljs-keyword">project</span><br>Pod installation complete! There are <span class="hljs-number">4</span> <span class="hljs-keyword">dependencies</span> <span class="hljs-keyword">from</span> the Podfile and <span class="hljs-number">4</span> total pods installed.<br><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cocoapods</category>
      </categories>
      <tags>
        <tag>ruby</tag>
      </tags>
  </entry>
  <entry>
    <title>感悟</title>
    <url>/2020/05/07/%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[<p><img src="http://q96fa88b1.bkt.clouddn.com/92451646_165530854660269_1736264037527961521_n.jpg" alt=""></p>
<p>我的爱越是温顺，</p>
<p>就越是远离爱。</p>
<p>在暴烈中，</p>
<p>在酷热中，</p>
<p>在渴望里，</p>
<p>在冒险里，</p>
<p>我找到了一些爱的本质。</p>
<p>我以适当的温度燃烧着，</p>
<p>以便走过爱的火焰。</p>
<p>所以，</p>
<p>当你问我为什么不能更为平静地爱你时，</p>
<p>我回答说，</p>
<p>平静地爱你就是一点也不爱你。</p>
<pre><code>                                   ----珍妮特·温特森
</code></pre>]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>爱情</tag>
      </tags>
  </entry>
  <entry>
    <title>读书感悟</title>
    <url>/2020/05/29/%E8%AF%BB%E4%B9%A6%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[<p><img src="http://q96fa88b1.bkt.clouddn.com/92754995_1216119388742169_4304828825357649633_n.jpg" alt=""></p>
<p>最近的一些读书的感想，思考起来，确实能够给自己带来一些真实的帮助和启发，希望大家在平时的工作学习中，也能够认清楚学习的一些本质。</p>
<p>如果我们的学习是在不断掌握应对具体工作场景和问题的方法，那就是在努力提升技术效率。在这种模式下，我们遇到每个新问题都要学习新知识。<br>如果我们的学习是在了解问题本质，了解解决方案的底层规律，能够让我们认清楚问题表象背后的实质，那我们就是在提升认知效率。在这种模式下，我们会发现，很多看似全新的问题，其实只不过是狡猾的旧问题换了一身装扮再次出现而已。<br>然而，我们大多数人的学习层次一直无法提升，就是因为我们掉进了追逐技术效率的游戏圈套：<strong>我们越努力，跑得越快，要学习的新知识就越多。而这，让我们陷入了学习的 “老鼠赛道”。在老鼠赛道中，我们看起来一直在努力，可是其实是在原地打转</strong>。</p>
<p><strong>看似最枯燥、最基础的东西往往具有最长久的生命力。</strong><br>技术亦是如此。不要天天谈什么框架，什么库，框架每年层出不穷，可是扒下框架那层炫酷漂亮的外衣，里面还是那些最基础的知识和原理。就是这些算法，数据结构，计算机网络，计算机原理这些看似基础的东西。如果这些掌握扎实了，你才有更加深一步的可能。<br>我们应该学会提升认知效率，而非技术效率。</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>做到这些，你就超越了大多的同龄人</title>
    <url>/2020/06/01/%E5%81%9A%E5%88%B0%E8%BF%99%E4%BA%9B%EF%BC%8C%E4%BD%A0%E5%B0%B1%E8%B6%85%E8%B6%8A%E4%BA%86%E5%A4%A7%E5%A4%9A%E7%9A%84%E5%90%8C%E9%BE%84%E4%BA%BA/</url>
    <content><![CDATA[<ol>
<li><p><strong>对同事隐藏70%，对恋人隐藏40%，对家人隐藏20%</strong>。油画中半裸的女子，往往比全裸更诱人。让自己保留一部分神秘感，会更具吸引力。如刚入职场，不要轻易将自己实力全盘托出，保留一部分实力，降低他人的期望，会更容易带来惊喜。</p>
</li>
<li><p><strong>20岁后你要果断舍弃：脆弱的玻璃心、负能量的恋人、处不来的朋友以及无意义的消遣；你要努力保持：自恰的独处、适度的温柔、从容的自信以及积极的心态</strong>。</p>
</li>
<li><p><strong>在任何亲密关系中，爱自己的比例都要超过50%。爱情靠的是吸引而不是感动，跪舔得来的感情大多不长久</strong>。当你爱自己多过爱别人，利用读书健身不断提升自己，并变得更有价值和吸引力时，你会发现，是爱情在追你，工作在追你，金钱在追你。</p>
</li>
<li><p>不要纠结于木板效应。很多时候我们不需要面面俱到，只需要将自己优势特长发挥到最好，它散发的光芒会掩饰我们的不足，并且最终决定你价值和财富的，往往是你最擅长的那一项。</p>
</li>
<li><p><strong>最杰出的人，往往都是刚柔并</strong>济。Ta们即有男生的狼性，又有女生的柔性。狼性让ta更好适应丛林法则，有咬定猎物不放松的毅力；柔性让ta更弹性的处理事情，有遇事不被轻易击垮的耐力。具有这两种特性的人，大多是工作中的佼佼者。</p>
</li>
<li><p><strong>人脉的宽度和深度，取决于你可提供的价值</strong>。一味向他人索求，自己却未能提供对等价值回报，这种人脉大多是不长久的。多花点心思精进工作相关技能，如考证培训。当你具有不可替代性时，会拥有更高质量人脉关系。</p>
</li>
<li><p><strong>在恋爱中一定不要牺牲自我</strong>（<code>男女均适用</code>）！有些男生，一味满足女友的高奢侈欲望，如买名牌包包和香水等，自己却熬夜加班喝粥度日，最终也还是败给了所谓的「合不来」。靠自我牺牲维持的恋情，注定走不远。</p>
</li>
<li><p><strong>生活也好，工作也罢，别轻易暴露你的软弱。很多人看到大BOSS就瑟瑟发抖，即使自己的利益受损也不敢出声。长此以往，每当团队要有人牺牲时，你总会成为BOSS的首选，欺软是几千年沉淀下来的人性，一向如此。</strong></p>
</li>
<li><p>为人处世的最高境界，不是全盘接受，而是适当拒绝。合理的请求，能帮就帮；无理的要求，果断回绝。把当烂好人的时间，多放在自己身上。时刻保持界限感，会让你更受尊重。</p>
</li>
<li><p>不要被别人的眼光，绊住了脚。有些人想去做一件事，却担心做不到引人笑话，于是一直碌碌无为。我喜欢写作，曾经也一度不敢公开发表，担心别人对自己才华的轻视，但从被频繁拒稿，到投稿中国青年六投六中，我只是做到了屏蔽外界嘈杂的声音，专注于精进自己。<br><strong>如果你也想和我一样改变自己，那就从双击点赞开始，一是作为你行动的见证，二是以后想看就不怕找不到了</strong>。</p>
</li>
<li><p><strong>不要像戏精一样，沉溺在</strong><code>「伪努力」</code><strong>的自我感动中</strong>。有些人上班挤公交四五小时，觉得自己异常努力。但你所付出的辛苦，并不能对你的收入带来一点提升。明白这点，会大大提高你的工作效率，并减少你70%的抱怨。</p>
</li>
<li><p><strong>好的恋情是锦上添花，而非相互打压</strong>。你抱怨男朋友不求上进，沉迷游戏。男朋友嫌弃你身材臃肿，懒惰邋遢。两个人终日只会互相消耗，进而自甘堕落和日渐自卑。好的恋情不是相互诋毁获得优越，而是共同扶持一起成长。</p>
</li>
<li><p><strong>跟胡搅蛮缠的人讲道理，是对自己的一种变向透支</strong>。职场中遇到一些不可理喻的人，不要跟他们辨解，耗费了自己精力，别人却不以为意。不如将辨解的时间用于精进自己专业能力，以此获得职场地位的快速提升。学习和生活也是如此。</p>
</li>
<li><p><strong>无基础的急功近利，会让你寸步难行</strong>。很多人都会高估自己一年左右完成的事，而低估自己三年左右可以完成的事。对于刚毕业大学生，想好自己未来职业规划，以及自己的优势定位。在一个行业精耕细作打磨三年，会比五年内不同行业频繁换岗，更容易让你获得高收入。</p>
</li>
<li><strong>20来岁的年纪，脱贫远比脱单重要，这是你实现恋爱自由的底气</strong>。从现在开始培养一些理财小习惯，可以让你更快实现财富自由。<br>手机下载记账软件，消费后随笔记账，每月分类总结自我花销； 闲钱大部分放在微信零钱通或余额宝； 每个月存下自己收入的10%； 关注财经新闻。</li>
<li><strong>作为男生，不要在该尽义务时，说女士优先，而享有权利时，说男女平等</strong>。</li>
<li><p><strong>想深入了解一个人，就看Ta人性最低处。如果你在考虑是否和某个人恋爱，别看Ta心情好时对你如何，要看Ta最生气时什么样子</strong>。若在最生气时对你歇斯底里，满口脏话，就不要考虑发展为男朋友了。记住这一点可让你避免80%的不幸恋情。</p>
</li>
<li><p><strong>小孩才要辨别绝对善恶，大人往往处在灰色地带</strong>。这世上不存在绝对的好人和坏人，监狱里的杀人犯会宠溺猫咪，对你很好的阿姨会驱赶乞丐。培养自己的灰度思维，用多角度分析替代单一认知，你会更真心接纳你身边70%的人。</p>
</li>
<li><p><strong>遇事波澜不惊，喜恶暗藏于心</strong>。很生气的时候在心里倒数5秒，深呼吸过后再开口讲话。管控自己的面部表情，是进入职场最基本的标配。</p>
</li>
<li><strong>实施自律的最好方式，就是「量化执行」</strong>。如十点半睡觉，六点半起床；每天做平板撑三组，每组一分钟；一周一本书，一天五十页，当你这样做时，会发现自律没有那么难。<br>在知乎上看到有帮助的答案，随手一个赞，我得到了鼓励，你收获了感激。</li>
<li><strong>没有规划的毕业大学生，参考以下两种方式选择就业，你的收入和能力，在未来三年会超过80%的同龄人。</strong><br><code>选赚钱多的行业，如理工类的计算机，文科类的地产、金融、咨询。 选增值容错率高，可学到硬技能的岗位。如审计，会计，法律，编程等</code>。</li>
<li><strong>把与工作无关的阅读，如刷知乎，看文学类书籍，当作是娱乐，而不是学习</strong>。这些在下班时间看是加分，上班时间看是减分。</li>
<li><strong>亲情也好，爱情也罢，只有真正爱你的人，才会因为你一点小情绪而缴械投降</strong>。珍惜真正爱你的人，给父母一周打一次电话，给伴侣做一桌可口晚餐。不要将他们对你的爱，当作你任性的砝码，肆意挥霍。</li>
<li><strong>最好的自律，是延迟满足感</strong>。少做让你获得短期快乐的事情：如熬夜，刷抖音，看肥皂剧，吃油炸食品。多进行长期获益的投资：如健身，学理财，深入阅读，吃绿色蔬菜。</li>
<li><strong>成年后，能让你脱离平庸的能力——「独立思辨」</strong>。独立思辨不是指固执已见，而是不人云亦云，保持独立思考的能力。而大多数的独立思辨，是建立在努力的基础上的。<br>不明白自己该往哪个方向努力时，健身、学英语、看书准不会错。</li>
<li><strong>假期也好，工作也罢，熬夜往往是主动选择</strong>。很多人抱怨工作日业务没有完成，必须熬夜。如果你早起或提高白天工作效率，完成的任务质量会远高于熬夜时。当你不再为熬夜找借口，三年后，你的样貌和收入会超过90%的同龄人。</li>
<li><strong>免费保姆做的再好，也留不住心爱的人</strong>。不要轻易为了取悦谁改变自己，除非那个改变正好是你想要的。太用力爱一个人，会失去最初让Ta心动的所有魅力。</li>
<li><strong>那些真正获得高收入、高成就的人，往往具有过硬专业能力</strong>。而培养专业能力的最好方法，也是唯一方法：就是选择一个行业深耕下去。三五年后再回看，你已经比90%的同龄人走的远了。</li>
<li><strong>人与人之间，总在时刻做着加减法</strong>。决定分数加减的可以是一句话，一个动作，一件小事。同一件事关系好的影响小一点，反之大一点。但这并不意味着Ta们没有感知，不要以为关系好就占人便宜，随便使唤。明白这一点，可以帮你维系好90%的友谊。</li>
<li><strong>勤奋的效用，有时是大于选择的</strong>。只有通过勤奋，将自己提升到宽阔的视角，和高的层次，才会为自己做出较好的选择。</li>
<li><strong>友情也好，爱情也罢，相处不适，尽早远离</strong>。 不要过多纠结于过去的沉没成本，如时间、金钱和精力等。一双不合脚的鞋，最好的处理办法是尽早丢掉，而不是惋惜，这样你才有机会穿到更舒适的鞋子。</li>
<li><strong>成长的最快捷径，就是直面你害怕的事</strong>。<br>越是能让你窘迫的批评，越表明它客观中肯，也越需要去纠正；越是使你敬畏的上司，越可以学习到更多专业知识，也越能提升自我；越是让你感到剧痛的过程，越可以磨炼你的意志，也越能让你快速成长。</li>
<li><strong>好形象自带认可属性。公司好看的小姐姐会更受欢迎；同等能力下，HR会招聘形象更好的求职者</strong>。路过任何反光镜面时，关注一下个人表情和服饰的整洁，在公共场合不要跷二郎腿和抖腿等。这些做法让你在提升能力的同时更自信，也更容易获得高收入和好人脉。</li>
<li><strong>有些「努力」，只是在为你过往的懒惰买单</strong>。很多人觉得做一件事付出了十分的努力，却只得到五分的回报。其实剩下的五分，是在填补你过往的懒惰。只有将过往懒惰填满，努力才会有正向成果。</li>
<li><strong>警惕自我安慰式阅读</strong>。有些人会在不想工作时看书，即逃避了工作，又安慰自己是在学习与进步。这是一种对自己极不负责的行为，如果只是为了自我安慰去看书，那么本质和刷抖音、打游戏无异。<br>正确的方式是为了提升自我而读书。因为看一本好书，对一个人的改变是巨大的。记得我刚上大学时，就是个废材，每天打游戏睡懒觉度日，后来终于想明白自己要什么，开始大量阅读，持续阅读，6年下来，看了接近500本（有的书会精看，有的不适合自己的书，就挑几页对自己有帮助的看）。</li>
<li><strong>始终保持有分寸感的温柔</strong>。温柔不是任何情况下的隐忍屈就，不是毫无原则底线的退让，也不仅仅是说话轻言软语眉眼带笑，而是对人与事物，有一份不可抵抗的同理心，温柔的人往往会吸引更多人靠近ta。</li>
<li><strong>即使天上下刀子也要读书</strong>。很多人认为自信源于精致的五官，黄金比例的身材，精美的服饰，这只是带来自信的一部分因素。比起这些更让一个人自信的，是不俗的认知和更高层次的格局，而这正是阅读所带来的。</li>
<li><strong>产生焦虑的源头之一，是不规律的生活</strong>。大部分人的焦虑是太多空闲时间，所导致的胡思乱想。而规律的生活，是告别焦虑的开始。疫情让很多人生活节奏变得混乱，并带来慌张和不安。建议先给自己制定一个24小时生活图，并严格执行，这样会大幅降低我们内心的焦虑。</li>
<li><strong>好的恋情，不是单向仰望，而是势均力敌</strong>。如果想找到一个很优秀的伴侣，自己首先要变得优秀。学会建立自己的兴趣爱好，如瑜伽、读书等，你所培养的气质，会吸引Ta主动走向你。</li>
<li><strong>接受自己的情绪，是控制它的最好方法</strong>。很多人有情绪时，第一反应是控制它，情绪得不到释放变得压抑，在下一次遇到问题仍会复发。我们应该先认可并接受它，告诉自己我有这样的情绪很正常，并把自己从中剥离开来，像是在观察另一个人的情绪，它就会渐渐消退。</li>
<li><strong>增加人生的支点，拓宽你的生活圈</strong>。有些人的生活由一个支点组成，如爱情，在爱情破灭时，整个世界分崩离析。如果你的人生由两个以上支点组成，如工作、家庭、朋友、娱乐、恋人、爱好等，当其中一个支点断裂时，你会更容易恢复，而不是被它击溃。</li>
<li><strong>年轻时，不缺爱，不缺鼓励和认可，缺的是自律和成长</strong>。如果现在的选择不是你想要的，那就先努力提升自己，多去健身、读书和旅行。终有一天，你会遇到你期望已久的那个人，在那之前要做的不是等待，而是变得更值得被爱。</li>
<li><strong>不要总用 “嗯，这就是生活”来麻痹自己</strong>。世上没有那么多无可奈何，不过是能力没有达到。我们可以反思深思，但要抵触沉重。当你努力去对待生活，会发现即使你没有绝顶聪明，也可以得到你想要的。</li>
<li><strong>真正快速的成长，往往伴随阵痛</strong>。成长以后落地窗外绯红的晨曦，傍晚瑰丽的晚霞，以及夜晚触手可及的月亮星辰，处处皆是景。</li>
</ol>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS性能优化-安装包瘦身</title>
    <url>/2020/12/23/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%AE%89%E8%A3%85%E5%8C%85%E7%98%A6%E8%BA%AB/</url>
    <content><![CDATA[<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.biaobaiju.com%2Fuploads%2F20190508%2F18%2F1557312058-zObtpAiXgK.jpg&amp;refer=http%3A%2F%2Fimage.biaobaiju.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611304390&amp;t=c28765de398489f92566de79a71a1c0c" alt=""></p>
<h3 id="1-常规瘦身方案"><a href="#1-常规瘦身方案" class="headerlink" title="1.常规瘦身方案"></a><strong>1.常规瘦身方案</strong></h3><h5 id="1-压缩资源"><a href="#1-压缩资源" class="headerlink" title="1.压缩资源"></a>1.压缩资源</h5><blockquote>
<p>项目中资源包括图片、字符串、音视频等资源。由于项目中图片比较多，所以资源压缩一般会从图片入手。在把图片加入到项目中时候需要采用tinypng或者ImageOptim对图片进行压缩；另外，可以通知设计，对切图进行压缩处理再上传；不需要内嵌到项目中的图片可以改为动态下载。</p>
</blockquote>
<ul>
<li>png，jpg，gif可以替换成webp</li>
<li>动画图片可替换为lotties、APNG</li>
<li>小图或表情图可替换为iconFont</li>
<li>大图可替换为svg</li>
</ul>
<h5 id="2-删除无用-重复资源"><a href="#2-删除无用-重复资源" class="headerlink" title="2.删除无用/重复资源"></a>2.删除无用/重复资源</h5><p>删除无用的资源。项目中主要以删除图片为主：</p>
<ul>
<li>图片用2x和3x图就可以，不要用1x图。</li>
<li>可以用<code>LSUnusedResources</code>搜索出未使用的图片然后删除之。<br><code>注意：该软件搜索出来的图片有可能项目中还在用，删除之前需要在工程中先搜索下图片是否有使用再确认是否可以删除。</code></li>
</ul>
<h5 id="3-删除无用代码"><a href="#3-删除无用代码" class="headerlink" title="3.删除无用代码"></a>3.删除无用代码</h5><p>删除无用类和库：可以用<code>WBBladesForMac</code>来分析，注意：通过字符串调用的类也会检测为无用类。</p>
<h3 id="2-非常规瘦身方案"><a href="#2-非常规瘦身方案" class="headerlink" title="2.非常规瘦身方案"></a><strong>2.非常规瘦身方案</strong></h3><h4 id="1-Strip-：去除不必要的符号信息。"><a href="#1-Strip-：去除不必要的符号信息。" class="headerlink" title="1.Strip ：去除不必要的符号信息。"></a>1.Strip ：去除不必要的符号信息。</h4><p><code>-Strip Linked Product</code>和 <code>Strip Swift Symbols</code> 设置为 <code>YES</code>，<code>Deployment Postprocessing</code> 设置为 <code>NO</code>，发布代码的时候也需要勾选 <code>Strip Swift Symbols</code>。</p>
<p><code>Strip Debug Symbols During Copy</code> 和 <code>Symbols Hidden by Default</code> 在<code>release</code>下设为YES<br><code>Dead Code Stripping</code> 设置为 <code>YES</code><br>对于动态库，可用<code>strip -x [动态库路径]</code>去除不必要的符号信息</p>
<h4 id="2-Make-Strings-Read-Only设为YES。"><a href="#2-Make-Strings-Read-Only设为YES。" class="headerlink" title="2.Make Strings Read-Only设为YES。"></a>2.Make Strings Read-Only设为YES。</h4><h4 id="3-Link-Time-Optimization（LTO）release下设为-Incremental。WWDC2016介绍编译时会移除没有被调用的方法和代码，优化程序运行效率。"><a href="#3-Link-Time-Optimization（LTO）release下设为-Incremental。WWDC2016介绍编译时会移除没有被调用的方法和代码，优化程序运行效率。" class="headerlink" title="3.Link-Time Optimization（LTO）release下设为 Incremental。WWDC2016介绍编译时会移除没有被调用的方法和代码，优化程序运行效率。"></a>3.Link-Time Optimization（LTO）release下设为 Incremental。WWDC2016介绍编译时会移除没有被调用的方法和代码，优化程序运行效率。</h4><h4 id="4-开启BitCode"><a href="#4-开启BitCode" class="headerlink" title="4.开启BitCode"></a>4.开启<code>BitCode</code></h4><ul>
<li><code>watchOS</code>,<code>Bitcode</code>是必选的；</li>
<li>而<code>Mac OS</code>是不支持<code>Bitcode</code>的。</li>
<li>对于<code>iOS</code>，Bitcode是可选的，根据你对APP的要求已经第三方库的事情情况决定是否使用<h4 id="5-去除异常支持。不能使用-try-catch，包只缩小0-1M，效果不显著。"><a href="#5-去除异常支持。不能使用-try-catch，包只缩小0-1M，效果不显著。" class="headerlink" title="5.去除异常支持。不能使用@try @catch，包只缩小0.1M，效果不显著。"></a>5.去除异常支持。不能使用@try @catch，包只缩小0.1M，效果不显著。</h4></li>
</ul>
<p><code>Enable C++ Exceptions</code>和<code>Enable Objective-C Exceptions</code>设为NO，<code>Other C Flags</code>添加<code>-fno-exceptions</code></p>
<h4 id="6-不生成debug-symbols：不能生成dSYM，效果非常显著。"><a href="#6-不生成debug-symbols：不能生成dSYM，效果非常显著。" class="headerlink" title="6.不生成debug symbols：不能生成dSYM，效果非常显著。"></a>6.不生成<code>debug symbols：</code>不能生成<code>dSYM</code>，效果非常显著。</h4><p><code>Generate debug symbols</code>选项 <code>release</code>设置为<code>NO</code></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>git命令整理</title>
    <url>/2020/12/31/git%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h3><blockquote>
<p>本文主要记录日常工作中，git使用过程中的常用命令。后续会持续更新完善。</p>
</blockquote>
<h3 id="2-环境配置"><a href="#2-环境配置" class="headerlink" title="2 环境配置"></a>2 环境配置</h3><h4 id="2-1-参数配置"><a href="#2-1-参数配置" class="headerlink" title="2.1 参数配置"></a>2.1 参数配置</h4><blockquote>
<p><code>git客户端</code>安装完毕后，需要进行变量配置。主要配置<code>user.name</code>和<code>user.email</code>两个属性，用来标识<code>git</code>操作者的身份。</p>
</blockquote>
<p>（1）查看全局所有配置<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">git config --global --list<br></code></pre></td></tr></table></figure><br>（2）查看全局某个属性配置<br><figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global user.name</span><br>git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global user.email</span><br></code></pre></td></tr></table></figure><br>（3）设置全局属性<br><figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog">git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.name</span> <span class="hljs-string">&quot;xxx&quot;</span><br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.email</span> <span class="hljs-string">&quot;xxx@126.com&quot;</span><br></code></pre></td></tr></table></figure><br>（4）删除某个全局配置<br><figure class="highlight brainfuck"><table><tr><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">git</span> <span class="hljs-comment">config</span> --<span class="hljs-comment">global</span> --<span class="hljs-comment">unset</span> <span class="hljs-comment">user</span><span class="hljs-string">.</span><span class="hljs-comment">name</span><br></code></pre></td></tr></table></figure><br>（5）打开全局参数配置文件<br><figure class="highlight brainfuck"><table><tr><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">git</span> <span class="hljs-comment">config</span> --<span class="hljs-comment">global</span> --<span class="hljs-comment">edit</span><br></code></pre></td></tr></table></figure><br>此命令会打开一个文件，可直接更改文件中的参数。</p>
<p>（6）默认文件打开方式还原</p>
<p>如配置文件打开方式，更改为本地软件后，想更改为原来的打开方式，可以执行如下命令：<br><figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global core.editor vi</span><br></code></pre></td></tr></table></figure></p>
<h4 id="2-2-访问远程仓库"><a href="#2-2-访问远程仓库" class="headerlink" title="2.2 访问远程仓库"></a>2.2 访问远程仓库</h4><p>访问远程仓库，一般会直接执行<code>clone</code>命令。如下：<br><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/xxx/my</span>test.git<br></code></pre></td></tr></table></figure><br>初次访问git仓库，会弹出提示框要求输入git服务器的用户名密码。如多次输入失败，会提示<br><figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-attribute">remote</span>: xxx<span class="hljs-variable">@126</span>.<span class="hljs-attribute">com</span>: Incorrect username or password (access token)<br><span class="hljs-attribute">fatal</span>: Authentication failed for <span class="hljs-string">&#x27;https://gitee.com/xxx/mytest.git/&#x27;</span><br></code></pre></td></tr></table></figure><br>这种情况需要清空windows凭据（控制面板-&gt;凭据管理器），输入正确的用户名密码</p>
<h3 id="3-常用命令"><a href="#3-常用命令" class="headerlink" title="3 常用命令"></a>3 常用命令</h3><h4 id="3-1-分支开发"><a href="#3-1-分支开发" class="headerlink" title="3.1 分支开发"></a>3.1 分支开发</h4><h4 id="3-1-1-克隆远程分支"><a href="#3-1-1-克隆远程分支" class="headerlink" title="3.1.1 克隆远程分支"></a>3.1.1 克隆远程分支</h4><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 克隆远程分支到本地</span><br>git clone https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/xxx/my</span>test.git<br></code></pre></td></tr></table></figure>
<h4 id="3-1-2-创建新分支"><a href="#3-1-2-创建新分支" class="headerlink" title="3.1.2 创建新分支"></a>3.1.2 创建新分支</h4><p>（1）根据当前分支创建本地分支，并切换到此分支<br><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> checkout -b dev<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><br>（2）更改代码后，提交到本地仓库<br><figure class="highlight vala"><table><tr><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 更改代码......</span><br><br><span class="hljs-meta"># 所有&quot;新增&quot;文件和&quot;删除&quot;文件加入到暂存区【建议】</span><br>git add -A<br><br><span class="hljs-meta"># 提交到本地仓库</span><br>git commit -m <span class="hljs-string">&quot;read me&quot;</span><br></code></pre></td></tr></table></figure><br>3）推送到远程仓库</p>
<p>新拉取的分支，第一次推送到远程仓库时，需指定远程仓库的名称并创建关联关系，有如下两种方式：</p>
<ul>
<li><code>push</code>命令<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 推送到远程新分支+创建本地和远程分支的关联关系</span><br><span class="hljs-attribute">git</span> push -u origin dev<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li>
<li><code>push</code>命令+<code>branch</code>命令<figure class="highlight vala"><table><tr><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 推送当前分支到远程新分支</span><br>git push origin dev1<br><br><span class="hljs-meta"># 当前分支和推送到的远程分支，创建关联关系</span><br> git branch --<span class="hljs-keyword">set</span>-upstream-to=origin/dev1<br></code></pre></td></tr></table></figure>
创建远程分支，创建关联关系后，之后再推送代码，如无特殊要求，推送时，无需再指定远程分支，推送时直接执行如下命令：<figure class="highlight avrasm"><table><tr><td class="code"><pre><code class="hljs avrasm">git <span class="hljs-keyword">push</span><br></code></pre></td></tr></table></figure>
查看远程分支和本地分支对应关系命令如下:<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch -vv</span><br></code></pre></td></tr></table></figure>
输出内容如下，中括号内为远程分支名称：<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">$ git branch -vv<br>  dev1   c1715e4 [origin/dev1] <span class="hljs-built_in">read</span> <span class="hljs-keyword">me</span><br></code></pre></td></tr></table></figure>
<h4 id="3-2-查看命令"><a href="#3-2-查看命令" class="headerlink" title="3.2 查看命令"></a>3.2 查看命令</h4></li>
</ul>
<h5 id="3-2-1-远程操作"><a href="#3-2-1-远程操作" class="headerlink" title="3.2.1 远程操作"></a>3.2.1 远程操作</h5><p>（1）查看当前分支对应的远程地址<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git remote -v</span><br></code></pre></td></tr></table></figure><br>输出内容如下，可以查看分支对应的远程地址：<br><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">$ git remote -v<br>origin  https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/xxx/my</span>test.git (fetch)<br>origin  https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/xxx/my</span>test.git (push)<br></code></pre></td></tr></table></figure></p>
<h5 id="3-2-2-分支相关"><a href="#3-2-2-分支相关" class="headerlink" title="3.2.2 分支相关"></a>3.2.2 分支相关</h5><p>（1）查看分支<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># 查看本地分支</span><br>git <span class="hljs-keyword">branch</span><br><span class="hljs-keyword"></span><br><span class="hljs-keyword"># </span>查看远程分支<br>git <span class="hljs-keyword">branch </span>-r<br><br><span class="hljs-comment"># 查看所有分支</span><br>git <span class="hljs-keyword">branch </span>-a<br><br><span class="hljs-comment"># 查看远程分支和本地分支对应关系</span><br>git <span class="hljs-keyword">branch </span>-vv<br><br></code></pre></td></tr></table></figure><br>（2）切换本地分支<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git checkout xxx</span><br></code></pre></td></tr></table></figure><br>用法如下：<br><figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 切换到本地master分支</span><br>git checkout <span class="hljs-literal">master</span><br><br><span class="hljs-comment"># 切换到本地feature/dev1分支</span><br>git checkout feature/dev1<br></code></pre></td></tr></table></figure></p>
<h5 id="3-2-3-日志相关"><a href="#3-2-3-日志相关" class="headerlink" title="3.2.3 日志相关"></a>3.2.3 日志相关</h5><figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 单行+ 图形化方式查看日志【建议】</span><br>git <span class="hljs-built_in">log</span> <span class="hljs-comment">--graph --oneline</span><br><br><span class="hljs-comment"># 查看日志</span><br>git <span class="hljs-built_in">log</span> <br><br><span class="hljs-comment"># 单行查看日志</span><br>git <span class="hljs-built_in">log</span> <span class="hljs-comment">--oneline</span><br><br><span class="hljs-comment"># 图形化方式查看日志</span><br>git <span class="hljs-built_in">log</span> <span class="hljs-comment">--graph</span><br></code></pre></td></tr></table></figure>
<h4 id="3-3-撤销变更"><a href="#3-3-撤销变更" class="headerlink" title="3.3 撤销变更"></a>3.3 撤销变更</h4><h5 id="3-3-1-撤销工作区变更"><a href="#3-3-1-撤销工作区变更" class="headerlink" title="3.3.1 撤销工作区变更"></a>3.3.1 撤销工作区变更</h5><p>未使用<code>git add</code>时</p>
<p>受版本控制的文件，变更后进行撤销</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 放弃某个文件更改（受版本控制的文件，进行变更）</span><br>git checkout xx<br><br><span class="hljs-meta"># 放弃所有工作区文件更改（受版本控制的文件，进行变更）</span><br>git checkout .<br><br></code></pre></td></tr></table></figure>
<p>不收版本控制的文件，进行撤销<br><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 删除未被跟踪的目录和文件</span><br><span class="hljs-attribute">git</span> clean -fd<br></code></pre></td></tr></table></figure></p>
<h5 id="3-3-2-撤销暂存区变更"><a href="#3-3-2-撤销暂存区变更" class="headerlink" title="3.3.2 撤销暂存区变更"></a>3.3.2 撤销暂存区变更</h5><p>已使用<code>git add</code>，未使用<code>git commit</code>。只撤销到工作区，如需从工作区撤销，仍然需要继续撤销</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 恢复某个“暂存文件”到“工作区”</span><br>git <span class="hljs-keyword">reset</span> HEAD XXX<br><br><span class="hljs-comment"># 恢复所有“暂存文件”到“工作区”</span><br>git <span class="hljs-keyword">reset</span> HEAD .<br></code></pre></td></tr></table></figure>
<h5 id="3-3-3-撤销本地仓库变更"><a href="#3-3-3-撤销本地仓库变更" class="headerlink" title="3.3.3 撤销本地仓库变更"></a>3.3.3 撤销本地仓库变更</h5><p>已执行<code>git commit</code>，未执行<code>git push</code><br><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 撤销“本地仓库”</span><br><span class="hljs-attribute">git</span> reset --soft <span class="hljs-number">5</span>f<span class="hljs-number">7024</span>f<br><br><span class="hljs-comment"># 撤销“本地仓库”+“暂存区”</span><br><span class="hljs-attribute">git</span> reset --mixed <span class="hljs-number">5</span>f<span class="hljs-number">7024</span>f<br><br></code></pre></td></tr></table></figure></p>
<h5 id="3-3-4-撤销远程仓库变更"><a href="#3-3-4-撤销远程仓库变更" class="headerlink" title="3.3.4 撤销远程仓库变更"></a>3.3.4 撤销远程仓库变更</h5><p>已push到远程仓库的记录，进行撤销</p>
<p>（1）不生成撤销记录<br><figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 重置到某个分支</span><br>git reset <span class="hljs-comment">--hard 重置到的镜像ID</span><br><br><span class="hljs-comment"># 强推到远程（可能会收到分支保护限制）</span><br> git push <span class="hljs-comment">--force origin master </span><br></code></pre></td></tr></table></figure><br>强推后远程日志，不再存在之前强推前的日志，如需要还原到强推前的内容，可借助reflog日志进行回滚<br><figure class="highlight vala"><table><tr><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 查看操作日志reflog</span><br>git reflog<br><br><span class="hljs-meta"># 回滚到指定分支目录</span><br>git reset --hard <span class="hljs-number">7167</span>ac9<br><span class="hljs-meta"># 推送到远程分支</span><br>git push origin master<br></code></pre></td></tr></table></figure><br>reflog如下<br><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">241323</span>f (HEAD -&gt; master, origin/master) HEAD@&#123;<span class="hljs-number">0</span>&#125;: <span class="hljs-keyword">reset</span>: moving <span class="hljs-keyword">to</span> <span class="hljs-number">241323</span>f<br><span class="hljs-number">7167</span>ac9 HEAD@&#123;<span class="hljs-number">1</span>&#125;: <span class="hljs-keyword">commit</span>: xxx<span class="hljs-comment">--new</span><br></code></pre></td></tr></table></figure><br>（2）生成撤销记录<br><figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># 撤掉某次提交</span><br>git revert --no-<span class="hljs-keyword">edit</span> 需要撤销掉的提交ID<br><br><span class="hljs-meta"># 提交</span><br>git <span class="hljs-keyword">push</span> origin master<br></code></pre></td></tr></table></figure></p>
<h4 id="3-4-合并分支"><a href="#3-4-合并分支" class="headerlink" title="3.4 合并分支"></a>3.4 合并分支</h4><h5 id="3-4-1-合并"><a href="#3-4-1-合并" class="headerlink" title="3.4.1 合并"></a>3.4.1 合并</h5><p>（1）<code>pull</code>合并</p>
<p><code>pull</code>命令等于<code>fetch+merage</code>，建议此种方式：<br><figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># 合并远程分支</span><br>git pull origin dev1 --no-<span class="hljs-keyword">edit</span><br><br><span class="hljs-meta"># 推送到远程分支</span><br>git <span class="hljs-keyword">push</span><br></code></pre></td></tr></table></figure><br>不加<code>--no-edit</code>参数，会打开一个编辑器，可以更改合并的提交信息：</p>
<p><strong>（2）merge合并 </strong><br><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> merge origin/dev<span class="hljs-number">00</span><br></code></pre></td></tr></table></figure></p>
<h5 id="3-4-2-处理冲突"><a href="#3-4-2-处理冲突" class="headerlink" title="3.4.2 处理冲突"></a>3.4.2 处理冲突</h5><p>（1）查看冲突文件，进行冲突处理</p>
<p>合并分支的时候，经常会出现有冲突的情况，可通过<code>git status</code>查看当前合并情况：<br><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">$ git status<br>On branch master<br>Your branch <span class="hljs-keyword">is</span> <span class="hljs-keyword">up</span> <span class="hljs-keyword">to</span> date with <span class="hljs-string">&#x27;origin/master&#x27;</span>.<br><br>You have unmerged paths.<br>  (<span class="hljs-keyword">fix</span> conflicts <span class="hljs-built_in">and</span> run <span class="hljs-string">&quot;git commit&quot;</span>)<br>  (use <span class="hljs-string">&quot;git merge --abort&quot;</span> <span class="hljs-keyword">to</span> abort the merge)<br><br>Unmerged path<span class="hljs-variable">s:</span><br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">mark</span> resolution)<br><br>        both modified:   ReadMe<br><br><span class="hljs-keyword">no</span> <span class="hljs-keyword">changes</span> added <span class="hljs-keyword">to</span> commit (use <span class="hljs-string">&quot;git add&quot;</span> <span class="hljs-built_in">and</span>/<span class="hljs-built_in">or</span> <span class="hljs-string">&quot;git commit -a&quot;</span>)<br></code></pre></td></tr></table></figure><br>此种情况，需要通过内置编辑器或外置编辑器（如idea或vscode等），对冲突的文件进行处理：</p>
<p>（2）标记文件已处理</p>
<p>处理完毕冲突后，执行如下命令<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 处理冲突后，标记文件已经处理</span><br>git <span class="hljs-keyword">add</span><span class="bash"> .</span><br>git <span class="hljs-keyword">add</span><span class="bash"> -A</span><br>git <span class="hljs-keyword">add</span><span class="bash"> &lt;file&gt;...</span><br></code></pre></td></tr></table></figure><br>之后查看<code>git status</code>，结果如下：<br><figure class="highlight vhdl"><table><tr><td class="code"><pre><code class="hljs vhdl">$ git status<br><span class="hljs-keyword">On</span> branch master<br>Your branch <span class="hljs-keyword">is</span> up <span class="hljs-keyword">to</span> date <span class="hljs-keyword">with</span> <span class="hljs-symbol">&#x27;origin</span>/master&#x27;.<br><br><span class="hljs-keyword">All</span> conflicts fixed but you are still merging.<br>  (<span class="hljs-keyword">use</span> <span class="hljs-string">&quot;git commit&quot;</span> <span class="hljs-keyword">to</span> conclude merge)<br><br>Changes <span class="hljs-keyword">to</span> be committed:<br><br>        modified:   ReadMe<br></code></pre></td></tr></table></figure><br>（3）提交合并</p>
<p>提交合并，<code>commit</code>后不需要其他参数</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git commit</span><br></code></pre></td></tr></table></figure>
<p>默认情况下，会弹出编辑框，提示可更改此次合并的提交日志，如下：</p>
<blockquote>
<p>如不想更改合并日志信息，直接commit，则可以在命令后增加参数—no-edit。命令如下：<br><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit --<span class="hljs-literal">no</span>-edit<br></code></pre></td></tr></table></figure><br><figure class="highlight vala"><table><tr><td class="code"><pre><code class="hljs vala">Merge branch <span class="hljs-string">&#x27;dev00&#x27;</span> of https:<span class="hljs-comment">//gitee.com/xxx/mytest3</span><br><br><span class="hljs-meta"># Conflicts:</span><br><span class="hljs-meta">#       ReadMe</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># It looks like you may be committing a merge.</span><br><span class="hljs-meta"># If this is not correct, please remove the file</span><br><span class="hljs-meta">#       .git/MERGE_HEAD</span><br><span class="hljs-meta"># and try again.</span><br><br><br><span class="hljs-meta"># Please enter the commit message for your changes. Lines starting</span><br><span class="hljs-meta"># with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># On branch master</span><br><span class="hljs-meta"># Your branch is up to date with &#x27;origin/master&#x27;.</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># All conflicts fixed but you are still merging.</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># Changes to be committed:</span><br><span class="hljs-meta">#       modified:   ReadMe</span><br><span class="hljs-meta">#</span><br></code></pre></td></tr></table></figure><br>更改完毕（或不更改）后，关闭此文件即可，关闭文件后，提示如下内容：<br><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">$ git commit<br>[master <span class="hljs-number">2339</span>e32] Merge branch <span class="hljs-string">&#x27;dev00&#x27;</span> of https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/xxx/my</span>test3<br></code></pre></td></tr></table></figure><br>代表已经合并完毕。</p>
</blockquote>
<p>（4）推送到远程分支</p>
<p>此时已经合并完毕，推送到远程分支即可：<br><figure class="highlight avrasm"><table><tr><td class="code"><pre><code class="hljs avrasm">git <span class="hljs-keyword">push</span><br></code></pre></td></tr></table></figure></p>
<h4 id="3-5-rebase命令"><a href="#3-5-rebase命令" class="headerlink" title="3.5 rebase命令"></a>3.5 <code>rebase</code>命令</h4><p>待完善。。。。。。</p>
<h4 id="4-其他命令"><a href="#4-其他命令" class="headerlink" title="4 其他命令"></a>4 其他命令</h4><h5 id="4-1-加入到缓存区"><a href="#4-1-加入到缓存区" class="headerlink" title="4.1 加入到缓存区"></a>4.1 加入到缓存区</h5><figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 所有&quot;新增&quot;文件和&quot;删除&quot;文件加入到暂存区【建议】</span><br>git <span class="hljs-keyword">add</span><span class="bash"> -A</span><br><br><span class="hljs-comment"># 所有“新增”文件加入到暂存区</span><br>git <span class="hljs-keyword">add</span><span class="bash"> .</span><br><br><span class="hljs-comment"># “指定”文件加入到暂存区</span><br>git <span class="hljs-keyword">add</span><span class="bash"> xxx xxx</span><br></code></pre></td></tr></table></figure>
<h4 id="4-2pull-rebase"><a href="#4-2pull-rebase" class="headerlink" title="4.2pull+rebase"></a>4.2<code>pull+rebase</code></h4><p><code>git pull</code>的默认行为是<code>git fetch + git merge</code></p>
<p><code>git pull --rebase</code>则是<code>git fetch + git rebase</code></p>
<h4 id="4-3-提交后补充提交"><a href="#4-3-提交后补充提交" class="headerlink" title="4.3 提交后补充提交"></a>4.3 提交后补充提交</h4><p>本地<code>commit</code>后，将新提交的，合并到上次提交中<br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 提示打开更改的文件</span><br>git commit <span class="hljs-params">--amend</span><br><br><span class="hljs-comment"># 不提示打开更改的文件</span><br>git commit <span class="hljs-params">--amend</span> <span class="hljs-params">--no-edit</span><br></code></pre></td></tr></table></figure><br>提交后对应的原日志的日志id，会发生变动。建议本地仓库未推送到远程分支时，使用此种合并提交的方式。</p>
<h4 id="4-4-去除rebase状态"><a href="#4-4-去除rebase状态" class="headerlink" title="4.4 去除rebase状态"></a>4.4 去除<code>rebase</code>状态</h4><p>（1）放弃当前<code>rebase</code>操作<br><figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">git rebase <span class="hljs-comment">--abort</span><br></code></pre></td></tr></table></figure><br>（2）继续<code>rebase</code></p>
<p>如果冲突已经解决，先<code>add</code>冲突文件，之后 <code>git rebase --continue</code><br><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">git rebase --<span class="hljs-keyword">continue</span><br></code></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 13.0以后presentViewController</title>
    <url>/2020/12/31/iOS-13-0%E4%BB%A5%E5%90%8EpresentViewController-%E4%B8%8D%E5%85%A8%E5%B1%8F%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="第一：基础的Present-View-Controller解析"><a href="#第一：基础的Present-View-Controller解析" class="headerlink" title="第一：基础的Present View Controller解析"></a>第一：基础的<code>Present View Controller</code>解析</h3><p>一、主要用途</p>
<p>弹出模态<code>ViewController</code>是<code>iOS</code>变成中很有用的一个技术，UIKit提供的一些专门用于模态显示的<code>ViewController</code>，如<code>UIImagePickerController</code>等。弹出模态<code>ViewController</code>主要使用于一下这几种情形：</p>
<ul>
<li><p>1、收集用户输入信息</p>
</li>
<li><p>2、临时呈现一些内容</p>
</li>
<li><p>3、临时改变工作模式</p>
</li>
<li><p>4、相应设备方向变化（用于针对不同方向分别是想两个ViewController的情况）</p>
</li>
<li><p>5、显示一个新的<code>view</code>层级</p>
</li>
</ul>
<p>这几种情形都会暂时中断程序正常的执行流程，主要作用是收集或者显示一些信息。</p>
<h3 id="二、几个概念和常用设置"><a href="#二、几个概念和常用设置" class="headerlink" title="二、几个概念和常用设置"></a>二、几个概念和常用设置</h3><h4 id="1、presenting-view-controllerVs-presented-view-controller"><a href="#1、presenting-view-controllerVs-presented-view-controller" class="headerlink" title="1、presenting view controllerVs presented view controller"></a>1、<code>presenting view controller</code>Vs <code>presented view controller</code></h4><p>当我们在<code>view controller A</code>中模态显示<code>view controller B</code>的时候，A就充当<code>presenting view controller</code>（弹出<code>VC</code>），而B就是<code>presented view controller</code>（被弹出<code>VC</code>）。官方文档建议这两者之间通过<code>delegate</code>实现交互，如果使用过<code>UIImagePickerController</code>从系统相册选取照片或者拍照，我们可以发现<code>imagePickerController</code>和弹出它的<code>VC</code>之间就是通过<code>UIImagePickerControllerDelegate</code>实现交互的。因此我们在实际应用用，最好也遵守这个原则，在被弹出的VC中定义<code>delegate</code>，然后在弹出<code>VC</code>中实现该代理，这样就可以比较方便的实现两者之间的交互。</p>
<h4 id="2、Modal-Presentation-Styles（弹出风格）"><a href="#2、Modal-Presentation-Styles（弹出风格）" class="headerlink" title="2、Modal Presentation Styles（弹出风格）"></a>2、<code>Modal Presentation Styles</code>（弹出风格）</h4><p>通过设置<code>presented VC</code>的<code>modalPresentationStyle</code>属性，我们可以设置弹出View Controller时的风格，有以下四种风格，其定义如下：<br><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;<br><br><span class="hljs-built_in">UIModalPresentationFullScreen</span> = <span class="hljs-number">0</span>,<br><br><span class="hljs-built_in">UIModalPresentationPageSheet</span>,<br><br><span class="hljs-built_in">UIModalPresentationFormSheet</span>,<br><br><span class="hljs-built_in">UIModalPresentationCurrentContext</span>,<br><br>&#125; <span class="hljs-built_in">UIModalPresentationStyle</span>;<br><br></code></pre></td></tr></table></figure><br><code>UIModalPresentationFullScreen</code>代表弹出<code>VC</code>时，<code>presented VC</code>充满全屏，如果弹出VC的<code>wantsFullScreenLayout</code>设置为<code>YES</code>的，则会填充到状态栏下边，否则不会填充到状态栏之下。</p>
<p><code>UIModalPresentationPageSheet</code>代表弹出是弹出VC时，presented VC的高度和当前屏幕高度相同，宽度和竖屏模式下屏幕宽度相同，剩余未覆盖区域将会变暗并阻止用户点击，这种弹出模式下，竖屏时跟UIModalPresentationFullScreen的效果一样，横屏时候两边则会留下变暗的区域。</p>
<p><code>UIModalPresentationFormSheet</code>这种模式下，presented VC的高度和宽度均会小于屏幕尺寸，presented VC居中显示，四周留下变暗区域。</p>
<p><code>UIModalPresentationCurrentContext</code>这种模式下，presented VC的弹出方式和presenting VC的父VC的方式相同。</p>
<p>这四种方式在<code>iPad上</code>面统统有效，但在<code>iPhone</code>和<code>iPod touch</code>上面系统始终已<code>UIModalPresentationFullScreen</code>模式显示presented VC。</p>
<h4 id="3、Modal-Transition-Style（弹出时的动画风格）"><a href="#3、Modal-Transition-Style（弹出时的动画风格）" class="headerlink" title="3、Modal Transition Style（弹出时的动画风格）"></a>3、<code>Modal Transition Style</code>（弹出时的动画风格）</h4><p>通过设置设置presented VC的<code>modalTransitionStyle</code>属性，我们可以设置弹出<code>presented VC</code>时场景切换动画的风格，其定义如下：<br><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;<br><br><span class="hljs-built_in">UIModalTransitionStyleCoverVertical</span> = <span class="hljs-number">0</span>,<br><br><span class="hljs-built_in">UIModalTransitionStyleFlipHorizontal</span>,<br><br><span class="hljs-built_in">UIModalTransitionStyleCrossDissolve</span>,<br><br><span class="hljs-built_in">UIModalTransitionStylePartialCurl</span>,<br><br>&#125; <span class="hljs-built_in">UIModalTransitionStyle</span>;<br></code></pre></td></tr></table></figure><br>我们可以看到有从底部滑入，水平翻转进入，交叉溶解以及翻页这四种风格可选。这四种风格在不受设备的限制，即不管是iPhone还是iPad都会根据我们指定的风格显示转场效果。</p>
<h4 id="4、Dismiss-Modal-ViewController（消失弹出的VC）"><a href="#4、Dismiss-Modal-ViewController（消失弹出的VC）" class="headerlink" title="4、Dismiss Modal ViewController（消失弹出的VC）"></a>4、<code>Dismiss Modal ViewController</code>（消失弹出的VC）</h4><p>消失<code>presented VC</code>，我们可以通过调用以下两个函数中的任何一个来完成<br><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">dismissModalViewControllerAnimated:                <span class="hljs-comment">// 将要废弃，不赞成继续使用</span><br><br>dismissViewControllerAnimated:completion:<br></code></pre></td></tr></table></figure><br>谁来调用这消失presented VC的这个方法：正确的做法是<code>“谁污染谁治理”</code>，即<code>presenting VC</code>调用上面的方法来取消<code>presented VC</code>的显示。这样做有一个好处，如果一个VC真不用户做的不同选择可能弹出不同的<code>view controller</code>，当不再需要显示被弹出的<code>view controller</code>的时候，直接调用<code>[self dismissModalViewControllerAnimated]</code>即可使之消失，而不用去关心其具体显示的哪一类view controller。当然系统在这里做了优化，当我们在presented VC里面调用上面的方法的时候，系统会自动的将这个消息传递到相应的presenting VC中，这样就可以实现不管谁弹出了自己，当不再需要的时候直接将自己消失掉的功能。在应用中具体要采用那种要看具体情况，如果presented VC需要和presenting VC有数据传递的话，建议在presenting VC实现的代理函数中dismiss弹出的view controller。</p>
<p><code>presentModalViewController</code>支持5.0，而<code>presentViewController</code>支持5.0以下</p>
<p>你可以<br><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">if</span> (SYSTEM_VERSION_LESS_THAN(<span class="hljs-string">@&quot;5.0&quot;</span>)) &#123;<br><br>[<span class="hljs-keyword">self</span> presentModalViewController:<span class="hljs-keyword">self</span>.childVC animated:<span class="hljs-literal">YES</span>];<br><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><br>[<span class="hljs-keyword">self</span> presentViewController:<span class="hljs-keyword">self</span>.childVC animated:<span class="hljs-literal">YES</span> completion:<span class="hljs-literal">nil</span>];<br><br>&#125;<br></code></pre></td></tr></table></figure><br>或直接使用<br><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[<span class="hljs-keyword">self</span> presentViewController:<span class="hljs-keyword">self</span>.childVC animated:<span class="hljs-literal">YES</span> completion:<span class="hljs-literal">nil</span>];<br></code></pre></td></tr></table></figure><br>来解决兼容性问题</p>
<h5 id="第二：高级自定义Present-View-Controller解析"><a href="#第二：高级自定义Present-View-Controller解析" class="headerlink" title="第二：高级自定义Present View Controller解析"></a>第二：高级自定义<code>Present View Controller</code>解析</h5><p>我们在使用View跳转的过程中，想使用各种各样的特效，例如：翻页、立方体等特效，我们就可以使用一下几种方法，实现自己想要的动态的效果。</p>
<p><code>presentModalViewController:animated:completion:</code>使用系统自带四种动画</p>
<p>简单的实现方式：<br><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[page2Controller setModalTransitionStyle:<span class="hljs-built_in">UIModalTransitionStyleFlipHorizontal</span>];<br><br>[<span class="hljs-keyword">self</span> presentModalViewController:myNextViewController animated:<span class="hljs-literal">YES</span>  completion:<span class="hljs-literal">nil</span>];<br></code></pre></td></tr></table></figure><br>系统支持的四种动画：<br><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;<br><br><span class="hljs-built_in">UIModalTransitionStyleCoverVertical</span>=<span class="hljs-number">0</span>, <span class="hljs-comment">//默认方式，竖向上推</span><br><br><span class="hljs-built_in">UIModalTransitionStyleFlipHorizontal</span>, <span class="hljs-comment">//水平反转</span><br><br><span class="hljs-built_in">UIModalTransitionStyleCrossDissolve</span>,<span class="hljs-comment">//隐出隐现</span><br><br><span class="hljs-built_in">UIModalTransitionStylePartialCurl</span>,<span class="hljs-comment">//部分翻页效果</span><br><br>&#125; <span class="hljs-built_in">UIModalTransitionStyle</span>;<br></code></pre></td></tr></table></figure><br><code>presentModalViewController:animated:completion:</code>不用自带的四种动画效果</p>
<p>以下是我们高级自定义的动画效果：</p>
<p>实现全翻页效果：<br><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">CATransition</span> *animation = [<span class="hljs-built_in">CATransition</span> animation];<br><br>animation.duration = <span class="hljs-number">1.0</span>;<br><br>animation.timingFunction = <span class="hljs-built_in">UIViewAnimationCurveEaseInOut</span>;<br><br>animation.type = <span class="hljs-string">@&quot;pageCurl&quot;</span>;<br><br><span class="hljs-comment">//animation.type = kCATransitionPush;</span><br><br>animation.subtype = kCATransitionFromLeft;<br><br>[<span class="hljs-keyword">self</span>.view.window.layer addAnimation:animation forKey:<span class="hljs-literal">nil</span>];<br><br>[<span class="hljs-keyword">self</span> presentModalViewController:myNextViewController animated:<span class="hljs-literal">NO</span> completion:<span class="hljs-literal">nil</span>];<br><br>常見的轉換類型（type）：<br><br>kCATransitionFade              <span class="hljs-comment">//淡出</span><br><br>kCATransitionMoveIn          <span class="hljs-comment">//覆盖原图</span><br><br>kCATransitionPush              <span class="hljs-comment">//推出</span><br><br>kCATransitionReveal          <span class="hljs-comment">//底部显出来</span><br><br>SubType:<br><br>kCATransitionFromRight<br><br>kCATransitionFromLeft    <span class="hljs-comment">// 默认值</span><br><br>kCATransitionFromTop<br><br>kCATransitionFromBottom<br><br>设置其他动画类型的方法(type):<br><br>pageCurl  向上翻一页<br><br>pageUnCurl 向下翻一页<br><br>rippleEffect 滴水效果<br><br>suckEffect 收缩效果，如一块布被抽走<br><br>cube 立方体效果<br><br>oglFlip 上下翻转效果<br></code></pre></td></tr></table></figure><br>总之，我们使用这些静态的<code>ViewController</code>过程中，实现更多的动画效果，就需要深入了解它的底层，了解更深入的IOS底层内容。</p>
<p>在<code>iOS13</code>中使用<code>presentViewController</code>的时候，页面顶部会空出一部分来，并且可以手动往下滑动关闭界面。</p>
<p>原因：<code>UIViewController</code>的一个属性modalPresentationStyle</p>
<p>在iOS13中，<code>modalPresentationStyle</code>的默认值是<code>UIModalPresentationAutomatic</code>，而在iOS12以下的版本，默认值是<code>UIModalPresentationFullScreen</code>，这就导致了在iOS13中present出来的页面没法全屏。因此加上代码：<br><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">XXXX.modalPresentationStyle = <span class="hljs-built_in">UIModalPresentationFullScreen</span>;<br></code></pre></td></tr></table></figure><br>显示正常。</p>
]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>有人又想谈恋爱，又害怕进入亲密关系？</title>
    <url>/2021/01/01/%E6%9C%89%E4%BA%BA%E5%8F%88%E6%83%B3%E8%B0%88%E6%81%8B%E7%88%B1%EF%BC%8C%E5%8F%88%E5%AE%B3%E6%80%95%E8%BF%9B%E5%85%A5%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://cdn.wallpaperhub.app/cloudcache/d/f/b/6/e/0/dfb6e0183a519d2a59b15374782639dab2d18ce9.jpg" alt=""></p>
<h4 id="1-害怕接纳感情，其实是不敢接纳不完美的自己"><a href="#1-害怕接纳感情，其实是不敢接纳不完美的自己" class="headerlink" title="1. 害怕接纳感情，其实是不敢接纳不完美的自己"></a>1. 害怕接纳感情，其实是不敢接纳不完美的自己</h4><p><strong><em>很多人都说脱单很难，其实只是内心更多的还没有想要真正脱单吧，又或者心里太敏感怕失去而不敢迈出那一步。</em></strong><br>就像我的朋友阿林，极度敏感但又害怕孤单，内心是极度渴望恋爱的，甚至让我想起《粉红女郎》里跌跌撞撞的结婚狂。<br>但她却在每次我问起感情状态的时候，总是无奈地回答，“又分手了。”<br>她很努力的想要得到甜蜜蜜的爱情，有次她苦追几个月，终于和心中的男神修成正果，却每天都在猜疑和患得患失中度过：<br>比如，他们每次出门约会之前，她都深怕自己不够完美，如果晚上有约，她中午就开始打扮自己，反而会在妆容上“用力过猛”；<br>平时和男神在一起的时候也是，采取“紧密盯人”的方法，只要对方的视线稍微从自己身上移走，她就开始猜疑他是不是移情别恋……<br>“甚至连他牵着我的手，我都会感觉惴惴不安，怕这一切会马上离我远去。”她跟我说，“我太害怕自己不够好了。”<br>这样的猜疑，也终于让对方觉得无法喘息，而主动提出结束这段感情。<br><strong><em>我也害怕那种谈恋爱的那种失控感，有些人平时理智淡漠，但是一碰感情，整个人都无法控制自己。<br>谈恋爱之前可以做一个独立自强的女生，但是恋爱之后会变成一个变成一个多疑，患得患失，没有安全感的女生。</em></strong><br>会因为对方不自信，会因为对方否认自己。<br>最后连自己都发现这样的自己并不讨人喜欢。<br>大家都说，好的爱情是两个人一起成长，一起进步。而这样对待感情，不是在成长只是在不停的消耗自己。<br>一边羡慕那些肆意爱恨的姑娘，一边又缩在自己建造的壳里，安慰自己那个更好更合适的人总会来的。<br>害怕接纳一段感情，何尝不是害怕接纳不够完美的自己呢？</p>
<h4 id="2-“恋爱恐惧症”不可怕，只是还没有遇见对的人"><a href="#2-“恋爱恐惧症”不可怕，只是还没有遇见对的人" class="headerlink" title="2. “恋爱恐惧症”不可怕，只是还没有遇见对的人"></a>2. “恋爱恐惧症”不可怕，只是还没有遇见对的人</h4><p>前几天重温热播剧《欢乐颂2》，刘涛扮演的角色安迪是一个有“恋爱恐惧症”的人。<br>别看她在职场上气场强大，一旦面临自己的亲密关系，她却一下子怂了：<br><strong><em>害怕与别人有亲密接触；<br>一旦有人试图闯入她的世界去窥探她的内心，她就下意识地和对方拉开距离；<br>在喜欢的人面前明明很在意却要假装若无其事，想要靠近却一直在远离。<br>在现实中有很多人和安迪有类似的情况，在面对亲密关系时表现出焦虑和回避的态度，心理学上称之为“恋爱恐惧”。</em></strong><br>为什么会有这种情况呢？</p>
<ul>
<li><p><strong><em>第一，可能因为选择性太多</em></strong><br>一旦和某一个人恋爱，建立亲密关系，就意味着责任，意味着不能够再观望其他的人。虽然我对你很满意，但是心里思考着会不会有更好的选择。<br>这种类型的人，是很怕进入亲密关系的。因为一但进入亲密关系，忠诚和另一半带来的压力就会制约他的本性，他必须要关上探测其他的异性的雷达，各种花花世界就都因为自己开始了一段关系而和自己说再见。<br>他会害怕失去自由，失去空间，失去自己向往的自在…..所以害怕进入一段亲密关系。</p>
</li>
<li><p><strong><em>第二，害怕失去</em></strong><br>这种人的内心是非常渴望亲密关系的，但在渴望的同时，他们又非常的担忧，因为他们非常害怕自己在亲密关系中表现不好。<br>于是很多人就会拒绝开启一段关系，很多女孩会在还没在一起的时候就想到了分手。<br>这样的人，也有同样的特质就是：都有一个伤痕的童年或者坎坷的情感经历。<br>他们内心充满着不自信，或者是因为自己在与别人相处的时候犯错了，亦或者就是在和人相处的时间长了以后，在自己还没搞清楚状态的情况下，那些本来一开始喜欢自己的人，渐渐变得不喜欢自己了。<br>总之，患有“恋爱恐惧症”的人，会拿一个透明的玻璃罩子，把自己护在里头，虽然有点鸵鸟心态，但就是沉溺于这种虚假的“安全感”里无法自拔。<br>但我想说，<code>“你之所以变成一个恋爱恐惧症的人，归根结底还是没有遇到一个正确的人。”</code></p>
</li>
</ul>
<h4 id="3-良好的亲密关系，是独立且相依的"><a href="#3-良好的亲密关系，是独立且相依的" class="headerlink" title="3. 良好的亲密关系，是独立且相依的"></a>3. 良好的亲密关系，是独立且相依的</h4><p><strong>其实，亲密关系没有你想的那么复杂。一段好的爱情，并不是两个圆相遇融合成一个分不清彼此的圆，而是两个圆仍然是两个圆，可以重叠、可以相交，也可以离开。<br>无论哪种状态，自己依旧是自己。</strong></p>
<p>前段时间，papi的婚恋观登上热搜，引起广大网友讨论。<br>简单来说，她们结婚五年双方父母没见过面，也没有喝喜酒和蜜月。<br>关于婚姻里谁养谁的话题，papi说，“他赚钱多他养你，他不会看轻你；他赚钱少你养着他，他也不会看轻自己”。<br>还有关于过年回谁家的话题，她也是很坦然的说，他们一直都是各回各家、各找各妈，不会因为这个事吵架。<br>何炅对于她的婚恋观做了一个很是中肯的评价：“俩人是独立又依赖的共同体，有独立的生活空间，但那种亲密的联系又扯不断”。<br>所以打开你的心扉，拥有一段良好的亲密关系，可以更好地帮助我们成为自己。<br>我相信每个人都有属于自己的挣扎，对方有时候也会没有足够的心理空间，来满足我们的需要。<br>但在问题面前，我们可以通过冥想练习为自己制造空间。<br>当我们在冥想中融入专注的心思，小我的喋喋不休暂时被止息，大我的平安喜悦一再被唤醒，全然的爱和向往会升起，这是冥想的真正含义。<br>冥想，会像一个贴身能量的疗愈师，随时随地，协助你看到内心的指引，释放内在不和谐能量，转化亲密关系中限制性信念，创造你的喜悦人生。<br><strong>内在的改善自然带来外在的改善，当你带着你的挑战进入亲密关系的冥想，放松且敞开时，你不仅能逐渐感受到内在的喜悦与和平，更能看到外在“问题”的改善、成长和突破。</strong><br>亲密关系其实有很多的形式，我们可以努力拥有有一个良性的关系和建立关系的能力。<br><strong>如果你焦虑了，慢下脚步来想想自己想要什么，什么对你更有意义，然后去努力。<br>你会慢慢有能力和外界给的焦虑保持合适的距离。</strong><br>人生不是一场赌博，只是一场体验，一场认定，勇敢去享受自由，去爱吧。</p>
]]></content>
      <categories>
        <category>情感</category>
      </categories>
      <tags>
        <tag>情感</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么越温柔有教养的男生越难追？</title>
    <url>/2021/05/31/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B6%8A%E6%B8%A9%E6%9F%94%E6%9C%89%E6%95%99%E5%85%BB%E7%9A%84%E7%94%B7%E7%94%9F%E8%B6%8A%E9%9A%BE%E8%BF%BD%EF%BC%9F/</url>
    <content><![CDATA[<p>林语堂说，”一个心地干净、思路清晰、没有多余情绪和妄念的人，是会带给人安全感的。因为他不伤人，也不自伤。不制造麻烦，也不麻烦别人。某种程度上来说，这是一种持戒。”</p>
<p>我感觉，那种温柔的人男生是清冽的。</p>
<p>为什么要用这个词来形容呢？</p>
<p>我感觉那种男生就是一杯茶，一杯酒。</p>
<p>酝酿许久，沉淀许久。</p>
<p>你呆在他的身边，会觉得无比的安心。</p>
<p>也许他不会什么甜言蜜语，但是当你看向他的时候，他的眼底都是你。</p>
<p>他会很细心，那种细心是不经意间流露出的，而不是套路。</p>
<p>他很暖，但有时候也会很冷。</p>
<p>但是他太温柔啦，他一定会藏起自己的孤独和悲伤，将最仅有的，温柔的光照在你的身上。</p>
<p>温柔的人是清冽的。</p>
<p>或者说，他是清醒的。</p>
<p>他或许经历过常人想不到的孤单或悲伤。</p>
<p>但是他依然坚强的存活了下来。</p>
<p>那样的经历没有让他变成极端的人，反之，他是温柔的。</p>
<p>因为他们把孤独和悲伤留给了自己，并尽力将仅存的温暖投向这个可能伤害过他们世界。</p>
<p>这样的人，怎能不温柔？</p>
<p>这样的人，谁又会不喜欢呢？</p>
<p>因为自己被伤害过，却又坚守着。</p>
<p>因为懂得，所以慈悲。</p>
<p>因为难得，所以必定难追。</p>
<p>与其说难追，不如说他们太清醒，亦或是太偏执。</p>
<p>他们有自己的底线与坚持。</p>
<p>他们知道自己适合哪样的人，知道自己喜欢怎样的人。</p>
<p>他们不是来者不拒，亦不是随遇而安的。</p>
<p>他们有清醒的认知，知道自己的要坚守的东西，以及自己要到达的目的地。</p>
<p>他们想要奔赴的山海，不是每个人都可以同行的。</p>
<p>己所不欲，勿施于人。</p>
<p>希望历经痛苦和沧桑仍然能成为一个温柔的人，用自己的方式给别人带来温暖吧。</p>
<p>想将这两句话送给在孤独或迷惘中坚持的温柔人们。</p>
<p>‘愿每个提着孤灯寻找星辰的理想主义者，都能被看见，被懂得。<br>愿每个风雪半生的灵魂，都能与一心一意的那个人，遥遥相认。’</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>情感</tag>
      </tags>
  </entry>
  <entry>
    <title>你在分手后，想念持续了多久</title>
    <url>/2021/05/31/%E4%BD%A0%E5%9C%A8%E5%88%86%E6%89%8B%E5%90%8E%EF%BC%8C%E6%83%B3%E5%BF%B5%E6%8C%81%E7%BB%AD%E4%BA%86%E5%A4%9A%E4%B9%85/</url>
    <content><![CDATA[<p>嗯，就在前天，前任又重新加了我的微信，看到他的名字，以为是自己不小心点了重新加了他为好友，重新确认了好多遍是他主动加的我。</p>
<p>然后那一刻才发现原来自己还是有点放不下啊。  </p>
<p>和他分手是在去年的10月，有时候觉得很搞笑，就在我决定真正的要投入喜欢他的时候，他居然在等着我说分手，有时候真的是很无奈啊。分手以后，无数次的幻想他会不会回头，会不会重新开始。</p>
<p>甚至在他重新加好友的那一刻我还想着会不会有也许，可是我朋友们说“是他先放弃你的呀，你又何必回头呢？”  </p>
<p>那一瞬间，我真的清醒了，是啊，何必呢。我们也不可能再有故事了不是吗？这一次，我是真的放下了。  </p>
<p>昨天看到知乎的一句话——</p>
<p>“我确实真诚地喜欢过你，想过带你去看每年故宫的初雪，阿拉斯加的海岸线，我曾愿意与你两人独占一江秋，愿意与你郡亭枕上看潮头，铺着红地毯的礼堂，暮霭沉沉的原野，我都曾愿与你共享，我想象过和你一起生活，直到白发苍苍垂垂老矣，同枕共穴，至死不休。 ” </p>
<p>可我现在也确实不喜欢你了，车站年久失修，江南的砖瓦裂了缝，当初不撞南墙不回头的热血已然冷却。</p>
<p>抱歉啦，我们就此别过吧，我的喜欢要给别的人啦。  </p>
<p>“此生勿复见，山水不相逢。”</p>
<p>再见啦，谢谢你赠予我的一场空欢喜。这一次，我不纠缠你了。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>情感</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找</title>
    <url>/2021/05/31/%E5%AF%BB%E6%89%BE/</url>
    <content><![CDATA[<p>努力想得到什么东西，<br>其实只要沉着镇 静、实事求是，<br>就可以轻易地、神不知 鬼不觉地达到目的。<br>而如果过于使劲，<br>闹得太凶，太幼稚，<br>太没有经验，<br>就哭 啊，抓啊，拉啊，<br>像一个小孩扯桌布，<br>结果却是一无所获，<br>只不过把桌上的好<br>东西都扯到地上，<br>永远也得不到了。  </p>
<p><code>卡夫卡《城堡》</code></p>
<p><code>Smile can be given to anyone. But TEARS are only for those people whom we never want to lose</code></p>
<p>——微笑可以和所有人分享，但眼泪只能和那个你不愿意失去的人分享。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>恋爱真理</title>
    <url>/2021/05/31/%E6%81%8B%E7%88%B1%E7%9C%9F%E7%90%86/</url>
    <content><![CDATA[<p>1.不联系你是真的不喜欢你，不是因为忙<br>2.一见钟情都是见色起义，日久生情都是权衡利弊<br>3.学会及时止损，三观合不来立马分开，别耗着<br>4.别看对方说什么，要看对方做什么<br>5.为自己的每一个选择买单，亏要自己吃</p>
<p>6.别指望恋爱能让你的生活更好一点<br>7.秀恩爱要慎重，要经过时间考衡<br>8.强扭的瓜不甜，强求的爱不圆满<br>9.不要指望一个人能无条件的爱你的全部坏脾气<br>10.爱的多的那一个反而没有什么话语权</p>
<p>11.旧情复燃等于重蹈覆辙<br>12.别去考验感情，经得住考验你配不上这段感情，经不住考验你会伤心<br>13.别把感情当全部，离开一个人死不了<br>14.你可能不是第一个也不是最后一个更不是他最爱的那一个<br>15.门当户对其实真的很重要</p>
<p>16.只暧昧就是说明不够喜欢你<br>17.不拖泥带水的分手会更酷一些，摇尾乞怜只会让对方看轻你<br>18.感动不是心动，千万别心软将就<br>19.别去深挖秘密，好奇心害死猫，只会给自己添堵<br>20.男人比女人更现实</p>
<p>21.多巴胺的分泌时间差不多有两年<br>22.女追男隔层纱也千万不要倒追，对方很难珍惜你<br>23.出了学校以后，不能只考虑喜不喜欢这个问题<br>24.喜欢你的原因其实也会变成分手的原因<br>25.别太作</p>
<p>26.他的礼貌妥帖温柔绅士很可能是以前的女朋友教会他的<br>27.你再爱他，只要他对你动手了，就没留恋的必要了<br>28.浪子不会为你回头，你很普通<br>29.出轨是底线问题，不要以为只会出现一次<br>30.别把任何人当成自己生活的全部</p>
<p>31.一直说可能会离开你的人是真的会离开你<br>32.如果对方太过得寸进尺，反思一下是不是自己太怂了<br>33.不要停在原地不动，不要以为找到了男朋友就万事大吉，这样感情随时可能会崩盘<br>34.没有人是傻子，你对他好他总能感觉到，一直装糊涂说明他对你没什么兴趣<br>35.再爱一个人，也要为自己留余地</p>
<p>36.不看一个人对你好的时候有多好，看他多不忍心伤害你<br>37.对女生抠门的男生一般都很自私，不一定是物质上的抠门<br>38.讨厌相同的东西比拥有共同的兴趣更重要<br>39.先爱三观、给你的感觉再去看表象<br>40.没有人有必要透过不好看的皮囊再去了解有趣的灵魂</p>
<p>41.结婚以前遇到任何挫折都是感情问题的信号，不要以为扛过婚礼就能一切太平<br>42.别太依赖一个人，会把他吓跑<br>43.抱怨对方前先看看自己，没有人可以无条件喜欢你，除了亲人<br>44.别称口舌之快，吵架就算吵赢了你会开心么？<br>45.保持好身材让自己更漂亮永远重要</p>
<p>46.对你好不代表你就是特殊的，换下一个待遇可能和你一样<br>47.当你在心里疑惑他还爱不爱你时，他就没有开始那么爱你了<br>48.心其实很难贴着心，哪怕你们成为了枕边人<br>49.哪怕曾经非常亲密也可能会反目成仇<br>50.也许你爱上的只是他带来的感觉，而不是他。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>爱情</tag>
      </tags>
  </entry>
  <entry>
    <title>我想找一个对我好的人</title>
    <url>/2021/05/31/%E6%88%91%E6%83%B3%E6%89%BE%E4%B8%80%E4%B8%AA%E5%AF%B9%E6%88%91%E5%A5%BD%E7%9A%84%E4%BA%BA/</url>
    <content><![CDATA[<p>之前看一个<strong>男生</strong>直播，高高帅帅还会打篮球，直播间突然有个人问他，想找什么样的对象。</p>
<p>我以为他会说漂亮的可爱的温柔的，结果他思考一会说“我想找一个对我好的人”。</p>
<p>瞬间被这句话戳到。之前总觉得，对喜欢的人好不是应该的吗，为什么会有这么卑微的要求。</p>
<p>后来琢磨一下，发现「对自己好」这个要求一点都不卑微，这个「好」包括无条件的喜欢，要被保护，</p>
<p>要被照顾，要能接住所有好的坏的情绪。</p>
<p>有次和前任躺在床上，抱着都快睡着了，他突然问我：宝贝，今天我妈催我找对象，</p>
<p>你猜她什么要求？我问他什么，他说“我妈要让我找一个对我好，知道心疼我的。”</p>
<p>分手后我每次想到这个场景都很想流泪。仔细想想和他恋爱那几个月，</p>
<p>好像都是他在主动，主动找我聊天，主动分享日常，主动找我见面。</p>
<p>我是喜欢他的，可却总口是心非，我好怕把热烈的爱表达出来，</p>
<p>会让他觉得这爱来的太过容易，会不被珍惜。</p>
<p>可能他在说这句话暗示我的时候，已经对这段关系失望了。</p>
<p>是我对他不够好，我浪费了他的喜欢，把他对我的好，</p>
<p>对这段感情的希望，对恋爱的美好幻想全部消磨殆尽。</p>
<p><code>不久后我说分手，他果断答应了</code>。</p>
<p>记得有人说过，嘴硬心软的人不配得到别人喜欢。</p>
<p>所以从现在开始，请珍惜珍惜你的人，放弃放弃你的人，</p>
<p><code>在意在意你的人，对对你好的人好</code>。</p>
<p>别再<code>畏首畏尾</code>，别再有所保留，有多爱就让他感受到多少爱，</p>
<p>拿着你能对一个人好的极限去对他好，也<code>不枉相爱一场</code>。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>情感</tag>
      </tags>
  </entry>
  <entry>
    <title>我觉得一个人单身太久未必就是太挑</title>
    <url>/2021/06/01/%E6%88%91%E8%A7%89%E5%BE%97%E4%B8%80%E4%B8%AA%E4%BA%BA%E5%8D%95%E8%BA%AB%E5%A4%AA%E4%B9%85%E6%9C%AA%E5%BF%85%E5%B0%B1%E6%98%AF%E5%A4%AA%E6%8C%91/</url>
    <content><![CDATA[<p>和朋友聊天时她说，我单身快一年了，身边的朋友不停的催我找男朋友，可我一直没有遇到合适的，她们就觉得是我要求太高太挑了。</p>
<p>可其实并不是这样的，我对另一半从来都没有什么要求，我只是觉得感情讲究缘分，合适的时间遇见合适的人，两个人就自然而然的在一起了。</p>
<p>如果你非要问我要找一个什么样的对象，我像考试一样列举了他的身高，体重，五官，然后呢？相处的时候还是会冒出很多很多的问题，三观啊，生活习惯啊，爱好理想啊。</p>
<p>你说，这些算是要求太高吗？其实真的不是的，这些从来都不是什么要求，就像一把锁，它只是在等适合它的钥匙打开它，其他钥匙不适合打不开，你能说是这把锁太难打开了吗？</p>
<p>单身太久的女生真的不是要求太高，她们也想谈恋爱，也想被宠坏，也想撒娇，也想做小公举，她们只是还在等那个能明白她们到底要什么的人出现。</p>
<p>为什么越来越多的女生单身了呢？</p>
<p>因为越来越多的追求者不靠谱，喜欢来的太快，去的也太快，现如今能持续追你一个月的，恐怕是少之又少了。</p>
<p>因为感情太容易分手，很多女生好不容易谈了一场恋爱，结果因为一些小事，因为一些争吵，莫名其妙就分手了，平白消耗精力和感情。</p>
<p>因为喜欢你的人根本不知道你到底要什么，现在的男生喜欢上你多数只需要一个朋友圈就够了，只要朋友圈你的自拍够美，他就能喜欢上你，可实际上，他根本不知道你喜欢什么，想要什么。</p>
<p>我想，单身越久的女生，越需要一个了解她，和她默契的人出现来爱她。</p>
<p>有很多男生会说，女生单身越久，也就越独立，越独立，也就越难追。</p>
<p>真的是这样吗？我记得之前看论坛的时候，看到有人说，千万不要去喜欢一个单身很久的女生，因为她们早就独立的可以不需要你了，她们灯泡坏了可以自己换，水管坏了可以自己修，生病了可以自己照顾自己，甚至她们都可以自己养活自己。你去喜欢一个什么都不需要你的女生，不难追才怪了。</p>
<p>我不太能接受这种说法，我觉得女生越来越独立，是因为越来越多的男生不知道如何去爱一个女生，所以导致现在的独立女性越来越多，她们单身，没有人宠，没有人爱，她们只是必须学会爱自己，宠自己。</p>
<p>你说这样的女生难追，我说，只是你自己不够用心，不够优秀。</p>
<p>你不明白，那些看上去难追的女生，心里到底想要什么，其实她们只是想要被一个男生理解，明白她们内心深处的想法，能陪她们在家里看电视剧，能陪她们逛一天的街，能和她们半夜看恐怖片，能照顾她们，陪伴她们。</p>
<p>如果你说，这些就是要求太高，那我说，一个女生如果对你没有这些要求，那么对不起，她根本就不爱你。</p>
<p>别指望用一场电影让她喜欢上你，别指望用一个520让她成为你的女朋友，别指望用一份礼物让她跟你上床。</p>
<p>爱情没有那么容易，每一个人在一起，都需要时间的考验。</p>
<p>熬不过这些考验，就别抱怨说，女生太难追了，送礼物，发红包都追不到，因为你那点付出，根本不算什么。</p>
<p>我觉得每一个单身的女生都很优秀，单身越久，越优秀，因为她们从来不愿意随便开始一段感情，她们明白宁缺毋滥这个道理，她们一直都在等那个合适的人到来。</p>
<p>这样的女生，值得你花心思，花精力去了解她，知道她喜欢吃甜还是喜欢吃辣，知道她喜欢熬夜还是喜欢早起，知道她喜欢粉红色还是喜欢黑白色。</p>
<p>如果你喜欢一个女生，千万不要觉得她很难追，试着慢慢去接近她，多点耐心，多点真诚，一点一点的感动她，慢慢的和她相处，最后你会发现，其实她真的一点都不难追，其实和她在一起真的会很幸福。</p>
<p>不要再说女生难追了，一切的难追，只是因为你根本没有认真去追。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>情感</tag>
      </tags>
  </entry>
  <entry>
    <title>我有一天开车回老家。</title>
    <url>/2021/06/03/%E6%88%91%E6%9C%89%E4%B8%80%E5%A4%A9%E5%BC%80%E8%BD%A6%E5%9B%9E%E8%80%81%E5%AE%B6%E3%80%82/</url>
    <content><![CDATA[<p>我妈坐在副驾驶上，絮絮叨叨地催我找个女朋友。我故意逗她：“那你跟我爸是当初怎么在一起的啊？”</p>
<p>她很得意：“我们那时候可时髦了，没让家长介绍，自由恋爱！”我反问道：“诶，你跟奶奶以前不是同事嘛？”</p>
<p>“对啊，办公室坐对桌，你爸他一直瞒着没告诉我，后来我跟你爸见家长了，一进家门，看到张老师笑眯眯地坐在那，我当时就懵了。”</p>
<p>“哈哈哈哈哈哈哈哈然后呢？”<br><img src="/img/20210603.jpg" alt=""></p>
<p>“有什么然后，以前一口一个张老师喊着……后来就喊妈了。还蛮不好意思的一开始。”</p>
<p>“那你跟我爸怎么认识的？”</p>
<p>“你爸那时候不是教高中历史嘛，什么都知道，特别厉害。我跟他当时被各自学校推选去参加县里演讲比赛，结果他第一，我第二，我就不服气啊，就这么认识了。”</p>
<p>“哈哈哈哈你就看上我爸学识渊博了？”</p>
<p>“哎呀，你爸那时候啊，瘦瘦高高，长得也帅，篮球打的又好。还是家里唯一的儿子，那时候县城流行自家盖楼啊，你爷爷奶奶家里又刚新盖了二层小楼。我就觉得什么都好，就一点，我自己当老师的，不太喜欢老师，当时有些犹豫。”</p>
<p>“诶，我爸不是早就转行做传媒了嘛？”</p>
<p>“对啊。有天冬天一大早，他裹着棉衣到我家门口，把我喊出来，二话不说，扔给我一个证，我一看，是辞职证明。他手里还捂着刚烤好的红薯，热气腾腾的，他掰了一半，剥好了给我，笑嘻嘻地问，说能不能拿这个证，跟你换个证啊？”</p>
<p>“……”</p>
<p>“然后就让他骗到了结婚证呗。”</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>情感</tag>
      </tags>
  </entry>
  <entry>
    <title>56条令人惊艳的小句子</title>
    <url>/2021/06/04/56%E6%9D%A1%E4%BB%A4%E4%BA%BA%E6%83%8A%E8%89%B3%E7%9A%84%E5%B0%8F%E5%8F%A5%E5%AD%90/</url>
    <content><![CDATA[<ol>
<li>我用光了所有的表情，从人群中仓皇逃走。</li>
<li>我年轻，又年老，连灵魂都无聊至极。</li>
<li>简单介绍下自己：素质教育漏网之鱼。</li>
<li>这世上，赢的，多半是薄情人。</li>
<li>你要变得足够强大，然后才有然后。</li>
<li>生活是属于每个人自己的感受，不属于任何别人的看法。</li>
<li>遇事不决，可问春风，春风不语，既随本心。</li>
<li>今日解签，宜下江南。江南好，最好是红衣。</li>
<li>理性的人适合共事，感性的人适合共处。</li>
<li>比绝望更绝望的是那些你自己都听厌了的希望。</li>
</ol>
<p><img src="/img/20210603.jpg" alt=""></p>
<ol>
<li>祝你风光，举世无双。</li>
<li>旗鼓相当，才能相处不厌。</li>
<li>生活不是这样就是那样，总之不会是你想的那样。</li>
<li>人生中充满了各种破事，但说的最多的就是没事。</li>
<li>人生难得几回醉，要喝就要喝到位。</li>
<li>不适合就是穷，没感觉就是丑。一见钟情就是好看，深思熟虑就是有钱。</li>
<li>泼出去的水我连盆都不要。</li>
<li>我心眼有些小，但是不缺。我脾气很好，但不是没有。</li>
<li>做了狗就别指望我把你当人看。</li>
<li><p>哪有什么选择恐惧症，还是不因为穷。哪有什么优柔寡断，还是不因为怂。</p>
</li>
<li><p>好的相处模式一定是靠自我的约束，而不是对方的束缚。</p>
</li>
<li>失去的总是美好的，得不到的总是牵肠挂肚。</li>
<li>突如其来的委屈，连笑都带着僵硬。</li>
<li>我不知道自己到底在执着什么，但我知道我一直都在为难自己。</li>
<li>当生活不再会有什么惊喜和感动，会发现孤单其实就是自由。</li>
<li>不走心的努力，都是在敷衍自己。</li>
<li>失望和生气怎么会一样，生气只是想被人哄，而失望是你说什么我都听不进去。</li>
<li>生活中本就充满了失望，不是所有的等待都能如愿以偿，你且笑对，不必慌张。</li>
<li>如果你向神求助，说明你相信神的能力，如果神没有帮你，说明神相信你的能力。</li>
<li><p>认准的路，就别问多远。</p>
</li>
<li><p>你别来，我就无恙，从此山水不相逢，不问旧人长与短。</p>
</li>
<li>年龄总是如期而来，忧愁总是不请自来。</li>
<li>心事是很难隐藏的，把嘴巴捂住它就会从眼睛里冒出来。</li>
<li>我和你什么关系呢，就像是上海的南京路和南京的上海路，听起来相似又亲密实际上毫无关系。</li>
<li>祝你岁月无波澜，敬我余生不悲观。</li>
<li>他若喜欢你，脾气再大都叫个性，他若不喜欢你，就算你温顺得像只猫，他都嫌你掉毛。</li>
<li>不怕沙雕多，就怕沙雕住一窝。</li>
<li>上帝是公平的，给了你丑的外表，还给你低的智商，以免让你显得不协调。</li>
<li>其实你有几个瞬间应该是喜欢我的，只是你没坚持我也没当真。</li>
<li><p>小时候我们词不达意，长大了我们言不由衷。</p>
</li>
<li><p>所有纠结做选择的人心里早就有了答案，咨询只是想得到心里内心所倾向的选择。——东野圭吾</p>
</li>
<li>人表达的永远不是他所说的内容，而是渴望被理解的心怀。</li>
<li>这一生，一条路走到黑，是无味 无谓 也无畏。</li>
<li>当完成了童年理想，童年又成了理想。</li>
<li>小时候认为流血了，就是很严重的事，不管痛不痛先哭了再说，长大以后才发现，原来流泪比流血还要疼。</li>
<li>有些人只适合好奇，不适合在一起。</li>
<li>我没有心事可以分享，我的心酸都不可告人。</li>
<li>说片面是熬夜，说实在是失眠，说实话是想你了。</li>
<li>梦短梦长俱是梦，年来年去是何年。</li>
<li><p>一见如故，便生欢喜。</p>
</li>
<li><p>先去做你应该做的事，再去做你喜欢的事。前半句让你有饭吃，后半句让你有念想。</p>
</li>
<li>一个人总是可以善待他毫不在意的人。—— 王尔德</li>
<li>年轻时，不拖累生你的人，年老时，不拖累你生的人。</li>
<li>我不知道自己到底在执着什么，但我知道 我一直都在为难自己。</li>
<li>不够真诚是危险的，太真诚则绝对是致使的。</li>
<li>你可以一杯滚水烫死我，也可以一杯冰水冷死我，但不能一杯温水耗着我。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><br>年纪越大越会明白，年少时说过的话，不管多么情真意切，<br>最后也终是流于天真，但是有什么关系，<br>不代表它们就是谎言<span class="hljs-operator">。</span>我是真心希望，如你所言，在我之后，<br>你再没有不能失去的东西<span class="hljs-operator">。</span>而我再无爱上的人，也无一人能再像你一分<span class="hljs-operator">。</span> ​​​<br><br><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>摘抄</tag>
      </tags>
  </entry>
  <entry>
    <title>狂风暴雨</title>
    <url>/2021/06/05/%E7%8B%82%E9%A3%8E%E6%9A%B4%E9%9B%A8/</url>
    <content><![CDATA[<p><img src="/img/20210605.jpg" alt=""></p>
<p>杨绛先生曾写到：</p>
<p>没人帮的时候，<br>学会了独立。<br>没人疼的时候，<br>学会了坚强。<br>累的时候，<br>一个人扛着，<br>痛的时候，<br>想办法忍着。<br>渐渐的，<br>我懂了，<br>安全感只能自己给！</p>
<p>你所期待为你遮风挡雨的那个人，<br>往往就是他给你带来狂风暴雨！ ​​​</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>摘抄</tag>
      </tags>
  </entry>
  <entry>
    <title>慢慢喜欢你，余生全是你</title>
    <url>/2021/06/06/%E6%85%A2%E6%85%A2%E5%96%9C%E6%AC%A2%E4%BD%A0%EF%BC%8C%E4%BD%99%E7%94%9F%E5%85%A8%E6%98%AF%E4%BD%A0/</url>
    <content><![CDATA[<p><img src="/img/20210606.jpg" alt=""></p>
<p>现代人的恋爱太快，看一眼顺眼就说一见钟情，三天聊得来就说喜欢，一个月玩得开心就说要一辈子，半年相处无虞就说要结婚。</p>
<p>结果往往不尽如人意。</p>
<p>朋友，你要懂得，在感情里，要慢慢来。</p>
<h5 id="01"><a href="#01" class="headerlink" title="01."></a>01.</h5><p>慢热更笃情</p>
<p>电影《怦然心动》里，儿时的朱丽对布莱斯一见钟情，她聪明热情善良，而那时的布莱斯年幼而“不解风情”。</p>
<p>一直到长大，他们在很多误会中，彼此了解，然后慢慢走近彼此的内心世界。</p>
<p>对于朱丽来说，一开始，布莱斯在她心里近乎完美，到后来，她慢慢发现这个男孩有缺点，甚至产生了“厌恶”。</p>
<p>对于布莱斯来说，一开始，他很烦朱丽，到后来慢慢地接触了解，发现这个女孩真的值得被爱，她看似普通，却有着和别的女孩不一样的魅力，即便是校花也不能比。</p>
<p>时间给出了最好的答案。</p>
<p>电影中，布莱斯的外公对朱丽说了一句话，道出了爱情里的真谛：</p>
<p>“有些人浅薄，有些人金玉其外败絮其中，但是总有一天，你会遇到一个绚丽的人，她让你觉得你以前遇到过的所有人都只是浮云。”</p>
<p>就像韩寒对《怦然心动》的解读：</p>
<p>“有人住高楼，有人在深沟，有人光万丈，有人一身锈，世人万千种，浮云莫去求，斯人若彩虹，遇上方知有。”</p>
<p>你只有慢慢地用心感受，用心喜欢，不必急于一时。</p>
<p>去了解那个很喜欢的人，或许发现很多你不知道的缺点，如果你能慢慢接受、慢慢让他为你做出一些改变，那么，这一段感情会更笃定。</p>
<p>哪有一蹴而就的深爱，不过是，<br>慢热一点，更加懂心。</p>
<h5 id="02"><a href="#02" class="headerlink" title="02."></a>02.</h5><p>慢热更长情</p>
<p>向往一种爱情：虽然慢热，却会保温，流失温度的同时，也一点点累积热量，它会一直温热，很长情。</p>
<p>“速热的人也速冻，慢热的人最长情。”</p>
<p>比起电光火石的爱情，我想我们更向往云淡风轻，慢慢悠悠的小确幸。爱情里最温馨的，莫过于平淡里的小快乐，我哄着你的小温暖，你躲在我怀里撒娇的小瞬间……</p>
<p>这发生的每一瞬间，就像电影胶片，一帧一帧，都是镜头的捕捉，因为慢慢喜欢，所以不愿错过，不愿快进。</p>
<p>很多慢热的人，不是不懂爱，不是不主动，而是心思更细腻，有些怕错付深情，也想谨慎一些，对自己和对方都更负责。</p>
<p>对于很多人来说，慢热就是想要好好爱的表现。</p>
<p>一如这句话说得这样：“慢热是因为怕辜负，因为每一次都是全情付出。”</p>
<p>若你遇到爱，愿你一生笑靥如花，伴你一世温热长情。</p>
<p>别急着结婚，也别急着许诺一生。</p>
<p>因为不愿意将就，也怕辜负你的深情，所以，我想慢慢来，确定我的心，也确定你的心。</p>
<p>哪有一步到位的深情，不过是，<br>慢热一分，期待成真。</p>
<h5 id="03"><a href="#03" class="headerlink" title="03."></a>03.</h5><p>慢热更钟情</p>
<p>作家王小波和李银河因书稿《绿毛水怪》而相识，王小波非常动情地写了一个青涩的爱情故事，李银河被这个故事深深打动，于是他们来时用书信联系，他们确定了恋爱关系。</p>
<p>可是，当他们见面后，李银河却觉得王小波长得真的不好看，而有些失望。</p>
<p>有一次，王小波喝醉了酒，给她写了一封回信，信上说：你一定可以闻得到这张纸上有很多的酒味。”</p>
<p>他絮絮叨叨说了很多，告诉银河，爱情要看重内心，不能只看外表。</p>
<p>最后，还在回信上面说：你长得也并不好看呀。</p>
<p>因为这一句幽默的话，李银河全然接受了这个灵魂有温度的男人。一直到王小波去世，李银河都一直在为他写的书，奔走宣传，王小波很多书都是他离世之后出名的。</p>
<p>喜欢一个人，通常从一点点喜欢，到很多点喜欢，从只喜欢一个型，到喜欢一个整体，这样的喜欢，更难忘记，也更深刻。</p>
<p>因为这样的喜欢，不是临时起意，而是蓄谋已久。</p>
<p>因为喜欢了好久，喜欢得深刻，所以那一份爱，无比钟情。</p>
<p>大冰写过一句话：</p>
<p>“其实世上哪儿有什么一见钟情，所谓的一见钟情，不过是你终于遇到了你那个一直想要的人而已。人海茫茫，遇之是幸，不遇是命。”</p>
<p>是的，喜欢了好久的人，不是当时的一见钟情，而是你笃定想要的人。</p>
<p>得之我幸，失之我命。所有的遇见，已经足够美好，得不到何妨，失去了何惧。</p>
<p>刘同在《谁的青春不迷茫》里，写过一句话，我很喜欢：</p>
<p>“这辈子我们需要一见钟情很多人，两情相悦一些人，然后白头偕老一个人。”</p>
<p>真正在乎一个人的时候，一如车、马、邮件都慢，一生只想爱你一个人。</p>
<p>因为时间推移，因为慢慢懂得了你，所以更笃定，那个人就是你。</p>
<p>哪里有一见钟情的良人，不过是，<br>慢热一生，钟情一人。 </p>
<h5 id="04"><a href="#04" class="headerlink" title="04."></a>04.</h5><p>慢慢喜欢，余生欢喜 “情深情浅全在真，缘深缘浅全在心。” 深情久伴，时光会变慢。 真心相爱，岁月会延长。 </p>
<p>就像莫文蔚的《慢慢喜欢你》里唱的那般： 慢慢喜欢你 慢慢的亲密 慢慢聊自己 慢慢和你走在一起 慢慢我想配合你 慢慢把我给你 慢慢喜欢你 慢慢的回忆 慢慢的陪你慢慢的老去 因为慢慢是个最好的原因 一点点的喜欢你，慢慢地贴近你，把我有的都给你，让你了解我，让我中有你，你中有我，当我们渐渐老去，我们会有很多回忆，别说时光太瘦，指缝太宽，如若喜欢，平淡也是幸福彼岸。 </p>
<p>慢慢地让感情叠加，升温，增进，不必今天看对眼，明天就得在一起，对彼此多一点了解，抓住恋爱的节奏，才能更好地进入感情。 此生惟愿， 慢慢喜欢你，余生都是你。 只要最后是你，慢一点不要紧，多晚都没关系。 </p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>摘抄</tag>
      </tags>
  </entry>
  <entry>
    <title>我觉得谈恋爱就是就像喝酒</title>
    <url>/2021/06/07/%E6%88%91%E8%A7%89%E5%BE%97%E8%B0%88%E6%81%8B%E7%88%B1%E5%B0%B1%E6%98%AF%E5%B0%B1%E5%83%8F%E5%96%9D%E9%85%92/</url>
    <content><![CDATA[<p>开始喝的时候，微醺，大家挺高兴的，后来就高兴过头了，管不了那么多，喝多了，喝嗨了，喝吐了，然后身体也喝坏了。</p>
<p><img src="/img/20210606.jpg" alt=""></p>
<p>所以，索性从一开始就不要多喝，自己有多少量自己知道的。又或者，你本来是喝啤酒的，他们是喝白酒的，根本不适合。那索性就找喝啤酒的呗。或者，喝白水喝可乐也行。喝可口可乐的和喝百事可乐的还打架呢。</p>
<p>别因为人际关系不开心了，犯不着。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>摘抄</tag>
      </tags>
  </entry>
  <entry>
    <title>你从来都不是废物</title>
    <url>/2021/06/08/%E4%BD%A0%E4%BB%8E%E6%9D%A5%E9%83%BD%E4%B8%8D%E6%98%AF%E5%BA%9F%E7%89%A9/</url>
    <content><![CDATA[<p>1.<br>她今年37岁，广告狗，刚刚结束加班，错过了末班车。<br>孩子在家发烧，打不到车，急的她原地跺脚。<br>中年了，她和年轻时候一样，觉得自己还是个废物。</p>
<p>三分钟后，一个男孩子气冲冲地把车丢到路边。<br>她看到男孩丢下的共享单车，赶忙扫码骑车回家。</p>
<p>2.<br>他今年刚刚16岁，又没考好。<br>刚刚妈妈指责了他两句，骂他废物。<br>现在他在桥边发呆。</p>
<p><img src="/img/20210611.jpg" alt=""><br>五分钟后，在他的面前会经过一辆车，溅他一身的水。<br>他会走下桥，只顾着和司机吵架。<br>忘记了刚才想要自杀的念头。</p>
<p>3.<br>他45岁，出租车司机。<br>刚和一个男孩吵完架。<br>每天起早贪黑，还赚不到钱。<br>孩子马上上大学了，想给孩子置办东西，只能熬夜跑车。<br>他骂自己是个废物。<br>现在的他在车里熟睡，再有十分钟就会因为缺氧中毒永远不能醒来。</p>
<p>三分钟后，一个醉醺醺的人将他吵醒。<br>这个乘客吐了他一车的呕吐物。<br>他永远不会知道这个乘客救了他的命。</p>
<p>4.<br>他是一个销售，陪客户喝了很多酒，产品还是没有卖出去。<br>业绩不达标，工资还是那么点，他觉得自己从没这么废物过。<br>如今的他醉醺醺的下了车，在路边的躺椅上熟睡。<br>他醒来的时候，钱包手机掉在在地上。</p>
<p>有人盯了他的东西很久，准备下手的时候，看到环卫工刚好骑车过来，于是打消了念头。<br>5.<br>他是一个环卫工，老伴有高血压。<br>儿女过得也一般，不想麻烦他们。<br>他现在努力工作，希望能给老伴攒一个新手机钱。<br>他在想，如果年轻的时候努力一点，不至于现在这么废物。</p>
<p>过了一会，他发现今天的路边垃圾比平常少了许多。<br>远处，一个到处拾矿泉水瓶的老太太的身影逐渐消失。<br>捡水瓶的老太也不知道，她帮他减轻了很多工作量。</p>
<p>6.<br>她是一个本地老太，刚刚退休。<br>很节俭，到处捡水瓶，但总被儿子说。<br>她想去国外陪儿子，但是不会英语，总学不会。<br>她很孤独。<br>“老了，废了。”这是她最常说的话。</p>
<p>路边有个猫盆。<br>小野猫每天都会跑去吃那个奶奶喂的猫粮。<br>但是它不知道，它一直在慰藉奶奶的孤独。</p>
<p>7.<br>小野猫原来的主人是个北漂。<br>它不知道什么叫废物，但是主人离开北京的时候，把它废物一样丢在了街上。</p>
<p>那个奶奶好多天没有来了，它饿得饥肠辘辘。<br>过了一会，它在路边看到了一盒饭，大快朵颐。</p>
<p>8.<br>他是个新媒体小编，最近他的文章数据越写越差。<br>今天要迟到了，买的盒饭也忘了拿，遗留在了路旁。<br>他不知道是，刚好是这个盒饭，喂饱了饥肠辘辘的小野猫。<br>他正在苦恼，也不知道自己是不是要坚持下去。<br>他感觉自己就是个废物。</p>
<p>过了一会，他写的文章下面多了一个评论：“这文笔真好。”<br>小编看到了评论，又打起了精神写作。</p>
<p>9.<br>他是个kol，俗称大V和网红。<br>刚刚看了一个不错的文章，评论了一下。<br>但这是一个每天都要诞生无数新网红的年代。<br>他看着新人冒出来，也很焦虑。<br>又怕哪天行业不景气，长时间不工作的他，可能连工作都找不到。<br>现在他卡文了，不知道写什么，觉得自己就是个废物。</p>
<p>门响了，他看到送外卖的小哥之后，<br>突发灵感，文思泉涌，写下了一篇叫做《外卖小哥图鉴》的文章，成为了全网的爆款文章。<br>外卖小哥不知道自己会成为别人文中的英雄。</p>
<p>10.<br>他是个骑手，刚来北京的时候壮志踌躇。<br>被生活薅秃了的他，总觉得自己是个废物。</p>
<p>他今天送的第30个外卖订单，已经麻木了。<br>电梯正好开着，他赶忙走了进去。<br>差一点就迟到要扣钱了。<br>他松了一口气。</p>
<p>11.<br>他们是一对情侣，正在电梯口吵架。<br>女生卡着电梯待了半天，看到骑手以后，让开了电梯，两个人又从电梯吵到楼梯间和街道，互相对骂废物。</p>
<p>这时候楼上掉下一件衣服。<br>正好砸在女生的脸上。<br>两人马上和好，一致对外，想骂却看不到楼上的人。<br>只有衣服孤零零地落在地上。</p>
<p>12.<br>那个加班的女人刚刚骑车回到家。<br>她把车放好，见到散落在地上的衣服，于是放下包，把衣服丢进了小区的衣物收纳箱。<br>而这些被丢掉的衣服，会送往遥远的贫困山区</p>
<p>后来<br>贫困山区的孩子收到了这些新衣服。<br>都是他们没有见过的牌子。<br>听说要很多钱。<br>他们不知道什么是废物，<br>他们希望走出去，眼睛里怀着希望。</p>
<p>世界是一个闭环，你从来都不是废物，你永远被这个世界需要。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>情感</tag>
      </tags>
  </entry>
  <entry>
    <title>值得收藏的句子</title>
    <url>/2021/06/08/%E5%80%BC%E5%BE%97%E6%94%B6%E8%97%8F%E7%9A%84%E5%8F%A5%E5%AD%90/</url>
    <content><![CDATA[<p>1.<br>祝你<br>时时有选择<br>路路有回转</p>
<p>2.<br>愿有人陪你颠沛流离，<br>如果没有，愿你成为自己的太阳。<br>——卢思浩</p>
<p>3.<br>未来不足惧，过往不须泣。<br>——雪莱</p>
<p>4.<br>愿你的未来纯净明朗，像你此刻的可爱目光，<br>在世间美好的命运中，愿你的命运美好欢畅。<br>——普希金</p>
<p>5.<br>愿你一切尽意，百事从欢。</p>
<p>6.<br>纵有千古，横有八荒。<br>前途似海，来日方长。<br>——梁启超</p>
<p><img src="/img/20210606.jpg" alt=""></p>
<p>7.<br>愿你以渺小启程，以伟大结尾。<br>——闵玧其</p>
<p>8.<br>执着于理想，纯粹于当下。<br>——北岛</p>
<p>9.<br>愿你遇良人，予你欢喜城，长歌暖浮生。<br>——林培源《欢喜城》</p>
<p>10.<br>愿你如愿遇到生命中的缘分，<br>不早也不晚，不急也不缓。<br>——禅小和尚</p>
<p>11.<br>愿你所有的日子，都比不上明天的光辉。<br>——博尔赫斯</p>
<p>12.<br>第一，无所畏惧。<br>第二，无所畏惧。<br>第三，还是无所畏惧。<br>——弗朗西斯 培根</p>
<p>13.<br>希君生羽翼，一化北溟鱼。<br>——李白</p>
<p>14.<br>愿所有梦见过远方的人，<br>心有惊雷，生似静湖。<br>——蔡崇达</p>
<p>15.<br>愿少年，乘风破浪，他日勿忘化雨功。<br>——汪曾祺</p>
<p>别否定自己，你特别好，特别温柔，特别值得。</p>
]]></content>
      <categories>
        <category>情感</category>
      </categories>
      <tags>
        <tag>摘抄</tag>
      </tags>
  </entry>
  <entry>
    <title>最好的爱情是什么状态</title>
    <url>/2021/06/08/%E6%9C%80%E5%A5%BD%E7%9A%84%E7%88%B1%E6%83%85%E6%98%AF%E4%BB%80%E4%B9%88%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<p>我想讲三个故事。</p>
<p><img src="/img/20210607.jpg" alt=""></p>
<p>第一个故事是我爸和我妈。刚大学毕业那会，第一个月，我发了工资。看着我爸还在用老年机，我当时看着着实有些不好受。于是偷偷地给我爸买了一个手机，拿回家以后，我爸虽然表面上骂我乱花钱，可是脸上还是看着很高兴的。他摆弄了半天，想了想，又用纸把屏幕擦干净，然后重新放进盒子里：算了，给你妈用吧。我用旧的。<br>父母让我觉得最好的爱情是：我把我最好的都留给你。</p>
<p>第二个故事，是我听闻的。男生女生出去玩，看见一家装潢很好的店铺，于是手拉手进去。<br>坐下之后，服务员拿了菜谱，俩人一看，好特么贵呀。<br>于是女生假装看手机，然后跟服务员说：不好意思，有点急事，我们先走了。<br>然后男生赶紧配合女方：是不是客户又出什么幺蛾子了，我陪你去吧。<br>俩人飞奔而出，到了小吃街的小角落，然后一人要了一碗烤冷面。<br>双方抱着烤冷面相互一笑：我还不了解你？<br>爱情没必要打肿脸充胖子，相互接受彼此，面对对方就很好。<br>其实我觉得还不够。因为这个世界毕竟还是聚少离多。</p>
<p>第三个故事，是我亲身经历的一件事。男生和女生谈恋爱的时候，正赶上男生的家里经济出了些问题。而女生，家里就比较富裕。男生为了不难堪，于是每次女生想要逛街的时候，都要想很多借口。要么是课太多了，要么就是该考试了，要么就是系里有事。其实女生也明白男生这么做的原因。<br>俩人谈恋爱谈了半年，转眼到了冬季。那个冬天特别冷，男生就那么几件衣服换来换去，都快洗破了。<br>有一天，女生跟男生显摆，我今天让我爸给我买了件男版衣服。超大款，能当裙子穿。<br>女生穿男版衣服，是一个流行趋势男生也没多想，好奇地问了问价钱，两千多。<br>男生吐吐舌头，好家伙，竟然是我两个月的生活费。<br>后来女生穿了两天就腻了，丢给了男生。男生穿上之后，刚好合适。<br>于是女生说：哎，反正我不想穿了，就给你咯。哎，衣服贵一点，能穿很多年的。过了一会女生又一脸惆怅地说：万一我们不在一起了，以后你也要好好对自己，知道没。我买的是经典款，穿很多年都不会被淘汰的。<br>男生当时就明白了，女生最开始就是买给他的。只不过碍于男生的面子，就找了个借口。<br>正如很多普通的青春故事一样，因为诸多现实原因，男生女生最后没有走到一起，他们在恋爱的第五年和平分手了。<br>而男生的那件衣服已经穿了好几年了，衣服很暖和，像女孩说的那样，还是可以穿很久。<br>有人问男生，衣服挺好看，衣品不错啊。<br>男生回答，这是ex之前买的。<br>男生的话引来一阵嘘声：你这样好渣啊。<br>男生是这样说的：我们虽然不联系了，开始有各自的人生了。但是彼此却没有刻意地删掉联系方式，也没有满怀怨气地删掉合影。你知道为什么吗？因为越刻意，越忘不掉。倒不如把她放在过去的时光里，坦然地接受未来。以后我也会正常的谈恋爱，认真地喜欢下一个人。我们不会互相憎恨，因为我们都曾经付诸真心。我们不会刻意怀念，因为我们还有彼此的人生。我不会去怀念前任，但也不会刻意地忘记她。她是我留在过去时光里的一个亲人。只是不再见面了而已。</p>
<p>所谓爱情，在一起时，我们会坦然接受对方的好与不好，会把我最好的都留给你。其实我更希望，即使我哪天离开了你，你也要更好地活下去。<br>如果能走到最后，我会好好对你好，把我最好的都给你。就像歌词里那样，清贫也好，富贵也好，都是你。<br>爱你呢，是每分每秒都要做的小事。<br>亲爱的，如果不能走到最后，也会有一个人真诚地祝福着你。你要像爱我一样，继续爱下一个人。<br>我们是亲人，只是不再见面了而已。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>情感</tag>
      </tags>
  </entry>
  <entry>
    <title>爱情最怕拿分手来威胁</title>
    <url>/2021/06/08/%E7%88%B1%E6%83%85%E6%9C%80%E6%80%95%E6%8B%BF%E5%88%86%E6%89%8B%E6%9D%A5%E5%A8%81%E8%83%81/</url>
    <content><![CDATA[<p>爱情这件事其实很怕拿分手两个字来威胁的。</p>
<p><img src="/img/20210608.jpg" alt=""></p>
<p>我们谈恋爱的时候，总是会幼稚地用无所谓的态度，来企图让爱我们的人惶恐，假装成不怕分手的样子，心里却等着对方放下姿态来哄你求你。</p>
<p>而所谓被你吃得死死的那个人，不过是因为爱你才肯示弱低头。</p>
<p>一个人总把分手挂嘴边，那说明他在这段感情里总是处在有恃无恐的位置上。</p>
<p>就像我们小时候跟父母闹离家出走一样，是因为我们知道父母一定会来找我们，所以肆无忌惮地使用这种爱的威胁。</p>
<p>可是这种爱的威胁是很可怕的啊，因为在这个世界上除了父母，没有人会天经地义的爱着你，再爱你的人也会累。</p>
<p>等到失望攒够的那天，他会头也不回的就走了，甚至不会有一丝留恋。</p>
<p>其实你不知道，每次你说出分手两个字的时候，在你看来是气话，或者是你对爱情的试探。</p>
<p>但对于对方来说，它像是刺进对方心里的一把尖利的刀，你每多说一次，他就多疼一次，直到最后伤痕累累，他再也说不出那句我爱你了。</p>
<p>这个世界上没有完全合适的两个人，所有的爱情都会有争吵，好的爱情是需要两个人的相互迁就磨合的，不要因为一个人一味地对你付出和退让，就自以为主导了这段感情。</p>
<p>没有谁是离不开谁的，当你把那个人伤的筋疲力尽狼狈不堪的时候，他说走也就真的走了。</p>
<p>有些人一旦错过也就真的不在了。</p>
]]></content>
      <categories>
        <category>情感</category>
      </categories>
      <tags>
        <tag>摘抄</tag>
      </tags>
  </entry>
  <entry>
    <title>Fluid语法</title>
    <url>/2021/06/09/Fluid%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h4 id="1-可选便签"><a href="#1-可选便签" class="headerlink" title="1. 可选便签"></a>1. 可选便签</h4><h5 id="1-1-效果1"><a href="#1-1-效果1" class="headerlink" title="1.1 效果1"></a>1.1 效果1</h5><div class="note note-success">
            <p>文字 或者 <code>markdown</code> 均可</p>
          </div>
<h5 id="1-2-效果2"><a href="#1-2-效果2" class="headerlink" title="1.2 效果2"></a>1.2 效果2</h5> <div class="note note-primary">
            <p>primary  </p>
          </div> 
<h4 id="2-html形式"><a href="#2-html形式" class="headerlink" title="2.  html形式"></a>2.  <code>html</code>形式</h4><p class="note note-primary">标签</p>


<h4 id="3-行内标签"><a href="#3-行内标签" class="headerlink" title="3. 行内标签"></a>3. 行内标签</h4><span class="label label-primary">枚举</span> <span class="label label-primary">分类</span>
<h4 id="4-勾选框"><a href="#4-勾选框" class="headerlink" title="4. 勾选框"></a>4. 勾选框</h4><div>
            <input type="checkbox" disabled >普通示例
          </div>
<div>
            <input type="checkbox" disabled checked="checked">默认选中
          </div>

            <input type="checkbox" disabled >内联示例
           后面文字不换行，后面文字不换行后面文字不换行后面文字不换行后面文字不换行后面文字不换行

文字写在后边（这样支持外联）

<input type="checkbox" disabled > 也可以只传入一个参数，文字写在后边（这样不支持外联）
文字写在后边（这样不支持外联）

#### 5. 按钮

你可以在` markdown `中加入如下的代码来使用` Button`：

1.  <a class="btn" href="url"  title="title" target="_blank">text</a>
<p>url：跳转链接<br>text：显示的文字<br>title：鼠标悬停时显示的文字（可选）</p>
<ol>
<li><a class="btn" href="url" title="title">text</a></li>
</ol>
<h5 id="5-1-示例1"><a href="#5-1-示例1" class="headerlink" title="5.1 示例1"></a>5.1 示例1</h5><a class="btn" href="https://platojobs.github.io"  title="title" target="_blank">PlatoJobs</a>
<p>或者使用 <code>HTML</code>形式：</p>
<p><a class="btn" href="https://platojobs.github.io" title="PlatoJobs">PlatoJobs</a></p>
<h4 id="6-组图"><a href="#6-组图" class="headerlink" title="6. 组图"></a>6. 组图</h4><p>如果想把多张图片按一定布局组合显示，你可以在 <code>markdown</code> 中按如下格式：<br><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://w.wallhaven.cc/full/9m/wallhaven-9m5owx.jpg" alt=""></div><div class="group-image-wrap"><img src="https://w.wallhaven.cc/full/9m/wallhaven-9m5owx.jpg" alt=""></div><div class="group-image-wrap"><img src="https://w.wallhaven.cc/full/9m/wallhaven-9m5owx.jpg" alt=""></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="https://w.wallhaven.cc/full/9m/wallhaven-9m5owx.jpg" alt=""></div><div class="group-image-wrap"><img src="https://w.wallhaven.cc/full/9m/wallhaven-9m5owx.jpg" alt=""></div></div></div></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">&#123;<span class="hljs-operator">%</span> gi total n1<span class="hljs-operator">-</span>n2<span class="hljs-operator">-</span><span class="hljs-operator">...</span> <span class="hljs-operator">%</span>&#125;<br>  <span class="hljs-operator">!</span>[](url)<br>  <span class="hljs-operator">!</span>[](url)<br>  <span class="hljs-operator">!</span>[](url)<br>  <span class="hljs-operator">!</span>[](url)<br>  <span class="hljs-operator">!</span>[](url)<br>&#123;<span class="hljs-operator">%</span> endgi <span class="hljs-operator">%</span>&#125;<br><br>total：图片总数量，对应中间包含的图片 url 数量<br>n1<span class="hljs-operator">-</span>n2<span class="hljs-operator">-</span><span class="hljs-operator">...</span>：每行的图片数量，可以省略，默认单行最多 <span class="hljs-number">3</span> 张图，求和必须相等于 total，否则按默认样式<br><br>如下图为 &#123;<span class="hljs-operator">%</span> gi <span class="hljs-number">5</span> <span class="hljs-number">3</span><span class="hljs-operator">-</span><span class="hljs-number">2</span> <span class="hljs-operator">%</span>&#125; 示例，代表共 <span class="hljs-number">5</span> 张图，第一行 <span class="hljs-number">3</span> 张图，第二行 <span class="hljs-number">2</span> 张图<span class="hljs-operator">。</span><br></code></pre></td></tr></table></figure>
<h4 id="7-LaTeX-数学公式"><a href="#7-LaTeX-数学公式" class="headerlink" title="7.LaTeX 数学公式"></a>7.<code>LaTeX</code> 数学公式</h4><script type="math/tex; mode=display">
E=mc^2</script><h4 id="8-Mermaid流程图"><a href="#8-Mermaid流程图" class="headerlink" title="8.Mermaid流程图"></a>8.<code>Mermaid</code>流程图</h4><h5 id="8-1-使用-Mermaid可以通过内置的Tag书写："><a href="#8-1-使用-Mermaid可以通过内置的Tag书写：" class="headerlink" title="8.1 使用 Mermaid可以通过内置的Tag书写："></a>8.1 使用 <code>Mermaid</code>可以通过内置的<code>Tag</code>书写：</h5>
<pre>
<code class="mermaid" >
gantt
dateFormat  YYYY-MM-DD
title Adding GANTT diagram to mermaid

section A section
Completed task            :done,    des1, 2014-01-06,2014-01-08
Active task               :active,  des2, 2014-01-09, 3d
Future task               :         des3, after des2, 5d
Future task2               :         des4, after des3, 5d
</code>
</pre>
<h5 id="8-2-也可以通过代码块书写"><a href="#8-2-也可以通过代码块书写" class="headerlink" title="8.2 也可以通过代码块书写"></a>8.2 也可以通过代码块书写</h5><pre><code class=" mermaid">classDiagram
Class01 &lt;|-- AveryLongClass : Cool
Class03 *-- Class04
Class05 o-- Class06
Class07 .. Class08
Class09 --&gt; C2 : Where am i?
Class09 --* C3
Class09 --|&gt; Class07
Class07 : equals()
Class07 : Object[] elementData
Class01 : size()
Class01 : int chimp
Class01 : int gorilla
Class08 &lt;--&gt; C2: Cool label
</code></pre>]]></content>
      <categories>
        <category>hexo主题</category>
      </categories>
      <tags>
        <tag>Fluid</tag>
      </tags>
  </entry>
  <entry>
    <title>我选择看到美好</title>
    <url>/2021/06/09/%E6%88%91%E9%80%89%E6%8B%A9%E7%9C%8B%E5%88%B0%E7%BE%8E%E5%A5%BD/</url>
    <content><![CDATA[<p>参加工作的第二年，我认识了一个当时正在上高三的女孩儿。</p>
<p>女孩儿是我学生的小表姐。通过我的学生知道我，想和我倾诉心事。我们先加了飞信，聊过几次，后来有一天，她突然提出想见面聊聊。</p>
<p>为了方便叙述，暂称她为L</p>
<p><img src="/img/20210610.jpg" alt=""></p>
<p>那是我们第一次见面，在操场。L早早坐在一个角落等着我，我到了，在她身边坐下。刚一看她，还没说话，她就哭出来了。不是抽泣，也不是默默地淌眼泪，而是嚎啕大哭。她和我说的第一句话是：“他真的不理我了。”</p>
<p>L和男朋友是高中同班同学。高一开学第一天的上学路上，L自行车的车胎扎了，慌乱之中也没想出什么办法，只能先推着车往学校走。眼看就快迟到的时候，一个穿相同校服的男孩儿停下自行车问她怎么了，她说车胎扎了。男孩儿看看表，说：“来不及了，车先锁路边儿吧，我带你去学校。”L依言将车锁好，坐上男孩儿的自行车后座。到了学校，俩人互相一问，才知道是同班同学。一个月后，L成了男孩儿的女朋友。</p>
<p>中间两年，故事很多。</p>
<p>他俩属于小情侣中比较高调的那种，因此受到老师和家长的双重重压，连校领导都多次找他们和他们的家长谈话。因为两个人学习成绩都不错，老师们爱才，生怕他们因为恋爱而影响了成绩。但两人从未向“权威”低过头。家长和老师们打压得越重，他们就靠得越紧。L说：“他说过，我就是他的命，他也是我的命，什么时候命没了，再散。”</p>
<p>高二的暑假，L和父母发生了有史以来最严重的一次冲突。爸爸和男友的父母结成“联盟”，联手毁掉了L与男友之间所有的信件、照片和礼物，还把男友刚送给她的一只三个月大的小猫扔了出去。L说：“小猫就像我和他的小孩子一样，我们俩一起带他到宠物医院体检、打疫苗，感觉就像他的爸爸妈妈。”之前，L一直说小猫是同学送的，爸爸不知道怎么突然知道了小猫是L男友送的，拎着脖子就给扔到了楼下。</p>
<p>小猫丢了，L的魂儿也丢了。这一次冲突对L造成了极大影响。高三开学后，L的成绩一路下滑，高三第一学期的期末考试，L从班里前几名，变成了全年级垫底儿。</p>
<p>就在寒假时，L的男友突然也跟她提出分开。男友说对她很失望，说她这次成绩的下滑是对他们之间所有坚持的背叛，是变相竖起了“白旗”。男友说，觉得自己一路以来所有的辛苦都付之一炬，没有被珍惜。他说：“我觉得你不再是之前我喜欢的你，我对我们的关系突然看不到希望，所以我决定分开”L苦苦哀求、挽留，无济于事。男友在最后一封信中说他已经看不到那个值得他拿出所有力量和决心为她而抵抗一切的L了。</p>
<p>那一年的高考，L毫无悬念的落榜了，她的前男友考上了一所很不错的大学。最后一次回学校，L小心翼翼地和他说话，他没理L。</p>
<p>我劝L：“再考一年吧，哪怕是为了向他证明自己，证明你一直是当年的你，就算真的有什么改变了，也不是你。”</p>
<p>L接受了我的建议。</p>
<p>复读那一年，L非常努力。我们也成了很好的朋友，我一直陪伴着她的复读路。</p>
<p>我给了她很多复习资料、有成功经验的同学的笔记、备考总结，每次大考后，我都给她一份其它学校考得很好的同学的卷子。让她看其它学校的题、看别人的答题思路，从中积攒经验。</p>
<p>第二年的高考，L考上了一所非常理想的大学，也是她上高一时曾梦想要和男友一起考入的大学。</p>
<p>我问L：“你想让他知道吗？”</p>
<p>L摇摇头：“都过去了。我现在已经不想向他证明什么了，没有意义了。当初决定拼了，确实是因为他，不想让他小看了，但是现在已经不这么想了，他怎么看不重要，我现在觉得，我努力还是为了自己。”</p>
<p>大学毕业后，L成了“毕婚族”。我参加了她的婚礼。</p>
<p>在婚礼上，我见到了L的初恋男友——</p>
<p>这场婚礼，他是新郎。</p>
<p>兜兜转转，他们还是在一起了。</p>
<p>当年L的初恋男友通过L的表妹（也就是我的学生）找到了我，说看着L萎靡不振，很着急。想破釜沉舟，用这种办法激一下L。虽然不见得好，但是也是他能想到的唯一办法，希望我能帮他。</p>
<p>我按他希望我说的话，去劝L复读。因为他说，他了解L，这样说，她一定会愿意复读的。</p>
<p>给L的资料，有我找的，但更多的是他找的。笔记、备考总结都是他的，因为L太熟悉他的字迹了，他还特意打印成电子版。L每一次大考，他都托我帮忙找一张同期的试卷，有时是一样的卷子，有时是不一样的卷子，他做一遍，拜托他的大学同学将答案抄到卷子上。我再帮忙“判”好，复印下来，转交给L。我说是别的学校某“学霸”的卷子，我帮她借来复印一份，让她看人家的题，人家的答题思路。L特别善良，每次题不一样时，她还把她的卷子也给我复印一份，让我带给“别的学校的那个同学”，说是让人家也看看他们的题。</p>
<p>L复印下来给我的卷子，L的男友都小心收好。婚礼当天，还当众拿了出来，掀起了整场婚礼的一个小高潮。</p>
<p>那天婚礼的另一个高潮是证婚环节。小两口做了一件每一对儿从中学时代一路走来的小夫妻普遍都特别爱做的事——请当年“棒打鸳鸯”的班主任老师上台证婚。</p>
<p>高中的恋爱走到最后的可能性有多大？</p>
<p>我认为，并不比其它任何形式相识、任何年纪开始的恋情走到最后的可能性小。</p>
<p>能不能走到一起，一看缘分，二看真心。和是否是高中时开始的恋爱关系不大。</p>
<p>上周，L打电话给我，告诉我她已经怀上了宝宝。狗年，她要当妈妈了。</p>
<p>昨天是情人节，今天是大年三十儿。我讲出这个结局像糖一样的故事，但愿能给看到的人心上增添一份甜润和温暖。</p>
<p>愿所有的人都快乐。愿每一个梦想，都能如愿以偿。</p>
<p>“永老无别离，万古常完聚，愿天下有情的都成了眷属”</p>
<p>前两日在一位老师的文章中看到了美剧《西部世界》中的一句话。此刻，引用于此，作为这篇回答的结尾——</p>
<p>“有人选择看到世界的丑恶，那些无秩序的混乱。我选择，看到美好”</p>
]]></content>
      <categories>
        <category>情感</category>
      </categories>
      <tags>
        <tag>职场</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/12/31/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>hexo练习</title>
    <url>/2017/11/24/hexo%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="一、别号：-quote"><a href="#一、别号：-quote" class="headerlink" title="一、别号： quote"></a>一、别号： quote</h3><blockquote><p>content</p>
<footer><strong>[author[</strong><cite>source]] [link] [source_link_title]</cite></footer></blockquote>
<blockquote><p>生活在哪里跌倒，在哪里爬起来！</p>
</blockquote>
<blockquote><p>生活在哪里跌倒，在哪里爬起来！</p>
<footer><strong>博客</strong><cite>崔盛希</cite></footer></blockquote>
<blockquote><p>NEW: DevDocs now comes with syntax highlighting. <a href="http://devdocs.io">http://devdocs.io</a></p>
<footer><strong>@CuiShegXi</strong><cite><a href="https://twitter.com/devdocs/status/356095192085962752">twitter.com/devdocs/status/356095192085962752</a></cite></footer></blockquote>
<blockquote><p>Every interaction is both precious and an opportunity to delight.</p>
<footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html">Welcome to Island Marketing</a></cite></footer></blockquote>
<h3 id="二、别名：-code"><a href="#二、别名：-code" class="headerlink" title="二、别名： code"></a>二、别名： code</h3><p>写法：<br><figure class="highlight clean"><figcaption><span>[title] [lang:language] [url] [link text]</span></figcaption><table><tr><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">code</span> snippet<br></code></pre></td></tr></table></figure><br>普通代码<br><figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-string">&#x27;Hello World!&#x27;</span>);</span><br></code></pre></td></tr></table></figure><br>指定语言的代码<br><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[rectangle setX: <span class="hljs-number">10</span> y: <span class="hljs-number">10</span> width: <span class="hljs-number">20</span> height: <span class="hljs-number">20</span>];<br></code></pre></td></tr></table></figure><br>附加说明<br><figure class="highlight cpp"><figcaption><span>Array.map</span></figcaption><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">array</span>.<span class="hljs-built_in">map</span>(callback[, thisArg])<br></code></pre></td></tr></table></figure><br>附加说明和网址<br><figure class="highlight excel"><figcaption><span>_.compact</span><a href="http://underscorejs.org/#compact">Underscore.js</a></figcaption><table><tr><td class="code"><pre><code class="hljs excel">_.compact([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-built_in">false</span>, <span class="hljs-number">2</span>, &#x27;&#x27;, <span class="hljs-number">3</span>]);<br>=&gt; [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>你的心换了锁，钥匙给了别人</title>
    <url>/2017/11/24/%E4%BD%A0%E7%9A%84%E5%BF%83%E6%8D%A2%E4%BA%86%E9%94%81%EF%BC%8C%E9%92%A5%E5%8C%99%E7%BB%99%E4%BA%86%E5%88%AB%E4%BA%BA/</url>
    <content><![CDATA[<p>雨，好像是千万支魔指，好像是千万条琴弦，弹出了千变万化的声音——题记</p>
<p>1.</p>
<p>从菲林口中得知你结婚的消息时，我没有哭，除了觉得手里的茶杯像加了一层润滑剂一般握也握不住之外，情绪波动并不大。</p>
<p>我的电话号码多年不变，短信，微信却都没有你结婚的消息。你是不想我的出现让你尴尬，还是不想你的电话让我难堪。</p>
<p>你不知道我从别人口中听到这个消息时，就像一个小丑，明明心里在滴血，却还将伤口捏成微笑的形状。</p>
<p>我从她家走出来，外面下起了银针般的细雨，淅淅沥沥的落在我的身上，很冷，生疼。</p>
<p>多年以前，你曾对我说过无数次：“我们一起去淋雨吧”</p>
<p>我总是一再推脱，什么淋雨容易感冒，生病了影响学业，大姨妈来了等等，不善言辞的我，只在拒绝你的时候，得心应手。</p>
<p>你很丧气，我们是学生，学海无涯，不知道等到何时才有机会，与我漫步雨中，成为雨巷里，丁香一样的恋人。</p>
<p>你一定想不到，多年以后，我会走入雨中，夜凉如水，灯火通明，来人如织，雨势很小。像是漫天飞落的丁香花，我置身其中，任由回忆肆意侵袭。</p>
<p>我终于无所顾忌的淋雨了，只是身边没有了你，丁香般的柔情细语，能与谁说，有谁能懂。世人不过觉得我是一时兴起的疯子罢了，却不知道我清醒着的那些年，失去了最重要的你。</p>
<p>清醒的人，是压抑自己真实欲望的傻子，疯子，才是敢于面对自己的勇士。</p>
<p>我在最好的年纪遇到了你，你是沙子，我太过用力，便流失于指缝中。</p>
<p>2.</p>
<p>与你相遇，并不美好，可以说是我循规蹈矩十几年里，乍现的一只苍蝇，烦人又无奈。</p>
<p>那时候，学校安排差生与优等生互帮互助，共同进步，这不过，就是变相扶贫。</p>
<p>我很不幸遇到了你，你不是我帮助的差生，你坐在我后排，却比他还难缠，他不过就是数学题不懂需要讲解十遍以上，英语口语说出来比西班牙语还难懂，我常常问：我是这样教的？他还会老老实实的点头，名正言顺的将罪名嫁祸给我，脸不红，心不跳，不去当演员实在可惜。</p>
<p>不过我觉得，你比他更难搞，或者你们俩是一伙儿的，他负责击垮我的心理防线，你负责让我浑身不自在。</p>
<p>我扎马尾的时候，你就在后面揪我的头发，一次揪一点儿，疼得我抓狂。我现在老是偏头痛，你罪责难逃。</p>
<p>我吃包子，你就在旁边说人肉包子的恐怖故事，还提醒我小心别吃到手指头了。直到今天我都觉得馒头比包子安全。</p>
<p>我上厕所，你就跟到门口，像诈尸一样的出来吓我，我吓得大哭，你就开心得像个疯子，好像你来学校的目的就是为了让我和你一起发疯。</p>
<p>我回宿舍，你经常会在宿舍楼下鬼哭狼嚎，各种乱七八糟的歌，乱七八糟的话层出不穷，你就是个废话制造机，每次说完还要署名是为我而来，你知道我那时候差点成为全民公敌吗？</p>
<p>你就是无处不在的苍蝇，赶都赶不走，见缝插针的给我添堵。我只祈祷扶贫工作赶紧结束，尽快脱离苦海，再也不要见到你，就天下天平了。</p>
<p>有一天，我对菲林诉苦：“林清远，就是阴魂不散”</p>
<p>菲林说：“男人如果捉弄一个女生，多半是出于喜欢”</p>
<p>我不屑的看了她一眼，喜欢？林清远这种苍蝇式的求爱方式只有苍蝇才能懂。作为人类，我没有感受到喜欢，只觉得恶心。</p>
<p>3.</p>
<p>扶贫工作结束了，可是你这只苍蝇却飞进来优等生的班里，学校颁布的进步学生黄榜上，你的大名比一般的苍蝇还醒目。一个暑假，你就基因突变了，我严重怀疑老师在阅卷的时候，打了盹儿，胡乱给了你一个分数。</p>
<p>很不幸，你还成了我的同桌，不过这次，我坚决不会理你。</p>
<p>上课的时候，你会时不时给我递张纸条儿：“怎么了，最近都不理我了”</p>
<p>课堂讨论的时候，你想尽办法跟我套近乎，我摆出一副毕加索抽象画的表情，送给你。</p>
<p>下课的时候，你会凑过来问：“你最近不开心啊，家里死人了啊？”</p>
<p>反正不管你说什么，做什么，除了干瞪眼，我不会给你任何回应，沉默是我铠甲，惹不起，我还躲不起啦！</p>
<p>我是班里少数骑电动车上学的人，表面上看上去像大户人家的小姐，其实也就是一台面临退休的小破车儿，打雷下雨的时候，还莫名其妙的罢工，一到下雨天，我就心慌。</p>
<p>越心慌，车越不懂事，一个雨天，车坏在了去学校的马路上，我穿着我爸那件加大加厚的雨衣，像是穿了件活动板房，笨重的像企鹅一样撒不开手脚。</p>
<p>上坡的时候，车子没电了，轮胎坏了，力气也耗光了，雨越下越大，步子却怎么也迈不开了。</p>
<p>突然，有一股力将车子推动了，我打算回头去看，雨衣挡住了我的视线，什么都看不见。只觉得身后这个人，力气很大，身体结实，在我最落魄的时候，帮了我，实在感激不尽。</p>
<p>到了停车棚，我脱下雨衣，才看见浑身湿透的你，脸色煞白的看着我，手里拿着一把没有打开的伞。</p>
<p>“有伞为什么不打？是不是傻？”我看着你，忍不住心疼的责备起来。</p>
<p>“一只手帮你推车，一只手推自行车，我又没有三头六臂，怎么打伞”明明理直气壮的话，却被你说得像个委屈的小媳妇儿。</p>
<p>“你会不会感冒啊？”</p>
<p>“不会，等会儿喝点姜汤就好”说着，他将伞打开，我们一起撑伞去了教室，那是第一次，我们俩没有吵架，没有嘶吼，身上的刺，好像被大雨全冲走了。</p>
<p>你说的喝姜汤，是不实际的，学校不是家里，没有姜，没有汤，也没有火。但是第二节课下课时，你居然用一次性碗端了一碗姜汤给我，热气腾腾的与你嘴里的白气融合成了一道氤氲，我头一次觉得你长得还不赖。</p>
<p>“你在哪里弄的？”我忍不住好奇</p>
<p>“学校后山，自己弄了个火”你得意的说</p>
<p>“姜，你是怎么切的”我咬住一口姜片问道，你的姜片切得太清奇了。</p>
<p>“用口咬的”</p>
<p>我当时差点没有被一口姜汤噎死，恶狠狠的盯着笑得花枝乱颤的你，胃里一阵翻滚，却分不清是恶心还是暖心。</p>
<p>4.</p>
<p>你因为私自生火被学校处分了，一贯大题小做的教导处主任，为你专门组织了一场集会，让你在国旗下检讨你的错误。</p>
<p>你的兄弟和你一样，都是不分场合的乌合之众。你一登台，他们就把你当成了超级演说家，底下掌声雷动，教导主任的那一张苦瓜一样的脸，又打了一层霜。</p>
<p>我站在底下，听着你读从百度上下载的检讨书，牛头不对马嘴的内容，这哪里是检讨，分明是单口相声啊。</p>
<p>读完之后，老师要你在国旗下面壁思过一天，太阳很大，可是我觉得你比它还耀眼。你身上的放荡不羁，与众不同，都在阳光下，熠熠生辉。</p>
<p>我躲在教室里，不止一次的朝你望去，看你的眼神变得温柔细腻，那是，爱情开始的信号。</p>
<p>不久，我们在一起了，偷偷摸摸的像是共产党初期的地下党员，每天在学校外面接头。</p>
<p>你的性情也发生了变化，不再以令我抓狂为乐，学着像别人家的男朋友，走起了暖心路线。说实在的，我对于你的再一次基因突变，心里很害怕。</p>
<p>你第一次买好了包子，牛奶放我桌上时，我掰开包子问你：“里面没有你的手指吧？”</p>
<p>你将十个手指抖得跟抽筋一样，自己又咬了一口，我才放心的吃了下去。</p>
<p>你第一次带我出去吃饭，点了两份包菜，我拿着筷子敲你的头：“谁告诉你我喜欢吃包菜”</p>
<p>“不是你自己说的吗？”你一脸无辜的扒着饭。</p>
<p>“我最讨厌这个菜了”那天，你找老板换了菜，从此以后，我们出门，你再没有点过包菜，错过一次的事情，你记得格外清楚。</p>
<p>你在宿舍下面等我，也不再鬼哭狼嚎，要是遇到我的舍友，还会故意将我搂在怀里，讨好的对人家说：“我女朋友在宿舍，麻烦你们多多关照啊”</p>
<p>我们会骑着自行车走过沿江风光带，但是你可没有人家电视剧男主角浪漫，你骑得几乎都要飞起来了，跟打了兴奋剂一样在树林边呼啸而过，我被甩下车半里地，都不知道。</p>
<p>人家是两个人吹着晚风，我们是一个人飞，一个人追。</p>
<p>我们会省钱一起去旅游，绿皮火车，都是硬座。你每次都让我坐在你的腿上，我有专属的软座，自带恒温系统，冬暖夏凉。</p>
<p>我们会一起读英语，冬天晨读是对意志力与耐寒力的双重考验。你买了几个热水袋，放在教室里，隔一阵拿一个热乎乎的给我暖手，自己从来不用，说什么皮糙肉厚，扛得住。</p>
<p>结果那个冬天，你长了一手冻疮，我心疼的一边替你擦药，一边抹眼泪。</p>
<p>我数学比你好，你一个男生居然数学不如一个女的，你也不害臊，每次我教育你的时候，你就一个一个老师的喊着，跟个马屁精一样的逗我。</p>
<p>在你面前，连生气都需要定力，不然容易笑场。</p>
<p>我们约定考同一所大学，甚至想过如果事与愿违怎么熬过漫长的异地恋。却没有想到，会在高考来临前夕，分手，而且连正式的告别都没有。</p>
<p>5.</p>
<p>那个时候，我加入了学校的读书会，每周一群志同道合的朋友，会将自己喜欢的诗词美文，摘抄下来，到学校的长廊里相互分享，这对我的作文水平的提升，帮助很大。</p>
<p>你很支持我，原本打算与我一起参加，无奈你实在缺少文艺细胞，看到一群人摇头晃脑的读上几个小时，你一度觉得他们吃多了摇头丸。</p>
<p>那个时候，我认识了沈以宁，我们俩都喜欢纳兰性德和张爱玲，每一次交流起来都有一种相见恨晚的感觉，但仅仅只限于诗词。</p>
<p>我曾私下和你提到过对沈以宁的崇拜，你颇有微词，气鼓鼓吃醋的样子，可气又可爱。</p>
<p>都说女孩子比男孩子心细，第一次恋爱的我，并没有意识到，他会成为我们感情的杀手。</p>
<p>有一次，他读到：“你总为爱你值不得值得，其实爱，就是不问值不值得”是张爱玲的句子，每一字都是她对胡兰成低到尘埃里的爱。</p>
<p>他忽然深情款款的说：“我爱你，也不问值不值得”</p>
<p>我心头一惊，被猝不及防的告白，乱了方寸，一时间连拒绝的话都卡壳了。一抬头，就看了你，出现在我的正对面，沈以宁的手，不知道什么时候落在了我的手上。我像触电一般的抽过来，你却转身就走了，连解释的机会都没给我。</p>
<p>我什么都没说，可我也什么都没有做啊，你为什么一点儿都不信任我呢，你的那份自以为是的理直气壮一度，让我在深夜痛哭了无数次。我们开始了冷战，互不理睬，明明像个无人机一样盯着对方的一举一动，偏要做出一副老死不相往来的假象。</p>
<p>直到有一天，你红着眼跑来问我：“陪我去淋一场雨吧”</p>
<p>这是冷战以后，你第一次跟我说话，我受宠若惊。原本打算立马答应了，可是耳边的雨声轰隆，电闪雷鸣，一想到明天的第三次模拟考试，这是高考前，最重要的一场模考，我不允许自己生病，我下意识的动摇了。</p>
<p>我看着课本，轻轻地摇摇头，还来不及解释几句，你就怒气冲冲的跑出了教室，我不是第一次拒绝你淋雨的邀请，你却是第一次生气。</p>
<p>那天，你一反常态，缺席了所有的课。</p>
<p>放学之后，沈以宁来接我去读书会，雨还没有停。我们俩共撑一把伞，走到学校花园，看见你一个人孤零零的坐在冰冷的石凳子上，捂着脸，哭得瑟瑟发抖。</p>
<p>我准备走过去，你却先抬起了头，一双充血的眼睛狠狠的盯着我，一触即发。</p>
<p>“我也准备了一把伞，只是你不愿意跟我走”你说完话，站起来就跑雨里去了，那一刻，我觉得你的背影都写满无助。</p>
<p>我从菲林那里得知，那天你妈妈去世了，车祸，当场死亡。</p>
<p>你跑来学校，一定是希望我能安慰你，陪在你的身边，陪你淋一场雨。不知道内情的我，居然又以学习为借口，再一次拒绝了你。</p>
<p>我不想用不知者无罪来为自己开脱，那天你一个人呆在雨里，心一定比身体更冷吧，就像妈妈躺在川流不息的马路上一样凄凉。我居然在你最需要的时候，和别人一起出现在你绝望的深谷里，每次想到这里，我的心就比上万次凌迟还要痛苦。</p>
<p>我恨死了考试，恨死了学习，恨死了自己。多年后，回忆起你，还是那个在雨里无助到绝望的眼神，目不转睛的盯着我。如果时间可以倒流，我一定陪你到雨里酣畅淋漓的淋一场，你的母亲也许还是不会回来，至少你不用孤独的面对这一切，至少你身边还有一个我。</p>
<p>从那以后，你就跟老师要求做到了最后一排，我们之间隔着无数个座位，无数个人，要再一次走近你，我需要付出更多的努力。</p>
<p>我试过很多种方法，与你和解。制造巧遇，制造话题，假装摔倒，给你写信，却都没有得到你的回应，你的心上了锁，唯一的钥匙丢在了雨里，再也找不到了。</p>
<p>高中毕业之后，我们的缘分没有断，去了同一座城市，不同的大学。你知道，我曾悄悄的去过的你的学校，校园好大，我走了一天，都没有遇到你。</p>
<p>我视力一直不好，又不喜欢戴眼镜。却总能在人群中一眼就认出你，这是在你面前才有的特异功能。那天我看遍了所有人，却找不到你的磁场，我像迷了路的小白兔，找不到回你心里的路了。</p>
<p>听菲林说，你也来过我的学校，看到我和一个男孩，在湖边散步。你一定又一次心灰意冷了吧，一定以为我移情别恋了，如果我告诉，那我表弟弟来学校看我，这一次，你会不会信我。</p>
<p>6.</p>
<p>我一个人失魂落魄的从雨幕里走到了家里，浑身湿透，淋过一场，像是对我们的爱情做了最后一次的告别，年轻时没有来得及实现的心愿，现在却为时已晚。</p>
<p>我换下衣服，打开空调，拿起柔软的毛巾擦拭着湿漉漉的头发，忽然，手机的声音响了。</p>
<p>一条简讯，你的简讯，时隔五年，联系人备注着——不敢联系的人。</p>
<p>“我不能等你了，我要结婚了”</p>
<p>我看着手机屏幕，一个一个字的数着，十几个字，我读了不下百遍，眼里的泪水，滴在屏幕上。像是新娘的钻戒一般，耀眼夺目。</p>
<p>外面的雨声越来越大，不时伴有雷声，我的心里不止一次的提醒自己要冷静，要克制。身体却要诚实得多，等我真正感受到那种撕心裂肺的痛苦时，我已经置身在滂沱大雨了，雨水像一把把尖锐刺骨的手术到，非要将你从我的身体里剔除出去才甘心。</p>
<p>我常在想，如果我们晚一点相遇，晚一点恋爱，会不会从别人的教训里学会爱一个人，陪你走到最后的会不会就是我？</p>
<p>爱情是一个偶然接着另一个偶然，我们一个误会接着另一个误会，盘根错节多次之后，剪不断，理还乱。</p>
<p>你要结婚了，新娘一定是一个愿意陪你淋雨的女子，宛若丁香。我会从菲林那里去看你结婚的视频，见证你从校服走向西装。这场婚礼除了新娘不是我，应该不会任何遗憾。</p>
<p>你的心换了锁，钥匙给了另一个女人，我祝你幸福。</p>
<p>我终于知道你为什么喜欢淋雨了，在雨里，没有人看得见，你在哭。就像现在，没人看见我的眼泪。</p>
]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>境界</title>
    <url>/2017/11/24/%E5%A2%83%E7%95%8C/</url>
    <content><![CDATA[<p>我想有一个家，家前有土，土上可种植丝瓜，丝瓜沿竿而爬，迎光开出几朵黄花，花谢结果，垒累棚上。我就坐在那土地上，看丝瓜身上一粒粒突起的青色疙瘩。</p>
<p>读罢此文，我禁不住得意起来，信步走出门口，来到丝瓜架下。</p>
<p>我家门口有土，靠着水塘边种了一棵丝瓜。丝瓜藤葱葱郁郁，沿着电线竿爬了两米多高转了弯，再顺着绳索平行向东，向前方的梓树逼去。主藤上又生长出许多细藤，相互缠绕攀爬，形成一条十几米长的绿色蛟龙。</p>
<p>蛟龙的头部，肚皮，尾部伸出很多细细的触角。有的垂下交叉着，轻轻摇曳，似乎想抓住人的头发或轻抚人的脸。有的卷成纽扣那么大的圆圈，一圈一圈蜿蜒着有十几公分长，像一根柔软的弹簧。</p>
<p>巴掌大的叶子间，擎举着一些颗粒状的花苞，有些盛开了，一朵一朵，并不簇拥，嫩黄成稀疏的星星。微风拂来，花儿傍着叶子，娇羞地颤栗，如一个刚走出闺房的女子，猛然撞上一束多情的目光。</p>
<p>我比龙应台幸运，不需要想，就拥有更多。</p>
<p>屋角转弯处还栽种了一棵扁豆，沿着山墙搭了几根棍棒。扁豆层层叠叠，垒起一幅毛茸茸的绿毯，早已覆住棍棒的沧桑。桃形的叶子密密麻麻，都将叶尖儿朝下，叶上有些浅浅的茸毛。叶子的某处，不经意就冲出一两束粉红或浅紫色豆花，沿着茎杆，挨挤着，如一串串霓虹。</p>
<p>我不敢靠得太近，有几只蜜蜂在花丛间蹶着屁股钻进钻出，冷静而匆忙。</p>
<p>与扁豆隔条马路的水塘边，放了一口大瓦缸。这些缸原来都放在屋里，或装小麦或盛米糠。现在没种小麦也没养猪，缸便废弃不用了。</p>
<p>我们将它放在水塘边，里面填满了土，都是老屋拆掉后的土坯砖敲碎的。这些土经风经雨经烟火上百年，非常肥沃。</p>
<p>缸里下了几根藕枝，此际，已经长出了十几支荷叶，脸盆那么大，如一柄柄伞，争着向上张开。</p>
<p>孩子们经常向荷叶上洒水，就像玩魔术一样，整片整片的水一落到叶上，就化作珠子，滴溜溜乱转。即使是阴天，水珠也如同裹着阳光，碰溅起晶莹，让人目眩。</p>
<p>啪啪啪的响声过后，有的叶子承受不住重量，身形一矮，一绺水趁机从最低处跌落。哗啦啦，一条白线倏忽钻进塘里，像婴儿找到母亲，激动之后，归于平静。</p>
<p>荷叶晃了几晃，立住身形，像什么都没发生。</p>
<p>我有时没事，搬张椅子坐在塘边。顶上是丝瓜藤，将天染成绿色的一长溜，起伏不定。底下是一蓬蓬荷叶，如同穿着纱裙的仙子，时不时勾头低颈，窃窃私语一番。对面是花红叶绿的扁豆，正在拼命向上爬，企图占领山头，将葱绿渲染成一幅风景。</p>
<p>抿一口茶，双眼或睁或闭，任时光在身前身后打打转，再悠悠前行。我所处的，也许正是别人梦寐以求的，我所向往的，也许正是别人所不屑的。</p>
<p>风景，哪儿都有，在每一双手中，每一双脚下，每一双注视的眼中。风景，似乎哪儿都没有，只是一直存在于我们触不到的远方，让人毕生去追逐。</p>
<p>我进入了一种境界，却又似乎时时漂浮在境界之外。</p>
]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>好想恋爱啊</title>
    <url>/2017/11/24/%E5%A5%BD%E6%83%B3%E6%81%8B%E7%88%B1%E5%95%8A/</url>
    <content><![CDATA[<p>01</p>
<p>上了大三，身边所有的小伙伴都拿出了高三的学习状态，每天早出晚归，在图书馆占有一席之地。</p>
<p>但我的舍友沈贝显然是个例外，她的日常口头禅是“我好想恋爱啊” 。</p>
<p>半个月前的校迎新晚会，作为老腊肉，沈贝还是想凑热闹，并且软硬兼施，成功忽悠我陪她一起去。</p>
<p>那天天气微凉，诺大的音乐厅里，却异常温暖。上课郁郁不得志的她，到了这里像一只飞出笼子的小鸟，活跃而躁动。</p>
<p>开场的节目是星舞堂的爵士，一群痞帅痞帅的男孩子，她的花痴本质显露无疑，在下面欢呼又呐喊，一直挥动着手中的荧光棒。</p>
<p>后面又有唱歌、小品、相声，有点搞笑却没有留下很深刻印象，我们边玩手机边看着。</p>
<p>快到结束的时候，一个身着白衬衫的男孩子，唱着赵雷的 《少年锦时》，宛如忧郁的小王子，深情款款，自动放电。</p>
<p>我担心赶上人流高峰期，拍了拍旁边的沈贝，说提前溜走吧，没想到她竟然听得格外入迷。</p>
<p>她一改开场嘻嘻哈哈的样子变得收敛恬静，呆呆地望着，一脸崇拜的神情让我对她有了新的认识。</p>
<p>歌曲结束后，她立马拉着我奔向后台，在演员区找刚刚那个小哥哥。我一脸蒙蔽。</p>
<p>她满心欢喜，却被告知来晚了，人家已经走了，她顿时像瘪气的气球，无精打采。</p>
<p>02</p>
<p>但回去之后，她依旧贼心不死，在表白墙上匿名问小哥哥的专业和班级，知道后在宿舍大喊“我找到小哥哥了！”</p>
<p>我们给她提议在教务网上查阅他们班级的课程表，她忙说对啊，立马又行动起来。</p>
<p>一天正好是我们一二节在二楼上课，他们三四节在五楼上课，她象征性的在群里问了一下有没有人和她一起去。</p>
<p>结果我们宿舍出奇的一致，群里一阵狂call， “去去去，去见见传说中的小哥哥～”“贝贝，看你会不会怂～”“等着看贝贝的套路教程～”</p>
<p>没等下课我们就收拾好书包，铃声一响，六个人火速冲上去，气势堪比要上去炸碉堡。</p>
<p>人数较多，我们采取了分散政策，两个人在楼梯口，两个人在前门，两个人在后门，做好万全之策，让小哥哥插翅难飞。</p>
<p>为了掩护，我们几个有一搭没一搭地看着手机，我无聊至极，默默观察着门口络绎不绝的人们。</p>
<p>等了很久，我看了一眼手机，还有一分钟就要上课了，我走过去看了看沈贝。</p>
<p>她在班级门口眼巴巴地张望着，视野在人群中一一扫过，看了好久好久，又转过头看看楼梯口，她失望地说了一句“应该是不来上课了，咱们回去吧。”</p>
<p>我们几个相互看看，还是一起走了。路上没有一个人说话，贝贝却突然大声说了一句“我才不会就这样放弃了呢。”</p>
<p>我们一起给她打气 “加油，贝贝一定会找到小哥哥的”。</p>
<p>03</p>
<p>从那以后，贝贝像是打了鸡血，每次有什么才艺比赛、唱歌比赛，她都积极报名，本身水平就不错的她，比赛轻松就过了。</p>
<p>参加了那么多比赛，都只为寻找那个她心心念念的小哥哥。</p>
<p>一次两次三次，终于在学校的社团联合会的晚会上，她和他相遇了。</p>
<p>为了彩排，工作人员给他们建了群聊，她愣是把群里好几十号人都加了，一一和他们说话，偏偏那个男生设置了禁止通过群聊添加，她和我们说当时她的心情都想去撞豆腐啊。</p>
<p>不过很快她就想到了方法，她和晚会负责人说感觉自己的节目太单调，不够出彩，主动提出为了晚会整体效果着想，应该合并一些歌曲类的节目。</p>
<p>听她一顿忽悠，负责人觉得挺有建设性意义，就提出在彩排时看一下效果。</p>
<p>彩排的时候，她第一个就到了，然后和每个人热情交谈，看到男生来了，就准备就绪，随时过去撩。</p>
<p>抒情类的歌曲一共就她和小哥哥的，如意算盘打得好好的，第一次合作，她就把自己的优势发挥得淋漓尽致，博得老师们的阵阵好评。</p>
<p>彩排完事，她立马和男生要了微信号，说有时间再一起练习练习，争取得个奖，男生点了点头加了她。</p>
<p>自此她的生活重心完全偏离，每天都忙着排练，我们都觉得她太辛苦了，大冬天的下课就去排练，还总没有时间吃饭。</p>
<p>可她自己却乐此不疲，因为每次小哥哥都给她送到宿舍楼下。</p>
<p>记得有一天，门禁的时候她才着急忙慌地回来，我们问她怎么了，她说排练的时候突然胃疼，男孩把他送到医院陪他输液买药，又给她送回来的。</p>
<p>我们听完告诉她不要再那么拼了，已经排练得很好了，她却说不行，一定要好好练，得奖了就去表白。</p>
<p>这样的信念支撑她又朝九晚五地练习了很久。</p>
<p>终于她的努力得到了回报，他和小哥哥的默契配合，把情歌唱得深入人心，最终得了二等奖。</p>
<p>我们在台下全程给她录了视频，她很美，他很帅。</p>
<p>04</p>
<p>上台领完奖杯之后，她就赶忙抓住小哥哥，拉着他到了后台，直接和他说“从半个月前的迎新晚会到今天，360个小时，21600秒。喜欢你，我不想掩饰，你给我个痛快话，如果不行我就，我就……还没想好，因为我觉得我还挺搭你的。”</p>
<p>说完这些话，她竟然害羞了。一个人低着头，心砰砰乱跳，她说像千万头小鹿乱撞，紧张感不亚于高考的最后报考。</p>
<p>大概过了几十秒，她见男生不说话，抬头偷偷瞄一眼，竟然看到男生不知所措地抓着头发，像个发呆的傻孩子。</p>
<p>突然她噗嗤一声笑了，男生也笑了，整个场面都充满了甜蜜。</p>
<p>男生小声说道“我这个人还真不知道怎么讨女孩子欢心，只会唱歌，现在发现唱歌还没有你好听。还是让我来喜欢你吧，小偶像。余下时间，多多切磋，还望不吝赐教。”</p>
<p>就这样，贝贝成功俘获了小哥哥，现在总在我们宿舍撒狗粮，比如她的微博名字竟然赤裸裸地写到“贝贝好像要恋爱了” ，我们看完一起抨击她，明明是 “贝贝恋爱了”，还用什么好像。</p>
<p>还记得看完晚会那天，她说 “我一定找到小哥哥！”</p>
<p>现在看来还真是，当你真心想做一件事时，上帝都会在冥冥之中助你一臂之力。</p>
<p>——END——</p>
]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>如果换了电脑，如何使用hexo更改博客</title>
    <url>/2017/11/24/%E5%A6%82%E6%9E%9C%E6%8D%A2%E4%BA%86%E7%94%B5%E8%84%91%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E6%9B%B4%E6%94%B9%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>不知道题主是不是换了新电脑，需要在新电脑上进行部署，如果是，可以参考下面的方法：<br>1、从官网Git下载git，在新电脑上安装，因为https速度慢，而且每次都要输入口令，常用的是使用ssh。使用下面方法创建：<br>（1）打开git bash，在用户主目录下运行：ssh-keygen -t rsa -C “youremail@example.com” 把其中的邮件地址换成自己的邮件地址，然后一路回车<br>（2）最后完成后，会在用户主目录下生成.ssh目录，里面有id<em>rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥，千万不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。<br>（3）登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add SSH Key」，你就应该看到已经添加的Key。<br>注意：不要在git版本库中运行ssh，然后又将它提交，这样就把密码泄露出去了。<br>2、下载Node.js，并安装<br>3、打开git bash客户端，输入 npm install hexo-cli -g，开始安装hexo<br>4、下面就将原来的文件拷贝到新电脑中，但是要注意哪些文件是必须的，哪些文件是可以删除的。<br>（1）讨论下哪些文件是必须拷贝的：首先是之前自己修改的文件，像站点配置_config.yml，theme文件夹里面的主题，以及source里面自己写的博客文件，这些肯定要拷贝的。除此之外，还有三个文件需要有，就是scaffolds文件夹（文章的模板）、package.json（说明使用哪些包）和.gitignore（限定在提交的时候哪些文件可以忽略）。其实，这三个文件不是我们修改的，所以即使丢失了，也没有关系，我们可以建立一个新的文件夹，然后在里面执行hexo init，就会生成这三个文件，我们只需要将它们拷贝过来使用即可。总结：_config.yml，theme/，source/，scaffolds/，package.json，.gitignore，是需要拷贝的。<br>（2）再讨论下哪些文件是不必拷贝的，或者说可以删除的：首先是.git文件，无论是在站点根目录下，还是主题目录下的.git文件，都可以删掉。然后是文件夹node_modules（在用npm install会重新生成），public（这个在用hexo g时会重新生成），.deploy_git文件夹（在使用hexo d时也会重新生成），db.json文件。其实上面这些文件也就是.gitignore文件里面记载的可以忽略的内容。总结：.git/，node_modules/，public/，.deploy_git/，db.json文件需要删除。<br>5、在git bash中切换目录到新拷贝的文件夹里，使用 npm install 命令，进行模块安装。很明显我们这里没用hexo init初始化，因为有的文件我们已经拷贝生成过来了，所以不必用hexo init去整体初始化，如果不慎在此时用了hexo init，则站点的配置文件_config.yml里面内容会被清空使用默认值，所以这一步一定要慎重，不要用hexo init。<br>6、安装其他的一些必要组件，如果在node_modules里面有的，就不要重复安装了：<br>（1）为了使用hexo d来部署到git上，需要安装<br>npm install hexo-deployer-git —save<br>（2）为了建立RSS订阅，需要安装<br>npm install hexo-generator-feed —save<br>（3）为了建立站点地图，需要安装<br>npm install hexo-generator-sitemap —save<br>插件安装后，有的需要对配置文件_config.yml进行配置，具体怎么配置，可以参考上面插件在github主页上的具体说明<br>7、使用hexo g，然后使用hexo d进行部署，如果都没有出错，就转移成功了！「广告时间」：如果感觉有用，不妨点下「赞」，让更多人看到。如果想转载，请注明出处，^</em>^！</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>成年人的疼痛，都是默不作声</title>
    <url>/2017/11/24/%E6%88%90%E5%B9%B4%E4%BA%BA%E7%9A%84%E7%96%BC%E7%97%9B%EF%BC%8C%E9%83%BD%E6%98%AF%E9%BB%98%E4%B8%8D%E4%BD%9C%E5%A3%B0/</url>
    <content><![CDATA[<p>01</p>
<p><img src="/img/qinglv.jpg" alt=""></p>
<p>今年3月份，一则只有10秒的“日本小哥在地铁上边哭边吃东西”的视频被大量转发，点赞评论者众多，大家都说，那种忍不住、控制不了又不敢发出声音的无声哭泣，全是满满的无助；</p>
<p>今年8月份，广东遭台风“天鸽”袭击，中山市一位54岁的男子试图阻挡大风中摇摇欲倒的小货车，却无力回天，车辆被风吹倒，男子被压车下，当场身亡。这辆车是两周前买的，现场很多人劝他算了，但他不听，非常执拗；</p>
<p>还是8月份，杭州58岁患癌男子，即使透不过气，即使疼痛难忍，为省两元钱，坚决不吸氧，因为吸氧1小时需要4元钱。</p>
<p>……</p>
<p>我们在少年时期“为赋新词强说愁”，在青年时期谈论“诗和远方”，翻遍词典，却找不到诗意美好的词汇，来定义成年人的生活状态。可能你看到的，是已成为广场舞杠把子他们，拖着腰臀同码的松弛身体，麻木于营营役役的生活。</p>
<p>但是，看了上面三则新闻，你还会认为他们“油腻”吗？是否和我一样想起一句电影台词：</p>
<p>成年人的生活里没有容易二字。</p>
<p>02</p>
<p>《过界男女》这部电影，是2014年情人节上映的。我初次看，觉得它“散”，散得没有高低起伏，没有感情纠葛，没有激烈冲突。凡具备这三个“没有”的电影，票房都惨淡，该片也没能幸免，豆瓣评分仅为5.6分。</p>
<p>评分这么低，我之所以二刷，是因为某作家的“油腻中年”论。中年人果真堕落到如此不堪境地了吗？我不由想起几年前看过的这部电影。</p>
<p>陈坤饰演的阿辉，老婆怀了二胎，为了避免大陆的超生罚款，来到香港做私人司机。在医院，他听着别的夫妻商量着生产细节，脸上麻木又平静；无法预定到床位，他几度犹豫挣扎，终于还是不自然地请求前女友帮忙；缺钱，他鼓起勇气找老板娘（刘嘉玲饰演的富家太太）预支工资……到了后来，他变卖汽车零件。</p>
<p>刘嘉玲饰演的李太，原本衣食无忧，生活无非是打麻将、做慈善、做美容，以及给在外国留学的女儿留言，突然有一天，丈夫失踪，账户冻结。她请了风水先生改房间里的摆设，穿起紫色衣服，用现金代替刷卡，到后来，她把家里值钱的东西都拿去卖掉，以支撑由奢入俭的生活。</p>
<p>整部影片就是这样，平静地讲述着某段时间的生活，没有特意地碰撞和高潮，更像是一场直播，激烈从未出现，一切都是暗地里的波涛汹涌。</p>
<p>03</p>
<p>然而，影片中的生活，却能无时无刻不让你想起“熬”这个字。</p>
<p>阿辉，这个苦男人，他永远都在默默承担：自行车倒了不扶，门被反锁了用脚踹开，妻子发脾气忍着，明知道孩子的托管阿姨在敷衍，还是得礼貌应对。</p>
<p>他厚着脸求助前女友，是已经没有其他办法了；他忐忑地找老板预支工资，是捉襟见肘了；他变卖汽车零件，是彻底走投无路了。</p>
<p>这个男人，像不像我们身边那些平凡普通的兄长、父亲？他有难处，但他能力有限，他能做的，只有安抚好家人，不让家人担心，无论在外面多辛苦多委屈，都不会表露出来，总是云淡风轻的样子。</p>
<p>李太，从富得流油到财政平平，她像是经历为了一场衰老。面对母亲的关心，她倔强地选择了隐瞒；丈夫失踪日久，她病急乱投医请来风水先生；为了开源节流，她卖掉古董和画，甚至尝试过自己开车、吃路边摊……</p>
<p>这个女人，仿佛就是平静如常的生活突然出了状况的我们。面对变故，我们强装镇定，我们笑，不想让人看出来，也不想和任何人说，偷偷地用尽办法把事情解决好；可能会六神无主，可能会茫然无措，但那只是一瞬间。</p>
<p>阿辉在“熬”，李太也在“熬”。生活就是不管我们的意志，一直推着我们向前走。我们扛着家人如同扛着全世界，会有眼泪，会有疼痛，但那都是寂静无声的。</p>
<p>04</p>
<p>谈论爱情时，我们的理想是“现世安稳，岁月静好”；谈论理想时，我们渴望“以梦为马，仗剑天涯”。谈论成年人时，我们谈论什么？</p>
<p>可能是地铁里默默无声的眼泪，也可能是人命至贱的以死相搏，还可能是人在深渊，为子女做梯子的舐犊情深。</p>
<p>身为成年人（中年人），我们为了生计、脸面、位子、房子、车子、票子不停周旋，能力卓然者，早早谋得一方天地，然而那也是多年苦心经营的结果；但多数还是普通如你我这般的平凡人，会焦虑，会在乎得失，会计较来去，如陀螺即使眩晕也不敢停歇，似蜗牛就算缓慢还是往前。</p>
<p>但，日子过着过着，可能某一天，我们就开悟了，人斗不过命，命斗不过时间。无数当年的惊涛骇浪，成了现如今的风轻云淡。再娇贵的贾宝玉会遁入空门，再厉害的如来敌不过妖精。年轻时喊着的逆流而上，现在修炼成随波逐流。</p>
<p>觥筹交错之后，夜深人静之时，我们会妥协到从容，到雅致，再到豁达。我们仍然敬畏生命，但更多的是留白，于无声中成就风景。</p>
]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>我的前世今生</title>
    <url>/2017/11/24/%E6%88%91%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
    <content><![CDATA[<p>有的事情不用当面对你说：<br>有一个人，他总是把你放在心中，<br>就像那看似平静的湖面，把高远的天空<br>映入深邃的湖底，只要有一点微光，<br>它总会第一个把你珍藏，不分昼夜。</p>
<p>许多事情你不必知道：在这个大千世界中<br>总有一个人，他从来不会忘了你的存在。<br>你的欢笑和眼泪，你的呼吸，你的想法，<br>你心脏的每一次跳动，你所有的一切，<br>都会使他激动不已。他是那么地深爱着，<br>不管春夏秋冬，不管世事变迁，不在乎<br>生命的短长，即使身边战火纷飞，随时有<br>丧命的危险，他也会把你牵挂，永不谢幕。</p>
<p>他爱你，把你当成唯一信仰，即使是上帝，<br>也必须为你让出那个至高无上的位置，<br>可是你仍然毫不知情，甚至把他排除于<br>你的心门之外。只是，最幸运的人儿啊，<br>你永远也不会知道，这个世界上总有<br>一个人，他在偷偷地爱你，把你当成<br>自己的生命来爱，他随时准备为你付出<br>他的一切，却不奢求你会知道这一点。</p>
<p>他爱你，忠于你的全部，包括灵魂，<br>无论是在过去，现在，还是未来。<br>当人类毁灭，地球消失，宇宙陷入<br>永恒无边的黑暗，他的爱将一直存在。</p>
]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>父爱无边</title>
    <url>/2017/11/24/%E7%88%B6%E7%88%B1%E6%97%A0%E8%BE%B9/</url>
    <content><![CDATA[<p>My father was a self-taught mandolin player. He was one of the best string instrument players in our town. He could not read music, but if he heard a tune a few times, he could play it. When he was younger, he was a member of a small country music band. They would play at local dances and on a few occasions would play for the local radio station. He often told us how he had auditioned and earned a position in a band that featured Patsy Cline as their lead singer. He told the family that after he was hired he never went back. Dad was a very religious man. He stated that there was a lot of drinking and cursing the day of his audition and he did not want to be around that type of environment.</p>
<p>　　Occasionally, Dad would get out his mandolin and play for the family. We three children: Trisha, Monte and I, George Jr., would often sing along. Songs such as the Tennessee Waltz, Harbor Lights and around Christmas time, the well-known rendition of Silver Bells. “Silver Bells, Silver Bells, its Christmas time in the city” would ring throughout the house. One of Dad’s favorite hymns was “The Old Rugged Cross”. We learned the words to the hymn when we were very young, and would sing it with Dad when he would play and sing. Another song that was often shared in our house was a song that accompanied the Walt Disney series: Davey Crockett. Dad only had to hear the song twice before he learned it well enough to play it. “Davey, Davey Crockett, King of the Wild Frontier” was a favorite song for the family. He knew we enjoyed the song and the program and would often get out the mandolin after the program was over. I could never get over how he could play the songs so well after only hearing them a few times. I loved to sing, but I never learned how to play the mandolin. This is something I regret to this day.<br>　　<br>　　Dad loved to play the mandolin for his family he knew we enjoyed singing, and hearing him play. He was like that. If he could give pleasure to others, he would, especially his family. He was always there, sacrificing his time and efforts to see that his family had enough in their life. I had to mature into a man and have children of my own before I realized how much he had sacrificed.<br>　　<br>　　I joined the United States Air Force in January of 1962. Whenever I would come home on leave, I would ask Dad to play the mandolin. Nobody played the mandolin like my father. He could touch your soul with the tones that came out of that old mandolin. He seemed to shine when he was playing. You could see his pride in his ability to play so well for his family.<br>　　<br>　　When Dad was younger, he worked for his father on the farm. His father was a farmer and sharecropped a farm for the man who owned the property. In 1950, our family moved from the farm. Dad had gained employment at the local limestone quarry. When the quarry closed in August of 1957, he had to seek other employment. He worked for Owens Yacht Company in Dundalk, Maryland and for Todd Steel in Point of Rocks, Maryland. While working at Todd Steel, he was involved in an accident. His job was to roll angle iron onto a conveyor so that the welders farther up the production line would have it to complete their job. On this particular day Dad got the third index finger of his left hand mashed between two pieces of steel. The doctor who operated on the finger could not save it, and Dad ended up having the tip of the finger amputated. He didn’t lose enough of the finger where it would stop him picking up anything, but it did impact his ability to play the mandolin.<br>　　<br>　　After the accident, Dad was reluctant to play the mandolin. He felt that he could not play as well as he had before the accident. When I came home on leave and asked him to play he would make excuses for why he couldn’t play. Eventually, we would wear him down and he would say “Okay, but remember, I can’t hold down on the strings the way I used to” or “Since the accident to this finger I can’t play as good”. For the family it didn’t make any difference that Dad couldn’t play as well. We were just glad that he would play. When he played the old mandolin it would carry us back to a cheerful, happier time in our lives. “Davey, Davey Crockett, King of the Wild Frontier”, would again be heard in the little town of Bakerton, West Virginia.<br>　　<br>　　In August of 1993 my father was diagnosed with inoperable lung cancer. He chose not to receive chemotherapy treatments so that he could live out the rest of his life in dignity. About a week before his death, we asked Dad if he would play the mandolin for us. He made excuses but said “okay”. He knew it would probably be the last time he would play for us. He tuned up the old mandolin and played a few notes. When I looked around, there was not a dry eye in the family. We saw before us a quiet humble man with an inner strength that comes from knowing God, and living with him in one’s life. Dad would never play the mandolin for us again. We felt at the time that he wouldn’t have enough strength to play, and that makes the memory of that day even stronger. Dad was doing something he had done all his life, giving. As sick as he was, he was still pleasing others. Dad sure could play that Mandolin!</p>
]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title>送走女闺蜜，再来娶你</title>
    <url>/2017/11/24/%E9%80%81%E8%B5%B0%E5%A5%B3%E9%97%BA%E8%9C%9C%EF%BC%8C%E5%86%8D%E6%9D%A5%E5%A8%B6%E4%BD%A0/</url>
    <content><![CDATA[<p>01</p>
<p><img src="/img/nvgq.png" alt=""></p>
<p>天蓝蓝的，云卷云舒，海蓝蓝的，浪潮涌动。冲浪的人们，时而俯冲，时而鱼跃。沙滩上人潮拥挤，五颜六色的帐篷下面，或甜言蜜语，或酒入愁肠。</p>
<p>筱雅一个急刹车，打开车门，捂着鼻子朝一侧人烟稀少的海滩飞奔而去。</p>
<p>筱雅边跑边扔下鞋子，一屁股坐在沙滩上，双手不停地刨着沙滩，沙坑越来越大。筱雅躺在沙坑里，一捧一捧地用沙子把自己埋葬，没过了细长的小腿，没过了白皙的大腿，没过了蕾丝的短裙，没过了起伏的胸脯，没过了脖子。突然，筱雅又爬了起来，仰望着天空，用手捧着嘴，大喊一声。</p>
<p>“杨扬，你就是一个王八蛋，为什么要欺骗我！”</p>
<p>筱雅发疯似的朝海滩扑了下去，似乎在埋葬自己身体的一刹那，突然觉得想死真的很难，泪水和海水交融在一起。</p>
<p>晴雯和小洁从车里跟了出来，一路跟随着躲在远处。晴雯想要跑过去安慰一下筱雅，被小洁拉住了。</p>
<p>“随她去吧，这种事情，只有喊出来，哭过以后，心里才会好受点”</p>
<p>杨扬从订婚宴上突然失踪，让筱雅不能接受，她不敢相信自己深爱的男人竟然会背叛她。小洁大概知道一些情况，只是不能确定，所以显得比较冷静。有些事情，不能操之过急，需要时间来澄清的。</p>
<p>02</p>
<p>星期一早上，筱雅急匆匆起床，洗漱完毕，抢了弟弟手里的一块面包，和妈妈打了个招呼，开车上班去了。</p>
<p>筱雅昨晚和老同学聊天聊的太晚了，在等红绿灯时迷迷糊糊，后面的车子一阵疯狂地鸣喇叭催促，一路上弄得蹭车的小洁心惊胆战。</p>
<p>筱雅的公司位于市中心地标建筑锦绣国际大厦的十八层，大楼是一栋智能科技创新创业孵化基地，也是十几家大公司的办公总部。</p>
<p>刚到一楼大厅，筱雅妈妈打电话叮嘱筱雅给爸爸订个生日蛋糕，虽说昨天亲朋好友在酒店为爸爸提前过了生日，但是今天还得在家里简单热闹一下。忽然，筱雅听到身后一位男生模样的声音。</p>
<p>“靓妹，你好像有东西掉地下了”</p>
<p>男生一边小声叫，一边用背包半遮半掩，好像生怕其他人看到地下的东西，表情有些尴尬。</p>
<p>筱雅扭头一望，哇，这么帅，心里一阵窃喜，这帅哥要是在我们公司多好喔。</p>
<p>小洁看到地下好像是一包护垫，应该是筱雅掏手机带出来的，于是用手碰了碰筱雅。筱雅羞得脸上绯红，迅速蹲下腰捡了起来。</p>
<p>03</p>
<p>离周一例会还有十几分钟，筱雅很快上传和打印好了上周财务报表，并抄送给了公司高管团队。</p>
<p>会议室里出奇的静，大家低头各自玩着手机，谁也不说话。筱雅走了进去，除了董事长的座位，董事长前方左右两侧各剩余一个座位，再没得选，筱雅随意坐了右侧一个位置。</p>
<p>正常周会，都是公司中高层干部，没有座次排名。董事长开会总是喜欢提点小问题，所以没有人坐在前面，能躲多远就躲多远。</p>
<p>筱雅如坐针毡，不该睡这么晚，更来这么迟。突然全场安静下来，董事长到了，身后跟着一位帅气的年轻人。</p>
<p>哇，这不是刚刚电梯口碰到的吗，这世界咋这么小？筱雅惊讶得差点叫出了声音，手机滑落在会议桌上，全场哑然。</p>
<p>平时的会议，都是董事长一言堂，但从现在开始不行了。公司实行了股改，会议室坐着的也有不少小股东。如果顺利，再过半年就可以申请上市了。</p>
<p>董事长首先介绍了年轻人身份，杨扬，金融硕士，上市企业工作经历，最重要的一条，有证券公司背景，杨扬担任集团公司财务总监一职，是筱雅的直接上司。</p>
<p>会议一个小时后结束，各个部门还得组织部门工作会议，大家各自散去。</p>
<p>筱雅敲了敲门，小心推开，问了声杨总早上好，竟有些脸红。这是筱雅调到财务部两年内的第三任财务总监，筱雅不知道杨扬到底能坚持多久，又将以何种方式出局。</p>
<p>杨扬身高一米八以上，白色衬衣里隐约勾勒出几块结实的胸肌，筱雅既羡慕又紧张。杨扬也没想到竟会和筱雅在一个公司上班，脑子里还浮现出电梯口的一幕。筱雅弯腰的一刹那，春光乍泄，浅蓝色的深V里，粉嫩的秀乳，一个吊坠从中滑落出来。</p>
<p>04</p>
<p>窗外楼盘的霓虹灯七彩变幻，杨扬躺在沙发上，一会儿浏览着财务群里的各种工作信息，一会儿又从群里打开筱雅的朋友圈，筱雅的朋友圈也只有一些工作小结，偶尔有些公司聚会照，也只露张侧脸，难免有些失望。</p>
<p>杨扬来公司快半个月，除了工作例会，还没有单独找筱雅谈过话，更没有近距离审视过，却有一种莫名的感觉。</p>
<p>自从男友毕业去澳大利亚以后，筱雅从职场小白一路爬升到了财务主管，几乎没有谈过恋爱，公司各部门也不乏追求者，筱雅也不为所动，可是对杨扬确有一种特别的好感。</p>
<p>筱雅一遍又一遍打开工作群，猛戳了一下添加到通讯录，指头对准“发送”又退了回去。突然间，一条好友接受请求弹出来，“云飞扬”，筱雅欣喜若狂，瞬间接受了。</p>
<p>随后，筱雅给了杨扬另一个生活朋友圈的微信号，并发过去两杯咖啡表情，杨扬@筱雅两朵玫瑰花。</p>
<p>05</p>
<p>筱雅和杨扬的恋情升温，还得从公司元旦文艺汇演开始。两人代表财务部合唱了一首杨坤的《一辈子朋友》，引得台下一阵尖叫声。</p>
<p>杨扬的工作有了筱雅默默的支持，不到三个月，各项工作取得了不俗的成绩，为公司股改上市取得了突破性进展。公司上上下下无不投以羡慕的眼光。</p>
<p>筱雅的父母都是本地人，虽然杨扬是外来户口，对杨扬也是丈母娘看女婿，越看越喜欢。筱雅今年二十八岁了，着实把妈妈急的到处托人相亲。</p>
<p>06</p>
<p>订婚仪式在一个秋天的周末。</p>
<p>筱雅的亲朋好友、杨扬的家人和同事悉数到场。酒店内外张灯结彩，一派喜气洋洋。</p>
<p>订婚宴由筱雅闺蜜及公司HR小洁主持，公司董事长作为特邀嘉宾也坐到了贵宾席。</p>
<p>突然，杨扬接到了一个电话，看了微信后神色异常紧张，跟大家鞠了个躬，说了声对不起，驱车而去。</p>
<p>杨扬来不及跟筱雅解释，他要驱车一百多公里见他的女闺蜜童欣最后一面。杨扬必须满足曾经的女闺蜜，一个白血病患者临终前最后的愿望。他知道这样做伤害了筱雅，可是时间根本来不及容他考虑。</p>
]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>小说</tag>
      </tags>
  </entry>
  <entry>
    <title>缘分这个东西真的很难琢磨</title>
    <url>/2021/06/07/%E7%BC%98%E5%88%86%E8%BF%99%E4%B8%AA%E4%B8%9C%E8%A5%BF%E7%9C%9F%E7%9A%84%E5%BE%88%E9%9A%BE%E7%90%A2%E7%A3%A8/</url>
    <content><![CDATA[<p>运气好的话，就是天长地久，要差那么一点，就是爱而不得，或缘尽则散。而大部分人的缘分，似乎都是后两者。</p>
<p>它能让两个原本陌生的人相遇，并互生好感，却又在中间设置重重障碍，告诉你们只能止步于此。就算是知晓彼此心意，也不得不将情感压抑在心里，克制住冲动和欲望。说好听点儿，是「友达以上，恋人未满」。</p>
<p><img src="/img/20210603.jpg" alt=""></p>
<p>又或者是能顺利成为一对相爱的恋人，让彼此沉浸在甜蜜之中，享受所有来自于恋爱的幸福感。可正当你以为能永远在一起的时候，缘分又偏偏不随你意，非要往反方向走，让原本亲密的关系倒退回最初的陌生状态，甚至连再次见面的机会都不给。过往种种回忆，都像是做了场梦，关于那个人的一切，也好像不曾存在过一样，消失得干干净净。</p>
<p>虽然知道人与人之间的关系复杂又微妙，聚散离合也是常态，但一想到我们只能止步于此，那些遗憾和无奈，终究是心头的意难平。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>摘抄</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C概述</title>
    <url>/2011/11/10/Objective-C%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>Object-C</code> 通常写作 Objective-C 或者 Obj-C 或 <code>OC</code>，是根据C语言所衍生出来的语言，继承了C语言的特性，是扩充 C 语言的面向对象编程语言。<br><code>Object-C</code> 是一种面向对象的语言。而 C 语言是面向过程的语言。<br><code>Object-C</code> 是 MAC OSX 和 iOS 开发的基础语言。</p>
<h5 id="优点及缺点"><a href="#优点及缺点" class="headerlink" title="优点及缺点"></a>优点及缺点</h5><p><code>Object-C</code></p>
<ul>
<li>是非常“实际”的语言。它使用一个用C写成，很小的运行库，OC写成的程序通常不会比其原始码大很多。</li>
<li><code>Objective-C</code> 的最初版本并不支持垃圾回收。</li>
<li><code>Objective-C</code> 不包括命名空间机制(namespace mechanism)。</li>
<li>虽然 <code>Objective-C</code> 是C的母集，但它也不视C的基本型别为第一级的对象。</li>
<li>和C++不同，<code>Objective-C</code> 不支持运算子重载（它不支持 ad-hoc 多型）。</li>
<li><code>Object-C</code> 仅支持单一父类继承，不支持多重继承。</li>
</ul>
<h5 id="和C-的比较"><a href="#和C-的比较" class="headerlink" title="和C++的比较"></a>和C++的比较</h5><blockquote>
<p>目前只有Apple使用 Objective-C 作为其支持的语言。</p>
</blockquote>
<h5 id="与C-的不同之处有："><a href="#与C-的不同之处有：" class="headerlink" title="与C++的不同之处有："></a>与C++的不同之处有：</h5><ul>
<li>O-C中所有的类都必须直接或间接继承自 NSObject;</li>
<li>O-C中所有对象都是指针的形式;</li>
<li>O-C用self代替this;</li>
<li>O-C使用id代替void;</li>
<li>O-C使用nil表示NULL;</li>
<li>O-C只支持单继承;</li>
<li>O-C使用YES/NO表示TRUE/FALSE;</li>
<li>O-C使用#import代替#include;</li>
<li>O-C中用消息表示类的方法，并采用[aInstance method:argv]调用形式;</li>
<li>O-C支持反射机制;</li>
<li>O-C支持Dynamic Typing, Dynamic Binding和Dynamic Loading.</li>
</ul>
<h5 id="与C-的相同之处有："><a href="#与C-的相同之处有：" class="headerlink" title="与C++的相同之处有："></a>与C++的相同之处有：</h5><ul>
<li>与C共享的部分一致;<br>可以使用<code>assert(BOOL</code>), 一般用<code>NSCParameterAssert(BOOL)</code>代替。</li>
</ul>
<h5 id="O-C中的命名前缀说明："><a href="#O-C中的命名前缀说明：" class="headerlink" title="O-C中的命名前缀说明："></a>O-C中的命名前缀说明：</h5><p><code>NS-：NextStep;</code><br><code>CF-：Core Foundation;</code><br><code>CA-：Core Animation;</code><br><code>CG-：Core Graphics;</code><br><code>UI-：User Interface;</code></p>
<h5 id="O-C中的消息特殊性："><a href="#O-C中的消息特殊性：" class="headerlink" title="O-C中的消息特殊性："></a>O-C中的消息特殊性：</h5><blockquote>
<p>调用消息的类可以不知道如何响应这个消息。如果它不知道如何处理这个消息，它会自动将这个消息传递给其他的类，比如它的父类。<br>调用消息的类可以是nil。在C++中，在使用类方法之前，我们都需要检查对象是否为空，所以在实现析构函数的时候，常会有如下的代码，如<code>if (var) &#123; delete var; &#125;</code>但是在<code>Objective-C</code> 中，我们就可以直接写<code>[var release]</code>;即使<code>var == nil</code>, 也不会有问题。</p>
</blockquote>
<p><strong><em>O-C中的函数声明格式有</em></strong>：<br><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">-/+ (<span class="hljs-keyword">return</span> type) function_name;<br>-/+ (<span class="hljs-keyword">return</span> type) function_name : (parameter type) parameter;<br>-/+ (<span class="hljs-keyword">return</span> type) function_name : (parameter type) parameter1 otherParameter: (parameter_type) parameter2;<br></code></pre></td></tr></table></figure><br>以上参数说明：<code>-</code>表示一般函数，<code>+</code>表示静态函数。<code>otherParameter</code>是参数的别名(第一个参数的别名省略)，在函数调用时方便指定。</p>
<h5 id="O-C中的构造-析构函数"><a href="#O-C中的构造-析构函数" class="headerlink" title="O-C中的构造/析构函数:"></a>O-C中的构造/析构函数:</h5><ul>
<li>O-C中的 init()/release() 对应于C++的构造/析构函数。alloc()/dealloc()也就对应于C++的new和delete,其中的dealloc()由于引用计数的自动调用而不用手动调用。</li>
<li>O-C中父类的init()/release()函数需要子类的手动调用。而且每次都必须调用。不同于C++的自动调用。</li>
<li>构造函数(- (id) init)调用形如:CSample* pSample=[[CSample alloc] init];其中alloc(+ (id) alloc)是继承来的static函数，init是继承来的一般函数，如重写一般函数时，则相当于C++的覆盖(不带参数)或重载(带参数)。</li>
<li>析构函数(- (void)release)将引用计数减1，当=0时父类的 release() 会自动调用dealloc(- (void)dealloc);</li>
</ul>
<blockquote>
<p>当O-C没有数据成员时，可省略{},建议保留。</p>
<p>继承下来的方法，如：-(id) init可以头文件中省略，建议保留。</p>
<p>O-C中只有数据成员的访问限制，没有方法的访问限制。</p>
<p>同C++一样，数据成员有三种访问限制public, protected, private，缺省是protected。<br>示例：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">AccessExample</span>: <span class="hljs-title">NSObject</span> </span>&#123;    <br><br><span class="hljs-keyword">@public</span><br><span class="hljs-keyword">int</span> publicVar;<br><br><span class="hljs-keyword">@protected</span><br><span class="hljs-keyword">int</span> protectedVar;<br><br><span class="hljs-keyword">@private</span><br><span class="hljs-keyword">int</span> privateVar; <br>&#125; <br><span class="hljs-keyword">@end</span>  <br><br></code></pre></td></tr></table></figure>
<p>方法的访问限制可通过Category（类别）实现，示例代码：<br><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// MyClass 类</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyClass</span>   </span><br>-(<span class="hljs-keyword">void</span>) sayHello    <br>&#123;   <br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Hello&quot;</span>);   <br>&#125;   <br><span class="hljs-keyword">@end</span><br><span class="hljs-comment">// MyClass  的扩展类</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyClass</span>(<span class="hljs-title">Private</span>)   </span><br>-(<span class="hljs-keyword">void</span>) kissGoodbye;   <br><span class="hljs-keyword">@end</span>   <br></code></pre></td></tr></table></figure><br>O-C中没有类的静态变量，只有全局变量。</p>
<p>O-C中的数组NSArray可以保存不同类型的数据。</p>
<p>O-C也支持run-time时的类型检查：</p>
<p><code>- (BOOL) isKindOfClass: classObj</code>用于判断该对象是否属于某个类或者它的子类。</p>
<p><code>- (BOOL) isMemberOfClass: classObj</code>用于判断该对象是否属于某个类（这里不包括子类) 。<br><code>- (BOOL) respondsToSelector: selector</code> 用于判断该对象是否能响应某个消息。这里，我们可以将@selector后面带的参数理解为C++中的函数指针。<br>注意:1）不要忘了@</p>
<p>　　 2）@selector后面用的是<code>()</code>，而不是<code>[]</code>。<br>　　<br>　　3）要在消息名称后面跟：，无论这个消息是否带参数。<br>　　<br>　　 如：<code>[pSquare respondsToSelector:@selector(Set: andHeight:)]</code>。<br><code>+ (BOOL) instancesRespondToSelector: selector</code> 用于判断该类是否能响应某个消息。这是一个静态函数。</p>
<p><code>-(id) performSelector: selector ：</code> 调用对象的selector方法。</p>
<p><code>conformsToProtocol</code>类似于<code>respondsToSelector</code>，用于动态检查某个对象是否遵守某个协议。</p>
<p><code>Category</code>：范畴/扩展类：在没有源代码的情况下，为一个已经存在的类添加一些新的功能。</p>
<p>只能添加新的方法，不能添加新的数据成员；</p>
<p><code>Category</code>的名字必须是唯一的。</p>
<p><code>Protocol</code>：协议类：相当于C++中的纯虚类</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//创建协议</span><br><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">MyProtocol</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span><br><span class="hljs-comment">//规则1</span><br><span class="hljs-comment">//规则2</span><br><br><span class="hljs-keyword">@required</span>    <span class="hljs-comment">//表示修饰的协议方法必须实现</span><br><span class="hljs-comment">//完成作业的协议方法</span><br>- (<span class="hljs-keyword">void</span>)finishTask;<br><br><span class="hljs-comment">//不能迟到的协议方法</span><br>-(<span class="hljs-keyword">void</span>)dontLate;<br><br><span class="hljs-keyword">@optional</span>   <span class="hljs-comment">//表示修饰的协议可选,可实现/可不实现</span><br><span class="hljs-comment">//穿戴整洁</span><br>- (<span class="hljs-keyword">void</span>)wearNeat;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">//  类签订协议:&lt;协议名&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Student</span>: <span class="hljs-title">NSObject</span> &lt; <span class="hljs-title">MyProtocol</span> &gt; </span>&#123;<br><br><span class="hljs-comment">//实现协议方法</span><br>- (<span class="hljs-keyword">void</span>)finishTask&#123;...&#125;<br>-(<span class="hljs-keyword">void</span>)dontLate&#123;...&#125;<br><br> &#125; <span class="hljs-keyword">@end</span><br><br></code></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 使用：</span><br>Student * student1 = [[Student alloc] init];<br><span class="hljs-keyword">id</span>&lt; MyProtocol &gt; student1 = dat;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>说明：我们首先声明了<code>MyProtocol</code>协议，任何遵守这个协议的类，都必须实现<code>@required</code>中的方法。在<code>Objective-C</code> 中，我们通过&lt;&gt;来表示遵守某个协议。当某个类声明要遵守某个协议之后，它就必须在.m文件中实现这个协议中的所有方法。使用<code>id&lt; MyProtocol &gt;</code> 作为类型，而不是像<code>C++</code>中的<code>MyProtocol* var</code>。</p>
</blockquote>
<p><code>IBOutlet</code>, IBAction: 告诉Xcode之后会使用Interface <code>Builder</code>关联该插座变量、动作。如果你希望在Interface <code>Builder</code>中能看到这个控件对象，那么在定义的时候前面加上IBOutlet，在IB里就能看到这个对象的outlet，如果你希望在Interface <code>Builder</code>里控制某个对象执行某些动作，就在方法前面加上IBAction。<br>形如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 声明一个属性 questionLabel，可以指向 UILabel 对象</span><br><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">weak</span>) <span class="hljs-keyword">IBOutlet</span> <span class="hljs-built_in">UILabel</span> *questionLabel;<br><br><span class="hljs-comment">//方法：实现 Botton 动作</span><br>- (<span class="hljs-keyword">IBAction</span>)showQuestion:(<span class="hljs-keyword">id</span>)sender&#123;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>尽量避免在一行语句中进行两层以上的嵌套。</p>
<p>消息转发：- (void) forwardInvocation: (NSInvocation *)anInvocation;</p>
</blockquote>
<p>扩展的关键字</p>
<p><strong>@interface</strong></p>
<p>类型声明，类似于 c++ 中的 class，区别在于OC中的声明与实现是强制分开的，@interface存放于.h文件中，而@implementation存放于.m文件中。@interface关键字用于类型的声明，包括数据成员、方法声明、属性等。方法的参数传递采用中缀符的形式，利用“：”分割参数名和被传递参数，类型的声明以@interface开头，以@end结束，通常一个类型的声明采用下面的结构：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@class</span> <span class="hljs-title">someOtherObject</span> //外部类型声明   </span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NewClassName</span> : <span class="hljs-title">ParentClassName</span> //类型声明 子类：父类   </span><br>&#123;  <br><span class="hljs-comment">//    定义属性   </span><br><span class="hljs-comment">//    全局变量，成员变量，实例变量   </span><br>    <span class="hljs-built_in">NSInteger</span> _age;  <span class="hljs-comment">//年龄   </span><br>    <span class="hljs-built_in">NSString</span> *_name;  <span class="hljs-comment">//姓名   </span><br>    <span class="hljs-keyword">float</span> _weight;  <span class="hljs-comment">//体重     </span><br>&#125;  <br><span class="hljs-comment">//方法定义   </span><br>-(<span class="hljs-keyword">void</span>)shopping；<span class="hljs-comment">//不带参数的方法   </span><br>-(<span class="hljs-keyword">void</span>)goshopping:(<span class="hljs-keyword">float</span>)price; <span class="hljs-comment">//带参数的方法       </span><br>-(<span class="hljs-keyword">id</span>)someMethod:(<span class="hljs-keyword">int</span>)someArg someOtherArgName:(<span class="hljs-keyword">int</span>)someOtherArg;     <br><span class="hljs-comment">//类方法,使用类名调用的方法 [类名 方法]   </span><br><span class="hljs-comment">//以&#x27;+&#x27;开头    </span><br>+(<span class="hljs-keyword">id</span>)someMethod:(<span class="hljs-keyword">int</span>)someArg;     <br>-(<span class="hljs-keyword">id</span>)init; <span class="hljs-comment">//初始化方法     </span><br><span class="hljs-keyword">@property</span> <span class="hljs-keyword">int</span> num; <span class="hljs-comment">//属性,为属性自动生成set和get方法   </span><br><span class="hljs-keyword">@end</span>   <br></code></pre></td></tr></table></figure>
<p><strong>@implementation</strong></p>
<p>对应于@interface的类型声明，@implementation表示一个类型的实现过程，存放于‘.m’文件中，同样以@end结束，实现的格式通常如下：<br><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">//预编译指令，只编译 .m 文件，而 .h 文件导入到此处处理。   </span><br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;Person.h&quot;</span>   </span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">NewClassName</span>     </span><br>-(<span class="hljs-keyword">id</span>)someMethod:(<span class="hljs-keyword">int</span>)someArg someOtherArgName:(<span class="hljs-keyword">int</span>)someOtherArg   <br>&#123;   <br><span class="hljs-comment">//实现代码   </span><br>&#125;    <br>+(<span class="hljs-keyword">id</span>)someMethod:(<span class="hljs-keyword">int</span>)someArg    <br>&#123;   <br><span class="hljs-comment">//类方法实现代码    </span><br><span class="hljs-comment">//与实例方法的区别：类方法中不能使用属性    </span><br> &#125;   <br><span class="hljs-keyword">@synthesize</span> num=i; <span class="hljs-comment">//将属性与变量进行对应 </span><br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><br><strong>new、alloc</strong></p>
<p>Object-C中的方法调用形式采用消息发送的方式，通常调用的形式如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br>[someObject someMethod:firstArg someOtherArgName:otherArg];<br><br></code></pre></td></tr></table></figure>
<p>实例的初始化也采用消息发送的形式，可以简单的调用类型的new方法来获取一个实例对象，简单实例化的方法通常是：<br><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">someObject *obj = [someObject new]; <span class="hljs-comment">//类的实例化</span><br></code></pre></td></tr></table></figure><br>new 方法的实际过程是调用 alloc 和 init 方法，因此如果需要采用自定义的方法来初始化实例，则需要自己重写 init 方法，通常的初始化方式为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">someObject *obj = [[someObject alloc] init]; <span class="hljs-comment">//采用无参数的init实例化   </span><br>someObject *obj = [[someObject alloc] initWithArg:Arg]; <span class="hljs-comment">//采用参数的实例化 </span><br></code></pre></td></tr></table></figure>
<p><strong>@class</strong></p>
<p>@class是一个前向引用声明，类似于C++中的friend友元声明，其作用是告诉编译器其后面的字段代表一个类型名称，尽管不知道类型的具体实现，但是只需要将其作为一个类型名称处理即可。通常在使用复合的结构时可以采用@class来减少头文件的相互引用，如果出现循环依赖，则需要依靠@class来避免引用的死循环。</p>
<p>@class 可以解决 #import 引起的相互导入而导致的循环引用问题。<br>在头文件里要使用其他类,一般用@class, 在实现文件用#import导入类文件。<br>通常使用形式为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@class</span> <span class="hljs-title">someOtherObject</span>;      </span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">someObject</span>:<span class="hljs-title">NSObject</span>   </span><br>&#123;   <br>someOtherObject *obj;  <br></code></pre></td></tr></table></figure>
<h1 id="import"><a href="#import" class="headerlink" title="import"></a>import</h1><p>类似于C语言中的 #include，导入一个头文件,获取该头文件中类的定义—方法和属性。</p>
<p><strong>@property</strong></p>
<p>尽管可以使用 obj-&gt;arr 的形式去强制读取对象的成员变量，但是良好的编程形式是对外界提供成员变量的读写接口。@property关键字提供了外界对成员变量的访问接口，其本质是自动为某一个属性生成set和get方法。<br>根据不同的需要，可以添加 readonly（只读，相当于只添加get不添加set方法）或者 readwrite（读写，如果不添加则为默认）；<br>还有三种赋值方式可选 ：<br>assign（直接赋值，通常用于基本类型），</p>
<p>retain（释放旧值，增加新的retaincount），</p>
<p>copy（常用于字符串，生成一个新的拷贝）.</p>
<p>格式：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">@property</span>(原子性©,赋值©,读写性©)<span class="hljs-built_in">NSString</span> *XXX;  <br><span class="hljs-number">1.</span>原子性    <br>  * atomic：多线程环境下，存在线程保护；   <br>  * <span class="hljs-keyword">nonatomic</span>：多线程环境下，不存在线程保护；   <br><span class="hljs-number">2.</span>赋值     <br>  * <span class="hljs-keyword">assign</span>：直接赋值，默认；(对象之外的类型使用)   <br>  * <span class="hljs-keyword">retain</span>：保留对象；（所有的对象，都使用 <span class="hljs-keyword">retain</span>）   <br>  * <span class="hljs-keyword">copy</span>：拷贝对象；<span class="hljs-built_in">NSString</span> 的对象都使用 <span class="hljs-keyword">copy</span>    <br><span class="hljs-number">3.</span>读写性     <br>  * <span class="hljs-keyword">readwrite</span>：生成<span class="hljs-keyword">getter</span>、<span class="hljs-keyword">setter</span>方法，默认；   <br>  * <span class="hljs-keyword">readonly</span>：只生成<span class="hljs-keyword">getter</span>方法  <br></code></pre></td></tr></table></figure>
<p>作用：</p>
<ol>
<li>生成一个 _XXX 属性，此属性是 private ,不能被继承；</li>
<li>自动为该属性生成 set 和 get 方法。<br>通常使用的方式如下：<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">someObject</span>:<span class="hljs-title">NSObject</span>   </span><br>&#123;   <br><span class="hljs-keyword">int</span> i; <span class="hljs-comment">//成员变量    </span><br>&#125;   <br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">assign</span>,<span class="hljs-keyword">readonly</span>) <span class="hljs-keyword">int</span> num; <span class="hljs-comment">//属性(注意无需下划线)   </span><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>
<strong>@synthesize</strong></li>
</ol>
<p>与 @property 对应，将一个外在属性与成员变量相关联，定义在 @implementation 中，如果属性名与变量名一致则可以省略变量名。常用方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">someObject</span> </span><br>  <br><span class="hljs-keyword">@synthesize</span> num=i;<span class="hljs-comment">//如果属性名也为i，则可以直接写为 @synthesize i </span><br><br><span class="hljs-comment">//更改属性名，将默认的 _username 改为 _name</span><br><span class="hljs-keyword">@synthesize</span> username = _name;  <br><span class="hljs-keyword">@end</span>   <br></code></pre></td></tr></table></figure>
<h6 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h6><p>内存管理是关于如何管理 对象 生命周期的编程原则。<br>Object-C采用引用计数的方式进行内存管理，由于所有的对象都继承于 NSObject，因此所有的对象都可以接受 NSObject 的三个方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br>-(<span class="hljs-keyword">id</span>)<span class="hljs-keyword">retain</span>;   <span class="hljs-comment">//retain方法将对象的引用计数加1并返回该对象   </span><br>-(<span class="hljs-keyword">void</span>)release; <span class="hljs-comment">//release将引用计数减1   </span><br>-(<span class="hljs-keyword">unsigned</span>)retainCount; <span class="hljs-comment">//retainCount方法返回对象当前的引用计数  </span><br></code></pre></td></tr></table></figure>
<p>当采用 <code>new、alloc、copy</code> 方法创建一个对象时，它的引用计数被置为1，如果程序中对该对象进行操作，则应根据需要，通过调用 <code>retain</code> 和<code>release</code> 方法来保证该对象在不需要的时候被清除。当一个对象的引用计数被置为0后，系统会自动向对象发送一个 <code>dealloc</code> 消息，将其占有的资源释放。通常情况下，如果一个对象的初始化过程调用了其他资源，则应该重写该对象的 <code>dealloc</code>过程，保证在对象的销毁期正确释放这些资源。</p>
<p><strong><em><code>Object-C</code>进行内存管理的3条规则</em></strong>是：</p>
<ul>
<li>如果使用 new、alloc、copy 操作获得一个对象，则该对象的保留计数器值为1.</li>
<li>如果通过任何其他方法获得一个对象，则假设该对象的保留计数器值为1，而且已经被设置为自动释放。</li>
<li>如果保留了某个对象，则必须保持 retain 方法和 release 方法的使用次数相等。</li>
</ul>
<p><code>retainCount</code>：内存管理默认为系统自动.<br>内存管理改为手动方法：选中<code>Project -&gt; Build settings -&gt; 搜索框搜索“arc”</code>,将 Object-C <code>Automatic Reference Counting</code>值设置为<code>No</code>；<br>手动内存管理(MRC)黄金法则:如果对一个对象使用了 <code>alloc,[mutable]copy,retain</code>, 那么你必须使用相应的 <code>release</code>或者<code>autorelease</code> 释放.</p>
<ul>
<li>为了更加方便的进行能存管理，cocoa中提供了一个自动释放池（autorelease pool）的概念，每一个类都继承了一个autorelease方法，当调用对象的autorelease方法时，该对象会被加入到开始创建的自动释放池中。当程序进行到不再需要自动释放池中的对象时，将自动释放池释放的时候会向池中的所有对象发送一个 release 消息，从而保证不再需要的对象被正确的释放。通常的用法如下：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSAutoreleasePool</span> *pool = [[<span class="hljs-built_in">NSAutoreleasePool</span> alloc] init];   <br>someObject * obj = [[someObject alloc] init];   <br>[obj autorelease]; <span class="hljs-comment">//将 obj 对象加入自动释放池中，引用计数不会-1.   </span><br><span class="hljs-comment">//其他代码  </span><br>[pool release]; <span class="hljs-comment">//执行该语句时，系统会向池内所有的对象发送 release 消息；</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>在这个例子中，如果对obj进行的其他 retain 操作和 release 操作保持一致的话，则会将obj的引用计数变为0，从而调用它的 dealloc 方法进行资源释放.</p>
</blockquote>
<h5 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h5><p>ARC自动引用计数(automatic reference counting)，提供自动管理内存的功能。<br>不需要手动管理引用计数,不需要也不允许 retain、release、autorelease。<br>注意版本的支持是在iOS4(不支持弱引用)、iOS5上。<br>内存中的区域划分</p>
<p>栈:栈区(stack)由系统自动分配和释放 ,存放局部变量的值等。<br>堆:一般由程序员分配和释放,如果不释放,则出现内存泄露。程序退出时, 系统会回收你的内存。特点:无序、速度慢、容量大。<br>静态存储区:全局变量(外部变量)和静态变量都存放在静态区域。当程序结束时,系统回收。<br>常量区:存放常量的内存区域,程序结束时,系统回收。<br>代码区:存放二进制代码的区域。<br>数组内存管理</p>
<p>如果一个对象被添加到数组,那么这个对象的引用计数会被 retain 而 +1.<br>数组销毁或者 removeAllObjects,会给每一个元素发送 release 消息。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//对数组中的每一个元素发送release消息  </span><br>[array removeAllObjects]; <br>    <br><span class="hljs-comment">//移除下标为1的元素,同时向它发送release消息  </span><br>[array removeObjectAtIndex:<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure>
<h5 id="类方法创建的内存管理"><a href="#类方法创建的内存管理" class="headerlink" title="类方法创建的内存管理"></a>类方法创建的内存管理</h5><p>Foundation 中的类可以通过 alloc 创建和 类方法 创建,区别在于内存管理不一样。<br>类方法 创建的对象是加入了自动释放池。<br>新语法（简便写法）创建的对象和类方法创建的对象相同,由自动释放池管理。</p>
<h4 id="Category-（类别、类目）"><a href="#Category-（类别、类目）" class="headerlink" title="Category （类别、类目）"></a>Category （类别、类目）</h4><ul>
<li>类目是为现有的类提供一个新的方法的方法，即使没有一个类的源代码，仍然可以向类中添加一个方法以方便使用。</li>
<li>通过类目扩展的方法,子类也能继承下来。</li>
<li>类目不能为原始类增加属性。</li>
<li>无法调用原始类的方法。</li>
<li>类目的主要目的有3个：将类的实现分散到多个不同的文件或框架中，创建对私有方法的前向引用，向对象添加非正式协议。</li>
<li>类目的定义和类的定义相似。在.h文件里声明,.m文件里实现方法。</li>
<li>定义类目的文件命名规则: 类名+类目名称,如“NSString+Revert”。<br>类目的创建： 菜单选File -&gt; New -&gt; File -&gt; Object-C File -&gt;选择File Type为 Category</li>
</ul>
<p>类别的声明方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSString</span> (<span class="hljs-title">Extension</span>)</span><br>&#123;<br><span class="hljs-comment">//        NSString *s = @&quot;hello&quot;;  错误！类目不能创建属性！！！</span><br>&#125;<br><br><span class="hljs-comment">// 要扩展的方法 </span><br>-(<span class="hljs-keyword">id</span>)someMethod:(<span class="hljs-keyword">int</span>)someArg; <br><br><span class="hljs-comment">//覆写父类方法</span><br>- (<span class="hljs-built_in">NSArray</span>&lt;<span class="hljs-built_in">NSString</span> *&gt; *)componentsSeparatedByString:(<span class="hljs-built_in">NSString</span> *)separator;<br><br><span class="hljs-keyword">@end</span> <br></code></pre></td></tr></table></figure>
<p>类别的实现方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">NSString</span> (<span class="hljs-title">Extension</span>)</span><br><br>-(<span class="hljs-keyword">id</span>)someMethod:(<span class="hljs-keyword">int</span>)someArg; &#123;<br><span class="hljs-comment">//实现代码</span><br>&#125;<br><br>- (<span class="hljs-built_in">NSArray</span>&lt;<span class="hljs-built_in">NSString</span> *&gt; *)componentsSeparatedByString:(<span class="hljs-built_in">NSString</span> *)separator&#123;<br><span class="hljs-comment">//无法调用原始类的方法</span><br><span class="hljs-comment">//实现代码</span><br><span class="hljs-keyword">return</span> expression;<br>&#125;<br><span class="hljs-keyword">@end</span>  <br></code></pre></td></tr></table></figure>
<h5 id="延展"><a href="#延展" class="headerlink" title="延展"></a>延展</h5><blockquote>
<p>在类的实现文件.m中定义类目,叫延展。<br><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//延展：使用类目声明方法，在实现类中实现此方法</span><br><span class="hljs-comment">//延展可以在.h中声明,也可以在.m中声明</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Persion</span> (<span class="hljs-title">p2</span>)</span><br><br>-(<span class="hljs-keyword">id</span>)someMethod:(<span class="hljs-keyword">int</span>)someArg;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure></p>
<h4 id="protocol-（协议）"><a href="#protocol-（协议）" class="headerlink" title="@protocol （协议）"></a>@protocol （协议）</h4></blockquote>
<ul>
<li>Object-C中的协议类似于java中的接口，通过@protocol关键字定义一个或多个需要遵从协议的对象实现的方法。</li>
<li>协议本身不是类，它定义了一组方法，让其他类来实现。</li>
<li>在类实现时需要将协议中规定的方法都予以实现。Object C 2.0增加了2个新的协议修饰符@optional和@required，可以规定协议中的方法是否为必须实现的方法。</li>
<li>创建方式：菜单选<code>File -&gt; New -&gt; File -&gt; Object-C File -&gt;自定义协议名</code>，选择File Type为 Protocl。<br>协议定义的方法：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">MyProtocol</span> &lt; <span class="hljs-title">NSObject</span> &gt;</span><br><br><span class="hljs-keyword">@required</span> <span class="hljs-comment">//表示修饰的协议方法必须实现    </span><br>-(<span class="hljs-keyword">void</span>)someMethod1; <span class="hljs-comment">//协议方法</span><br><br><span class="hljs-keyword">@optional</span> <span class="hljs-comment">//表示修饰的协议可选，可实现/可不实现      </span><br>-(<span class="hljs-keyword">void</span>)someMethod2;     <br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>
<p>采用协议的方法需在类声明时使用尖括号注明其需要使用的协议：<br><code>@interface someObject:NSObject &lt;MyProtocol&gt;</code><br>然后在 .m 文件中添加协议中需要实现的方法。</p>
<h5 id="self-和-super"><a href="#self-和-super" class="headerlink" title="self 和 super"></a><code>self</code> 和 <code>super</code></h5><ul>
<li><code>self</code>指的是类对象本身;</li>
<li><code>super</code>是父类对象本身;</li>
<li><code>self</code>用来调用本类对象的方法;</li>
<li><code>self</code>关键字先从本类中查找是否有此方法，如果没有，再从父类中调用此方法;</li>
<li><code>super</code>调用从父类继承下来的方法;</li>
<li><code>super</code>关键字直接调用父类中定义的方法.</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>概述</tag>
      </tags>
  </entry>
  <entry>
    <title>我的女朋友</title>
    <url>/2019/11/10/%E6%88%91%E7%9A%84%E5%A5%B3%E6%9C%8B%E5%8F%8B/</url>
    <content><![CDATA[<p>或许是回忆太美，只是物是人非。</p>
<p><img src="http://c.hiphotos.baidu.com/image/pic/item/ae51f3deb48f8c54b6cc922935292df5e0fe7f9c.jpg" alt="1"></p>
<p>毕业答辩的前一天，我问喵小姐：“你真的愿意和我一起留在北京吃苦？你妈妈都给你安排好了一切，我要是你，早就回老家发展了。”</p>
<p>喵小姐说：“你再说，再说我可生气了哇！”然后把一块回锅肉夹起喂到我的嘴巴里。 喵小姐是北方人，对于川菜的辛辣有点接受不了，但每次出去约会的时候，她都愿意和我一起吃回锅肉。</p>
<p>吃一口，嘴巴就呼哧呼哧直喘气，然后一张一合地喝水：“真辣啊，但是很好吃！”我说：“你这是何必呢，不能吃辣就别勉强啊。”喵小姐说：“我就要和你吃一样的！”在一起两年后，喵小姐逐渐习惯了川菜的辛辣，每次出去吃饭的时候她都会点一份回锅肉。</p>
<p>有一次我和喵小姐拉着手在马路上散步，我问喵小姐：“你说毕业以后我们干什么呢？好迷茫啊，真想一辈子当学生，无忧无虑的。”喵小姐敲了一下我的脑袋：“就知道玩儿，一点儿也不成熟。不如我们开饭店吧，我朝我妈妈要一笔钱，咱们自己干。你不是很会做饭吗？你当主厨好了，我呢，我就当老板娘吧！”说完自己嘿嘿直傻笑。我则苦笑道：“说什么呢，我怎么可能要你妈妈的钱。”</p>
<p>俗话说，船到桥头自然直，虽然迷茫了很长一段时间，但当真正来临的那一刻，还是动了起来。我决定在北京先待几年再说，并做好了各种各样的准备。</p>
<p>当喵小姐和我说她妈妈在老家给她安排了一份薪水五位数一周还休息三天的工作的时候，我是很欣慰的，心想她要是回去了就不用跟着我吃苦了。结果喵小姐给她妈打电话说：“我不回去了，我要待在北京，和我男朋友在一起。”</p>
<p>我当时心情是很复杂的，有感动，有开心，还有对未来的恐惧和担忧。如果你是一个男人，你应该明白那种带着心爱的女人一起吃苦的屈辱感。</p>
<p>但一个人就不一样，一个馒头就能凑合一顿，没有地方睡花十来块钱在网吧上个通宵一晚上就过去了，如果带着心爱的女人就不行了啊！ 我非常不可思议地看着喵小姐：“我以后可是要住一段时间地下室的，里面潮湿阴暗，不见阳光，憋得慌，还有很多怪叔叔和社会小青年，你不怕啊？”喵小姐说：“有你在，天塌了我都不怕。”</p>
<p><img src="http://c.hiphotos.baidu.com/image/pic/item/6c224f4a20a44623c3f7f2649722720e0cf3d7f3.jpg" alt="15"></p>
<p>吃完回锅肉后，我和喵小姐拉着手往学校里走，我把她送到宿舍楼下准备离开的时候，她突然冲上来吻了我一下。我心里想着明天答辩的事儿，恍惚了几秒才反应过来，此时她已经跑出了几米远，冲我比了比剪刀手和拳头，以示努力、加油。</p>
<p><img src="http://h.hiphotos.baidu.com/image/pic/item/cc11728b4710b9129ff1a1f8ccfdfc0392452287.jpg" alt="图片发自简书App"></p>
<p>答辩结束的第二天，我就收拾东西搬到了地下室，我没有和喵小姐说，心里还是在期望她能回去的。我希望她也不和我告别，只要她能生活得好，一切都不重要。结果，我刚收拾完狭窄的地下室的床，转身就看到了她，我没有关门，她倚在门边叉着手似笑非笑地看着我。</p>
<p>我手足无措起来，尴尬得不知道说什么好。喵小姐没有说什么，她把她的行李往床上一放，开始收拾起屋子来。我知道，我们将要在地下室住一段日子了。 我在一家互联网公司做运营，每天晚上要加班到八九点钟。</p>
<p>喵小姐没有去上班，她每晚在我公司楼下等我，和我一起去路边摊吃晚饭，然后一边聊天一边向地铁站走。</p>
<p>开始我沉浸在这样的幸福中，但渐渐地我开始拒绝她等我，最后变成了反感。有一天晚上她又来等我，我们吃完东西往地铁站走的时候，她一边说话一边拉我的手，我突然气上心头，一下子甩开她的手。</p>
<p>她一脸惊愕，难以置信地看着我。我冲她吼叫：“我们能一直这样吗？我们能这样一辈子吗？” 喵小姐怔怔地看着我，眼眶里有泪水在闪烁，眼泪顺着脸颊流了下来。</p>
<p>她一哭我就心软，我抓了抓头发，向她道歉：“对不起，最近压力有点大。”然后轻轻地抱住了她。 第二天晚上下班的时候，喵小姐没有来接我，下午的时候她给我发微信说她去找了一份工作，在一家金融公司当总经理助理，我因为太忙，还没来得及回复。﻿</p>
<p><img src="http://e.hiphotos.baidu.com/image/pic/item/71cf3bc79f3df8dcedf7cd91c211728b461028e3.jpg" alt="图片发自简书App"><br>            我掏出手机给她打电话，电话接通后，那边的声音很嘈杂，好像是有人在唱歌。正常的声音她听不清楚，我就吼着问她：“你那边怎么回事啊？”她也用吼的声音和我说：“经理说我今天就开始上班了，晚上正好有个饭局，就把我也带上了。”我说：“你看现在都几点了！你在哪儿？我去找你！”喵小姐说了地址后，我就匆匆向她那边赶去。</p>
<p>在KTV的门口，我见到了喵小姐，她满身酒气，还有些微醉，我扶住她：“走，跟我回家。”她说：“我不回去。”还想挣脱我的手，我厉声道：“快和我回去！”她说：“那你要答应和我一起开饭店。”我没吭声。</p>
<p>她又说：“那你别拦着我，他们还等着我呢。”我说：“好好好，我答应你。” 喵小姐一觉睡到了中午，醒来后没有发现我，就直接给我打了电话过来，惊慌失措地问我去了哪里。我说：“我在上班啊，还能去哪里？”她说：“不是说好和我一起开饭店的吗？”昨晚我当她喝醉了神志不清才说一起开饭店的，结果她一直记着。</p>
<p>我耍赖说：“你是不是记错了，我什么时候说啦。”她呵呵一笑：“我就知道你会这么说，我可录音了，你要不要听？”我很无奈：“那你总得让我把今天忙完吧，我还没辞职呢。” 我工作了三个月，这三个月过得昏天黑地的，每天除了有做不完的工作，还时常被办公室的各个人叫去跑腿，好像谁都能欺负我一般。我每天晚上加班的时候都想把桌子给掀了，然后一走了之。﻿</p>
<p><img src="http://b.hiphotos.baidu.com/image/pic/item/e850352ac65c1038a2a99ac4bd119313b17e89e5.jpg" alt="图片发自简书App"><br>      但我忍住了。我给自己灌鸡汤，生活不都是这样吗？每个成功人士都是这样走过来的。 当喵小姐再次和我说起一起开饭店这件事情的时候，我发现我并没有自己想象的那么坚强，我居然动摇了。</p>
<p>我可耻地想，日子每天都得照常过，我为什么要活得那么累呢？既然有机会，就要好好抓住啊，不珍惜机会的人都是傻子！ 我花了三个晚上的时间平复自己的内心。</p>
<p>这三个晚上，我告别了那个曾经自以为坚持自我、能独自一人闯出一片天的自己，开始变得世故和圆滑。为了不那么辛苦，我开始接受喵小姐以及她们家的帮助，尽管我曾一度鄙视过会这样做的自己。虽然喵小姐的出发点和我想的截然不同，她只是希望我们的爱情不要那么辛苦而已。</p>
<p>我虽然会做几个菜，但离厨师这个职业还差一大截，我也没有学过管理。除了年轻有动力我爱喵小姐喵小姐也爱我之外，我没有其他条件能征求到喵小姐妈妈的支持。</p>
<p>虽然喵小姐对她妈妈拿钱给我们开店这件事情一直信心满满。 经过商议，我不做厨师，而是负责管理这家饭店上上下下的工作，还得在喵小姐妈妈的带领下。</p>
<p>她说我们刚毕业，没有任何经验，怕搞砸了。但我清楚地感觉到，她不相信我。 喵小姐她妈不让我叫她伯母，也不让我叫她阿姨，而是称呼其为老板。老板是个雷厉风行的女强人，在他面前我不能表现得太差，我把她当成了我和喵小姐过一辈子的考验，我必须得迈过去。</p>
<p>白天我绷紧了神经很努力地工作，晚上拼命看书学习，希望能在最短的时间内成熟和强大起来。 喵小姐倒是特别高兴，她没啥正经事儿干，每天就在店里转来转去，活脱脱一个富家千金的姿态。</p>
<p>有天晚上她对我说：“我想给我们饭店弄点特色。”我问她是什么，她说：“我打算叫你来做我们店里的回锅肉，限量版，每天只卖20份。”我说：“有专业的厨师不让他们做，让我做，搞错没有？”喵小姐说：“特色嘛，老板亲自做菜的店有几家啊。”我说：“你妈才是老板，我不是。”</p>
<p>喵小姐拉住我的手开始撒娇：“再等等吧，我妈想的也对，如果没有她，我们两个是玩不转这么大一个饭店的，等你变得更厉害了她就可以放心交给你打理了。”</p>
<p>我说：“那你让我先好好学习吧，做回锅肉什么的，等以后再说。” 喵小姐说：“我还从来没有吃过你给我做的回锅肉呢——不对，我从来没有吃过你做的饭！你真的会做饭吗？”我想了想，发现也是，和喵小姐在一起三年多了，我还没有给她做过饭。我开玩笑说：“你都没见过我做饭，怎么我说我会做饭你就信了呢？”喵小姐嘴巴一翘：“我看得出来你会做饭，我也知道你不会骗我。”</p>
<p>那天晚上我第一次给喵小姐做饭，炒了一份回锅肉，一份青菜，还有一份番茄鸡蛋，都是下饭的家常菜。喵小姐吃得很开心，一边吃一边朝我竖大拇指，平常只吃一碗饭的她，今天却吃了三碗饭。 不知道为什么，那一刻我有流泪的冲动。我在心里想，拥有这么好的姑娘，我应该更加努力才对。</p>
<p>半年之后，老板还是没有让我独立管理饭店的打算，虽然我自认为我已经足够有能力了。喵小姐说要去找她妈理论理论，我说等等吧。</p>
<p>喵小姐不干，拉着我跑到她妈妈面前非得问个为什么。 喵小姐用质问的口气问老板：“妈，不是说好了时机一成熟就把饭店交给我们打理吗？”老板看了一眼我，又看了一眼怒气冲冲的喵小姐，用蔑视的口吻说：“现在饭店的员工上上下下加起来有30多个人，食客也每天越来越多，你觉得他管得过来吗？”喵小姐说：“当然管得过来！”老板厉声道：“你让他自己说！”然后她们两人都把眼睛看向我，等着我回答。</p>
<p>我如站在火山口一样难受和煎熬，不知道为什么，我内心有很屈辱的感觉，像在跪求着别人肯定自己一样难受，还是从来没有看起过自己的人。我立在那儿，不知道怎么回答老板的问题，我很想一走了之，但那明显太不礼貌了。</p>
<p>我就那么尴尬地站了一会儿，然后做了一个鬼使神差的举动。我弯下腰，朝老板和喵小姐鞠了一躬就淡定地走了出去，全程没有说一句话。 我一直走到饭店门口的花坛边才停下来，我坐在花坛边的椅子上，点燃一支烟默默地抽了起来。</p>
<p>过了几分钟，我听到了高跟鞋走路的声音。喵小姐默默地走到我身边，坐下，不说话，我的头一直埋着，我不知道她的表情。 喵小姐打破了沉默：“你到底想怎样？”我说：“我不知道，我也不知道我在做什么。”喵小姐也不再说话。</p>
<p>又过了大概十分钟，喵小姐来拉我的手：“回家吧，外面好冷。”我坐在那儿，没动，我问她：“为什么你要对我这么好？”喵小姐说：“我爱你，我们有很深的感情不是吗？”我说：“我想离开。”喵小姐问：“你想去哪里？”我说：“一个没有你的地方。”说完这句话我立马就后悔了，我赶紧起身去追喵小姐，不能让她跑了。</p>
<p>和喵小姐在一起的时候，我们相互向对方约定，不管在任何时候任何地方任何情况下，都不能说分手，哪怕是玩笑也不行。 我追上喵小姐的时候，她已经泪流满面了。</p>
<p>我发现我是如此在乎她。我一把抱住她，她努力想要挣脱，我就是不放手。她呜呜呜地哭了出来，用手打我的背，我说：“别哭了，别哭了，我错了还不行吗？” 喵小姐边擦眼泪边说：“我只想和你好好的，我不知道我哪里做错了。</p>
<p>我就想我们一起开个饭店，一起经营，你没事给我做回锅肉吃，不用出去上班，不用受别人的气，我不知道你为什么那么不情愿……” 我帮喵小姐擦去眼泪：“你哪里都没有做错，都是我不好，都是我不好……”</p>
<p>但我和喵小姐最后还是分手了。不是我离开她，是她离开了我。 那天晚上之后，我决定不管多难都要坚持下来，于是我又坚持了大半年。老板也不再从门缝里看我，并允许我叫她阿姨了，还把饭店一些更重要的事情交给我打理。</p>
<p>我内心也得以转变，之前那种“上门女婿”的感觉也渐渐消失殆尽，我给自己换了另一套说辞：“喵小姐家里给我提供了平台，我靠自己的努力争取到了一切。” 就在我意气风发兴致勃勃的时候，喵小姐却向我提出了分手。</p>
<p>我震惊地问她原因，我知道她不是开玩笑的。她说：“其实我妈从来没有喜欢过你，不管你做得再好她也不可能接受你。虽然我一直在努力，我知道你也一直在努力。”我突然不知道如何接她的话了，好像说什么都显得那么苍白和无力。</p>
<p>虽然她很爱我，但她并不是言情剧里的女生，不是我装着暖男的样子求她不要离开我她就会回头的。说来也有些奇怪和可耻，她和我提分手，我心里居然有一些如释重负的感觉。</p>
<p>只是还是很难过。 我和喵小姐分手的事儿她妈不知道，我和喵小姐也没有和她提过，我还是每天按时去饭店工作和上下班，喵小姐却出国了，没说是去留学还是去旅游。</p>
<p>我和喵小姐的妈妈则一直保持着上下级的关系，除了工作上的事儿之外，我们从来没有聊过任何关于喵小姐的话题。这样的状态一直保持了四个月，四个月后的一天，喵小姐她妈突然问我：“你对未来有什么打算？” 我恍惚了几秒，微笑起来：“我还真没有想过这个问题，如果没啥太大的变故的话，我想我应该会继续干下去吧。”</p>
<p>她倒是干脆，直击我命门，一点也不拖沓：“你和我女儿的事，我已经知道了，她现在去了国外，一时半会儿也回不来。</p>
<p>我以前看在她的面子上，也没说什么，但我可以明确地告诉你，不管怎样，我是无法接受你的，我想，你也应该很清楚了不是吗？现在摆在你面前的有两个选择，继续在现在的岗位上干下去，我很认可你的能力，我还有其他的公司和产业，你会有很好的前途，但前提是不能和我女儿有丝毫接触。要么我给你一笔钱，永远不要再出现在这座城市里。”</p>
<p>我无法理解她的思维，为何会提出两个这么极端的要求。不过不重要，我第二天就直接辞了职，并离开了这座城市。</p>
<p>在回成都的火车上，我打开手机，看着电话通讯录里喵小姐的号码，犹豫良久，最后还是点了删除。有些故事还没有讲完就算了吧，结果什么的也并不重要了。那个可爱的人儿，就埋在回忆里吧。</p>
<p>我喜欢吃川菜，因为我在四川出生和长大，吃川菜对于我这样的游子来说在精神上会带来归属感，让浮躁的心变得安静。</p>
<p>只是，和喵小姐分手以后，我再未吃过回锅肉，虽然那是我最喜欢的川菜之一。 这三年来，我换过好几份工作，从事的行业也有好几个，但一直心神不宁。也就是说，我不知道自己要什么。 最后，我还是选择开了一家饭店，只是规模很小。</p>
<p>只做川菜，我是主厨，但没有回锅肉这道菜。 当喵小姐出现在饭店的时候，我居然没有感到太惊讶。我们坐在饭桌上，相互看着对方，沉默了大概有两分钟，她突然噗嗤一声笑了出来。</p>
<p>我也笑了。 喵小姐说：“我不知道为什么还是对你念念不忘。”</p>
<p>我微笑：“或许是回忆太美，只是物是人非。”我眼睛看向了她无名指上戴着的钻戒。 喵小姐说：“其实，当时我妈挺喜欢你的，只是她觉得你还太固执太清高，需要一些改变和突破——说得直白点，就是你的思维太执拗和传统，如果想做一件大事，你得具有多面性。</p>
<p>我很不喜欢我妈用商人的角度来看你，但她和我说，她只有我这一个孩子，她不可能轻易把自己一辈子努力的事业和最心爱的宝贝交给一个不懂得变通的人。我离开以后，你并没有坚持下来，无论是对我们的爱情，还是那家我帮你从我妈妈那里争取到的饭店。”</p>
<p><img src="http://a.hiphotos.baidu.com/image/pic/item/35a85edf8db1cb1339ac2910d254564e93584bef.jpg" alt="图片发自简书App"></p>
<p>我静静地看着喵小姐，她的眼里流出了眼泪。 我把纸巾给她递过去，她抹了抹眼睛：“对不起，我失态了。” 我想说些什么，但还没开口，她就打断了我：“其实我跑这么远，只是想再吃一次你做的回锅肉。</p>
<p>自从那年你给我做了一份回锅肉后，我吃遍了上百家川菜店，都没有吃出你的味道。</p>
<p>所以，今天，你能再为我做一次吗？” 我点点头，进了后厨，开始准备做这道菜谱上没有的菜，也渐渐回忆起了当年回锅肉的味道。</p>
<p>热锅，倒油，煸香辣椒，我的眼泪缓缓流出。 一定是辣椒辣到了眼里，我想着。用手去擦，眼泪却怎么也擦不完。﻿</p>
<p><img src="http://b.hiphotos.baidu.com/image/pic/item/d788d43f8794a4c2dce5f32801f41bd5ac6e39ea.jpg" alt="图片发自简书App"></p>
]]></content>
      <categories>
        <category>小说</category>
      </categories>
      <tags>
        <tag>情感</tag>
        <tag>成长</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2020/03/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="正则表达式是什么"><a href="#正则表达式是什么" class="headerlink" title="正则表达式是什么"></a>正则表达式是什么</h3><blockquote>
<p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p>
<p>正则表达式语言由两种基本字符类型组成：原义（正常）<code>文本字符</code>和<code>元字符</code>。元字符使正则表达式具有处理能力。</p>
</blockquote>
<h3 id="常用元字符"><a href="#常用元字符" class="headerlink" title="常用元字符"></a>常用元字符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>元字符</th>
<th>做什么用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.</code></td>
<td>匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>匹配字母或数字或下划线或汉字</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>匹配任意的空白符，包括空格，制表符（Tab），换行符，中文全角空格等）</td>
</tr>
<tr>
<td><code>\d</code></td>
<td>匹配数字</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>匹配单词的开始或结束</td>
</tr>
<tr>
<td><code>^</code></td>
<td>匹配字符串的开始</td>
</tr>
<tr>
<td><code>$</code></td>
<td>匹配字符串的结束</td>
</tr>
</tbody>
</table>
</div>
<h3 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h3><blockquote>
<p>如果你想查找元字符本身的话，比如你查找 <code>.</code> ,或者 <code>*</code> ,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用 <code>\</code> 来取消这些字符的特殊意义。因此，你应该使用 <code>\.</code> 和 <code>\*</code> 。当然，要查找 <code>\</code> 本身，你也得用 <code>\\</code> .<br>例如： <code>deerchao\.net</code> 匹配 <strong>deerchao.net</strong>，<code>C:\\Windows</code> 匹配 <strong>C:\Windows</strong> 。</p>
</blockquote>
<h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><blockquote>
<p>你已经看过了前面的 <code>*</code> , <code>+</code> , <code>&#123;2&#125;</code> , <code>&#123;5,12&#125;</code> 这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如*,{5,12}等)</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>元字符</th>
<th>做什么用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td><code>+</code></td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td><code>?</code></td>
<td>重复零次或一次</td>
</tr>
<tr>
<td><code>&#123;n&#125;</code></td>
<td>重复n次</td>
</tr>
<tr>
<td><code>&#123;n,&#125;</code></td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td><code>&#123;n,m&#125;</code></td>
<td>重复n到m次</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>下面是一些重复的示例：<br><code>Windows\d+</code> 匹配Windows后面跟1个或更多数字<br><code>^\w+</code> 匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)</p>
</blockquote>
<h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><blockquote>
<p>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？<br>很简单，你只需要在方括号里列出它们就行了，像 <code>[aeiou]</code> 就匹配任何一个英文元音字母， <code>[.?!]</code> 匹配标点符号(.或?或!)。<br>我们也可以轻松地指定一个字符范围，像 <code>[0-9]</code> 代表的含意与 <code>\d</code> 就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于 <code>\w</code> （如果只考虑英文的话）。<br>下面是一个更复杂的表达式： <code>\(?0\d&#123;2&#125;[) -]?\d&#123;8&#125;</code> 。<br>这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})。</p>
</blockquote>
<h3 id="分支条件"><a href="#分支条件" class="headerlink" title="分支条件"></a>分支条件</h3><blockquote>
<p>正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。<br>示例： <code>0\d&#123;2&#125;-\d&#123;8&#125;|0\d&#123;3&#125;-\d&#123;7&#125;</code><br>这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。<br>示例： <code>\d&#123;5&#125;-\d&#123;4&#125;|\d&#123;5&#125;</code><br>这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个示例是因为它能说明一个问题：<strong>使用分枝条件时，要注意各个条件的顺序</strong>。如果你把它改成 <code>\d&#123;5&#125;|\d&#123;5&#125;-\d&#123;4&#125;</code> 的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。</p>
</blockquote>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><blockquote>
<p>重复单个字符，直接在字符后面加上限定符就行了。但如果想要重复多个字符，我们可以用小括号来指定 <strong>子表达式</strong>(也叫作<strong>分组</strong>)。<br><code>(\d&#123;1,3&#125;\.)&#123;3&#125;\d&#123;1,3&#125;</code> 是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它： <code>\d&#123;1,3&#125;</code>匹配1到3位的数字， <code>(\d&#123;1,3&#125;\.)&#123;3&#125;</code> 匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字 <code>(\d&#123;1,3&#125;)</code> 。<br>不幸的是，它也将匹配 <em>256.300.888.999</em> 这种不可能存在的IP地址。我们只能使用冗长的分组，选择，字符串来描述一个 <strong>正确的IP地址：</strong> <code>((2[0-4]\d|25[0-5]|[01]?\d\d?)\.)&#123;3&#125;(2[0-4]\d|25[0-5]|[01]?\d\d?)</code></p>
</blockquote>
<h3 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h3><blockquote>
<p>有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>元字符</th>
<th>做什么用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\W</code></td>
<td>匹配任意不是字母，数字，下划线，汉字的字符</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>匹配任意不是空白符的字符</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>匹配任意非数字的字符</td>
</tr>
<tr>
<td><code>\B</code></td>
<td>匹配不是单词开头或结束的位置</td>
</tr>
<tr>
<td><code>[^x]</code></td>
<td>匹配除了x以外的任意字符</td>
</tr>
<tr>
<td><code>[^aeiou]</code></td>
<td>匹配除了aeiou这几个字母以外的任意字符</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>示例： <code>\S+</code> 匹配不包含空白符的字符串。 <code>&lt;a[^&gt;]+&gt;</code> 匹配用尖括号括起来的以a开头的字符串。</p>
</blockquote>
<h3 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h3><blockquote>
<p>使用小括号指定一个子表达式后，<strong>匹配这个子表达式</strong> 的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个 <strong>组号</strong>，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。<br><strong>后向引用</strong> 用于重复搜索前面某个分组匹配的文本。<br>示例： <code>\b(\w+)\b\s+\1\b</code> 可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字 <code>\b(\w+)\b</code> ，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符<code>\s+</code>，最后是分组1中捕获的内容（也就是前面匹配的那个单词） <code>\1</code>。<br>你也可以自己指定子表达式的 <strong>组名</strong>.要指定一个子表达式的组名，请使用这样的语法： <code>(?&lt;Word&gt;\w+)</code> (或者把尖括号换成 <code>&#39;</code> 也行： <code>(?&#39;Word&#39;\w+))</code>,这样就把<code>\w+</code>的组名指定为 <strong>Word</strong> 了。要反向引用这个分组捕获的内容，你可以使用 <code>\k&lt;Word&gt;</code> ,所以上一个示例也可以写成这样： <code>\b(?&lt;Word&gt;\w+)\b\s+\k&lt;Word&gt;\b</code> 。</p>
</blockquote>
<h3 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h3><blockquote>
<p>接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为 <strong>零宽断言</strong>。<br><code>(?=exp)</code> 也叫 <strong>零宽度正预测先行断言</strong>，它断言自身出现的位置的后面能匹配表达式exp。比如<code>\b\w+(?=ing\b)</code>，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找 <em>I’m singing while you’re dancing.</em> 时，它会匹配 sing 和 danc 。<br><code>(?&lt;=exp)</code> 也叫 <strong>零宽度正回顾后发断言</strong> ，它断言自身出现的位置的前面能匹配表达式exp。比如 <code>(?&lt;=\bre)\w+\b</code> 会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找 <em>reading a book</em> 时，它匹配ading。<br>假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分： <code>((?&lt;=\d)\d&#123;3&#125;)+\b</code> ，用它对1234567890进行查找时结果是234567890。<br>下面这个示例同时使用了这两种断言： <code>(?&lt;=\s)\d+(?=\s)</code> 匹配以空白符间隔的数字( <strong>再次强调，不包括这些空白符</strong> )。</p>
</blockquote>
<h3 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h3><blockquote>
<p>前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词–它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：<br><code>\b\w*q[^u]\w*\b</code> 匹配 <em>包含后面不是字母u的字母q的单词</em> 。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为<sup><a href="#fn_u" id="reffn_u">u</a></sup>总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的<sup><a href="#fn_u" id="reffn_u">u</a></sup>将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的 <code>\w*\b</code> 将会匹配下一个单词，于是 <code>\b\w*q[^u]\w*\b</code>就能匹配整个Iraq fighting。<strong>负向零宽断言</strong> 能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题： <code>\b\w*q(?!u)\w*\b</code> 。<br><strong>零宽度负预测先行断言</strong>(?!exp)，断言此位置的后面不能匹配表达式exp。例如： <code>\d&#123;3&#125;(?!\d)</code> 匹配三位数字，而且这三位数字的后面不能是数字； <code>\b((?!abc)\w)+\b</code> 匹配不包含连续字符串abc的单词。<br>同理，我们可以用(?&lt;!exp),<strong>零宽度负回顾后发断言来断言</strong> 此位置的前面不能匹配表达式exp：(?&lt;![a-z])\d{7}匹配前面不是小写字母的七位数字。<br>一个更复杂的示例：<code>(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)</code> 匹配不包含属性的简单HTML标签内里的内容。<code>(?&lt;=&lt;(\w+)&gt;)</code> 指定了这样的 <strong>前缀</strong>：被尖括号括起来的单词(比如可能是<strong>)，然后是. <code>*</code> (任意的字符串),最后是一个 </strong>后缀<strong> <code>(?=&lt;\/\1&gt;)</code>。注意后缀里的 \/ ，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的 <code>(\w+)</code> 匹配的内容，这样如果前缀实际上是</strong>的话，后缀就是<strong>了。整个表达式匹配的是</strong>和<strong>之间的内容(再次提醒，不包括前缀和后缀本身)。</strong></p>
</blockquote>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><blockquote>
<p>小括号的另一种用途是通过语法(?#comment)来包含注释。例如：<code>2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)</code>。<br>要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：<br><code>(?&lt;=</code> # 断言要匹配的文本的前缀<br><code>&lt;(\w+)&gt;</code> # 查找尖括号括起来的字母或数字(即HTML/XML标签)<br><code>)</code> # 前缀结束<br><code>.*</code> # 匹配任意文本<br><code>(?=</code> # 断言要匹配的文本的后缀<br><code>&lt;\/\1&gt;</code> # 查找尖括号括起来的内容：前面是一个”/“，后面是先前捕获的标签<br><code>)</code> # 后缀结束</p>
</blockquote>
<h3 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h3><blockquote>
<p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配 <strong>尽可能多</strong> 的字符。以这个表达式为例： <code>a.*b</code> ，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为 <strong>贪婪匹配</strong>。<br>有时，我们更需要 <strong>懒惰匹配</strong>，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号 ? 。这样 <code>.*?</code> 就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。<br>示例： <code>a.*?b</code> 匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>语法</th>
<th>做什么用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*?</code></td>
<td>重复任意次，但尽可能少重复</td>
</tr>
<tr>
<td><code>+?</code></td>
<td>重复1次或更多次，但尽可能少重复</td>
</tr>
<tr>
<td><code>??</code></td>
<td>重复0次或1次，但尽可能少重复</td>
</tr>
<tr>
<td><code>&#123;n,m&#125;?</code></td>
<td>重复n到m次，但尽可能少重复</td>
</tr>
<tr>
<td><code>&#123;n,&#125;?</code></td>
<td>重复n次以上，但尽可能少重复</td>
</tr>
</tbody>
</table>
</div>
<h3 id="其他元字符"><a href="#其他元字符" class="headerlink" title="其他元字符"></a>其他元字符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>元字符</th>
<th>做什么用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\a</code></td>
<td>报警字符(打印它的效果是电脑嘀一声)</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>通常是单词分界位置，但如果在字符类里使用代表退格</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>制表符，Tab</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>回车</td>
</tr>
<tr>
<td><code>\v</code></td>
<td>竖向制表符</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>换页符</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>换行符</td>
</tr>
<tr>
<td><code>\e</code></td>
<td>Escape</td>
</tr>
<tr>
<td><code>\0nn</code></td>
<td>ASCII代码中八进制代码为nn的字符</td>
</tr>
<tr>
<td><code>\xnn</code></td>
<td>ASCII代码中十六进制代码为nn的字符</td>
</tr>
<tr>
<td><code>\unnnn</code></td>
<td>Unicode代码中十六进制代码为nnnn的字符</td>
</tr>
<tr>
<td><code>\cN</code></td>
<td>ASCII控制字符。比如\cC代表Ctrl+C</td>
</tr>
<tr>
<td><code>\A</code></td>
<td>字符串开头(类似^，但不受处理多行选项的影响)</td>
</tr>
<tr>
<td><code>\Z</code></td>
<td>字符串结尾或行尾(不受处理多行选项的影响)</td>
</tr>
<tr>
<td><code>\z</code></td>
<td>字符串结尾(类似$，但不受处理多行选项的影响)</td>
</tr>
<tr>
<td><code>\G</code></td>
<td>当前搜索的开头</td>
</tr>
<tr>
<td><code>\p&#123;name&#125;</code></td>
<td>Unicode中命名为name的字符类，例如\p{IsGreek}</td>
</tr>
<tr>
<td><code>(?&gt;exp)</code></td>
<td>贪婪子表达式</td>
</tr>
<tr>
<td><code>(?&lt;x&gt;-&lt;y&gt;exp)</code></td>
<td>平衡组</td>
</tr>
<tr>
<td><code>(?im-nsx:exp)</code></td>
<td>在子表达式exp中改变处理选项</td>
</tr>
<tr>
<td><code>(?im-nsx)</code></td>
<td>为表达式后面的部分改变处理选项</td>
</tr>
<tr>
<td>[1]</td>
<td>把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no</td>
</tr>
<tr>
<td><code>(?(exp)yes)</code></td>
<td>同上，只是使用空表达式作为no</td>
</tr>
<tr>
<td>[2]</td>
<td>如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no</td>
</tr>
<tr>
<td><code>(?(name)yes)</code></td>
<td>同上，只是使用空表达式作为no</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>[1]:<code>(?(exp)yes|no)</code></p>
<p>[2]:<code>(?(name)yes|no)</code></p>
</blockquote>
<h2 id="正则表达式常用实例"><a href="#正则表达式常用实例" class="headerlink" title="正则表达式常用实例"></a>正则表达式常用实例</h2><h3 id="账号-密码"><a href="#账号-密码" class="headerlink" title="账号/密码"></a>账号/密码</h3><figure class="highlight smalltalk"><table><tr><td class="code"><pre><code class="hljs smalltalk">帐号是否合法(字母开头，允许<span class="hljs-number">5</span><span class="hljs-number">-16</span>字节，允许字母数字下划线) = <span class="hljs-comment">&quot;^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$&quot;</span><br>密码(以字母开头，长度在<span class="hljs-number">6</span>~<span class="hljs-number">18</span>之间，只能包含字母、数字和下划线) = <span class="hljs-comment">&quot;^[a-zA-Z]\w&#123;5,17&#125;$&quot;</span><br>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在<span class="hljs-number">8</span><span class="hljs-number">-10</span>之间) = <span class="hljs-comment">&quot;^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$&quot;</span><br><br></code></pre></td></tr></table></figure>
<h3 id="字符串校验"><a href="#字符串校验" class="headerlink" title="字符串校验"></a>字符串校验</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell">汉字 = <span class="hljs-string">&quot;^[\u4e00-\u9fa5]&#123;0,&#125;<span class="hljs-variable">$</span>&quot;</span>;<br>英文和数字 = <span class="hljs-string">&quot;^[A-Za-z0-9]+<span class="hljs-variable">$</span> 或 ^[A-Za-z0-9]&#123;4,40&#125;<span class="hljs-variable">$</span>&quot;</span>;<br>长度为<span class="hljs-number">3</span><span class="hljs-literal">-20</span>的所有字符 = <span class="hljs-string">&quot;^.&#123;3,20&#125;<span class="hljs-variable">$</span>&quot;</span>；<br>由<span class="hljs-number">26</span>个英文字母组成的字符串 = <span class="hljs-string">&quot;^[A-Za-z]+<span class="hljs-variable">$</span>&quot;</span>；<br>由<span class="hljs-number">26</span>个大写英文字母组成的字符串 = <span class="hljs-string">&quot;^[A-Z]+<span class="hljs-variable">$</span>&quot;</span>；<br>由<span class="hljs-number">26</span>个小写英文字母组成的字符串 = <span class="hljs-string">&quot;^[a-z]+<span class="hljs-variable">$</span>&quot;</span>；<br>由数字和<span class="hljs-number">26</span>个英文字母组成的字符串 = <span class="hljs-string">&quot;^[A-Za-z0-9]+<span class="hljs-variable">$</span>&quot;</span>；<br>由数字、<span class="hljs-number">26</span>个英文字母或者下划线组成的字符串 = <span class="hljs-string">&quot;^\w+<span class="hljs-variable">$</span> 或 ^\w&#123;3,20&#125;<span class="hljs-variable">$</span>&quot;</span>；<br>中文、英文、数字包括下划线 = <span class="hljs-string">&quot;^[\u4E00-\u9FA5A-Za-z0-9_]+<span class="hljs-variable">$</span>&quot;</span>；<br>中文、英文、数字但不包括下划线等符号 = <span class="hljs-string">&quot;^[\u4E00-\u9FA5A-Za-z0-9]+<span class="hljs-variable">$</span> 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;<span class="hljs-variable">$</span>&quot;</span>；<br>禁止输入含有~的字符 = <span class="hljs-string">&quot;[^~\x22]+&quot;</span>；<br><br></code></pre></td></tr></table></figure>
<h3 id="手机号"><a href="#手机号" class="headerlink" title="手机号"></a>手机号</h3><figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">/**<br> * 手机号码  新增的号段自己看着添加<br> * 移动：<span class="hljs-number">134,135,136,137</span>,<span class="hljs-number">138,139,147,150</span>,<span class="hljs-number">151,152,157,158</span>,<span class="hljs-number">159,170,178,182</span>,<span class="hljs-number">183,184,187,188</span><br> * 联通：<span class="hljs-number">130,131,132,145</span>,<span class="hljs-number">152,155,156</span>,<span class="hljs-number">1709,171,176</span>,<span class="hljs-number">185,186</span><br> * 电信：<span class="hljs-number">133,134,153</span>,<span class="hljs-number">1700,177,180</span>,<span class="hljs-number">181,189</span><br> */<br>String MOBILE = &quot;^<span class="hljs-number">1(3[0-9</span>]|<span class="hljs-number">4</span>[<span class="hljs-number">57</span>]|<span class="hljs-number">5[0-35-9</span>]|<span class="hljs-number">7[01678</span>]|<span class="hljs-number">8</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>])\\d&#123;<span class="hljs-number">8</span>&#125;$&quot;<span class="hljs-comment">;</span><br>/**<br> * 中国移动：China Mobile<br> * <span class="hljs-number">134,135,136,137</span>,<span class="hljs-number">138,139,147,150</span>,<span class="hljs-number">151,152,157,158</span>,<span class="hljs-number">159,170,178,182</span>,<span class="hljs-number">183,184,187,188</span><br> */<br>String CM = &quot;^<span class="hljs-number">1(3[4-9</span>]|<span class="hljs-number">4</span>[<span class="hljs-number">7</span>]|<span class="hljs-number">5[0-27-9</span>]|<span class="hljs-number">7</span>[<span class="hljs-number">0</span>]|<span class="hljs-number">7</span>[<span class="hljs-number">8</span>]|<span class="hljs-number">8[2-478</span>])\\d&#123;<span class="hljs-number">8</span>&#125;$&quot;<span class="hljs-comment">;</span><br>/**<br> * 中国联通：China Unicom<br> * <span class="hljs-number">130,131,132,145</span>,<span class="hljs-number">152,155,156</span>,<span class="hljs-number">1709,171,176</span>,<span class="hljs-number">185,186</span><br> */<br>String CU = &quot;^<span class="hljs-number">1(3[0-2</span>]|<span class="hljs-number">4</span>[<span class="hljs-number">5</span>]|<span class="hljs-number">5</span>[<span class="hljs-number">56</span>]|<span class="hljs-number">709|7[1</span>]|<span class="hljs-number">7</span>[<span class="hljs-number">6</span>]|<span class="hljs-number">8</span>[<span class="hljs-number">56</span>])\\d&#123;<span class="hljs-number">8</span>&#125;$&quot;<span class="hljs-comment">;</span><br>/**<br> * 中国电信：China Telecom<br> * <span class="hljs-number">133,134,153</span>,<span class="hljs-number">1700,177,180</span>,<span class="hljs-number">181,189</span><br> */<br>String CT = &quot;^<span class="hljs-number">1</span>(<span class="hljs-number">3</span>[<span class="hljs-number">34</span>]|<span class="hljs-number">53|77|700</span>|<span class="hljs-number">8</span>[<span class="hljs-number">019</span>])\\d&#123;<span class="hljs-number">8</span>&#125;$&quot;<span class="hljs-comment">;</span><br><br></code></pre></td></tr></table></figure>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><figure class="highlight taggerscript"><table><tr><td class="code"><pre><code class="hljs taggerscript">String IPREGEXP = &quot;((2[0-4]<span class="hljs-symbol">\d</span>|25[0-5]|[01]?<span class="hljs-symbol">\d</span><span class="hljs-symbol">\d</span>?)<span class="hljs-symbol">\.</span>)&#123;3&#125;(2[0-4]<span class="hljs-symbol">\d</span>|25[0-5]|[01]?<span class="hljs-symbol">\d</span><span class="hljs-symbol">\d</span>?)&quot;;<br><br></code></pre></td></tr></table></figure>
<h3 id="EMAIL地址"><a href="#EMAIL地址" class="headerlink" title="EMAIL地址"></a>EMAIL地址</h3><figure class="highlight taggerscript"><table><tr><td class="code"><pre><code class="hljs taggerscript">Email地址 = &quot;^<span class="hljs-symbol">\w</span>+([-+.]<span class="hljs-symbol">\w</span>+)*@<span class="hljs-symbol">\w</span>+([-.]<span class="hljs-symbol">\w</span>+)*<span class="hljs-symbol">\.</span><span class="hljs-symbol">\w</span>+([-.]<span class="hljs-symbol">\w</span>+)*$&quot;;<br><br></code></pre></td></tr></table></figure>
<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">域名 = <span class="hljs-string">&quot;<span class="hljs-subst">[a-zA-Z0-9]</span><span class="hljs-subst">[-a-zA-Z0-9]</span>&#123;0,62&#125;(/.<span class="hljs-subst">[a-zA-Z0-9]</span><span class="hljs-subst">[-a-zA-Z0-9]</span>&#123;0,62&#125;)+/.?&quot;</span>;<br>InternetURL = <span class="hljs-string">&quot;<span class="hljs-subst">[a-zA-z]</span>+://<span class="hljs-subst">[^\s]</span>* 或 ^http://(<span class="hljs-subst">[\w-]</span>+\.)+<span class="hljs-subst">[\w-]</span>+(/<span class="hljs-subst">[\w-./?%&amp;=]</span>*)?$&quot;</span><br><br></code></pre></td></tr></table></figure>
<h3 id="身份证"><a href="#身份证" class="headerlink" title="身份证"></a>身份证</h3><figure class="highlight dust"><table><tr><td class="code"><pre><code class="hljs dust"><span class="xml">身份证号(15位、18位数字) = &quot;^\d</span><span class="hljs-template-variable">&#123;15&#125;</span><span class="xml">|\d</span><span class="hljs-template-variable">&#123;18&#125;</span><span class="xml">$&quot;</span><br><span class="xml">短身份证号码(数字、字母x结尾) = &quot;^([0-9])</span><span class="hljs-template-variable">&#123;7,18&#125;</span><span class="xml">(x|X)?$ 或 ^\d</span><span class="hljs-template-variable">&#123;8,18&#125;</span><span class="xml">|[0-9x]</span><span class="hljs-template-variable">&#123;8,18&#125;</span><span class="xml">|[0-9X]</span><span class="hljs-template-variable">&#123;8,18&#125;</span><span class="xml">?$&quot;</span><br><br></code></pre></td></tr></table></figure>
<h3 id="数字类校验"><a href="#数字类校验" class="headerlink" title="数字类校验"></a>数字类校验</h3><p><code>数字 = &quot;^[0-9]*$&quot;;
n位的数字 = &quot;^\d&#123;n&#125;$&quot;;
至少n位的数字 = &quot;^\d&#123;n,&#125;$&quot;;
m-n位的数字 = &quot;^\d&#123;m,n&#125;$&quot;;
零和非零开头的数字 = &quot;^(0|[1-9][0-9]*)$&quot;;
非零开头的最多带两位小数的数字 = &quot;^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$&quot;;
带1-2位小数的正数或负数 = &quot;^(\-)?\d+(\.\d&#123;1,2&#125;)?$&quot;;
正数、负数、和小数 = &quot;^(\-|\+)?\d+(\.\d+)?$&quot;;
有两位小数的正实数 = &quot;^[0-9]+(.[0-9]&#123;2&#125;)?$&quot;;
有1~3位小数的正实数 = &quot;^[0-9]+(.[0-9]&#123;1,3&#125;)?$&quot;;
非零的正整数 = &quot;^[1-9]\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\+?[1-9][0-9]*$&quot;;
非零的负整数 = &quot;^\-[1-9][]0-9&quot;*$&quot; 或 &quot;^-[1-9]\d*$&quot;;</code>**</p>
]]></content>
      <categories>
        <category>日常开发</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>OS代码块Block</title>
    <url>/2017/11/24/My-Block/</url>
    <content><![CDATA[<p>概述<br><img src="/img/qw.jpg" alt=""><br>代码块Block是苹果在iOS4开始引入的对C语言的扩展,用来实现匿名函数的特性,Block是一种特殊的数据类型,其可以正常定义变量、作为参数、作为返回值,特殊地,Block还可以保存一段代码,在需要的时候调用,目前Block已经广泛应用于iOS开发中,常用于GCD、动画、排序及各类回调</p>
<p>注: Block的声明与赋值只是保存了一段代码段,必须调用才能执行内部代码<br>Block变量的声明、赋值与调用</p>
<p>Block变量的声明</p>
<p>Block变量的声明格式为: 返回值类型(^Block名字)(参数列表);</p>
<p>// 声明一个无返回值,参数为两个字符串对象,叫做aBlock的Block<br><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs Objective-c">void(^aBlock)(NSString *x, NSString *y);<br><br></code></pre></td></tr></table></figure><br>// 形参变量名称可以省略,只留有变量类型即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs Objective-c">void(^aBlock)(NSString *, NSString *);<br></code></pre></td></tr></table></figure>
<p>注: ^被称作”脱字符”<br>Block变量的赋值</p>
<p>Block变量的赋值格式为: Block变量 = ^(参数列表){函数体};<br><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs Objective-c">aBlock &#x3D; ^(NSString *x, NSString *y)&#123;<br>NSLog(@&quot;%@ love %@&quot;, x, y);<br>&#125;;<br></code></pre></td></tr></table></figure><br>注: Block变量的赋值格式可以是: Block变量 = ^返回值类型(参数列表){函数体};,不过通常情况下都将返回值类型省略,因为编译器可以从存储代码块的变量中确定返回值的类型<br>声明Block变量的同时进行赋值<br><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs Objective-c"><br></code></pre></td></tr></table></figure><br>int(^myBlock)(int) = ^(int num){<br>return num * 7;<br>};</p>
<p>// 如果没有参数列表,在赋值时参数列表可以省略</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs Objective-c">void(^aVoidBlock)() &#x3D; ^&#123;<br>NSLog(@&quot;I am a aVoidBlock&quot;);<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>Block变量的调用</p>
<p>// 调用后控制台输出”Li Lei love Han Meimei”<br><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs Objective-c">aBlock(@&quot;Li Lei&quot;,@&quot;Han Meimei&quot;);<br></code></pre></td></tr></table></figure><br>// 调用后控制台输出”result = 63”<br>NSLog(@”result = %d”, myBlock(9));</p>
<p>// 调用后控制台输出”I am a aVoidBlock”<br>aVoidBlock();<br>使用typedef定义Block类型</p>
<p>在实际使用Block的过程中,我们可能需要重复地声明多个相同返回值相同参数列表的Block变量,如果总是重复地编写一长串代码来声明变量会非常繁琐,所以我们可以使用typedef来定义Block类型</p>
<p>// 定义一种无返回值无参数列表的Block类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs Objective-c">typedef void(^SayHello)();<br></code></pre></td></tr></table></figure>
<p>// 我们可以像OC中声明变量一样使用Block类型SayHello来声明变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs Objective-c">SayHello hello &#x3D; ^()&#123;<br>NSLog(@&quot;hello&quot;);<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>// 调用后控制台输出”hello”<br>hello();<br>Block作为函数参数</p>
<p>Block作为C函数参数</p>
<p>// 1.定义一个形参为Block的C函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs Objective-c">void useBlockForC(int(^aBlock)(int, int))<br>&#123;<br>NSLog(@&quot;result &#x3D; %d&quot;, aBlock(300,200));<br>&#125;<br></code></pre></td></tr></table></figure><br>// 2.声明并赋值定义一个Block变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs Objective-c">int(^addBlock)(int, int) &#x3D; ^(int x, int y)&#123;<br>return x+y;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure>
<p>// 3.以Block作为函数参数,把Block像对象一样传递<br>useBlockForC(addBlock);</p>
<p>// 将第2点和第3点合并一起,以内联定义的Block作为函数参数</p>
<p>Block作为OC函数参数<br><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs Objective-c">useBlockForC(^(int x, int y) &#123;<br>return x+y;<br>&#125;);<br></code></pre></td></tr></table></figure><br>// 1.定义一个形参为Block的OC函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs Objective-c">- (void)useBlockForOC:(int(^)(int, int))aBlock<br>&#123;<br>NSLog(@&quot;result &#x3D; %d&quot;, aBlock(300,200));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>// 2.声明并赋值定义一个Block变量<br>int(^addBlock)(int, int) = ^(int x, int y){<br>return x+y;<br>};<br><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs Objective-c"><br></code></pre></td></tr></table></figure><br>// 3.以Block作为函数参数,把Block像对象一样传递<br>[self useBlockForOC:addBlock];</p>
<p>// 将第2点和第3点合并一起,以内联定义的Block作为函数参数<br>[self useBlockForOC:^(int x, int y){<br>return x+y;<br>}];<br>使用typedef简化Block</p>
<p>// 1.使用typedef定义Block类型<br>typedef int(^MyBlock)(int, int);</p>
<p>// 2.定义一个形参为Block的OC函数</p>
<ul>
<li>(void)useBlockForOC:(MyBlock)aBlock<br>{<br>NSLog(@”result = %d”, aBlock(300,200));<br>}</li>
</ul>
<p>// 3.声明并赋值定义一个Block变量<br>MyBlock addBlock = ^(int x, int y){<br>return x+y;<br>};</p>
<p>// 4.以Block作为函数参数,把Block像对象一样传递<br>[self useBlockForOC:addBlock];</p>
<p>// 将第3点和第4点合并一起,以内联定义的Block作为函数参数<br>[self useBlockForOC:^(int x, int y){<br>return x+y;<br>}];<br>Block内访问局部变量</p>
<p>在Block中可以访问局部变量<br>// 声明局部变量global<br>int global = 100;</p>
<p>void(^myBlock)() = ^{<br>NSLog(@”global = %d”, global);<br>};<br>// 调用后控制台输出”global = 100”<br>myBlock();<br>在声明Block之后、调用Block之前对局部变量进行修改,在调用Block时局部变量值是修改之前的旧值<br>// 声明局部变量global<br>int global = 100;</p>
<p>void(^myBlock)() = ^{<br>NSLog(@”global = %d”, global);<br>};<br>global = 101;<br>// 调用后控制台输出”global = 100”<br>myBlock();<br>在Block中不可以直接修改局部变量<br>// 声明局部变量global<br>int global = 100;</p>
<p>void(^myBlock)() = ^{<br>global ++; // 这句报错<br>NSLog(@”global = %d”, global);<br>};<br>// 调用后控制台输出”global = 100”<br>myBlock();<br>注: 原理解析,通过clang命令将OC转为C++代码来查看一下Block底层实现,clang命令使用方式为终端使用cd定位到main.m文件所在文件夹,然后利用clang -rewrite-objc main.m将OC转为C++,成功后在main.m同目录下会生成一个main.cpp文件<br>// OC代码如下<br>void(^myBlock)() = ^{<br>NSLog(@”global = %d”, global);<br>};<br><img src="/img/qinglv.jpg" alt=""><br>// 转为C++代码如下<br>void(<em>myBlock)() = ((void (</em>)())&amp;<strong>main_block_impl_0((void *)</strong>main_block_func_0, &amp;__main_block_desc_0_DATA, global));</p>
<p>// 将变量类型精简之后C++代码如下,我们发现Block变量实际上就是一个指向结构体<strong>main_block_impl_0的指针,而结构体的第三个元素是局部变量global的值<br>void(*myBlock)() = &amp;</strong>main_block_impl_0(<strong>main_block_func_0, &amp;</strong>main_block_desc_0_DATA, global);</p>
<p>// 我们看一下结构体__main_block_impl_0的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs Objective-c">struct __main_block_impl_0 &#123;<br>struct __block_impl impl;<br>struct __main_block_desc_0* Desc;<br>int global;<br>__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _global, int flags&#x3D;0) : global(_global) &#123;<br>impl.isa &#x3D; &amp;_NSConcreteStackBlock;<br>impl.Flags &#x3D; flags;<br>impl.FuncPtr &#x3D; fp;<br>Desc &#x3D; desc;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><img src="/img/qinglv.jpg" alt=""><br>// 在OC中调用Block的方法转为C++代码如下,实际上是指向结构体的指针myBlock访问其FuncPtr元素,在定义Block时为FuncPtr元素传进去的<strong>main_block_func_0方法<br>((void (*)(</strong>block_impl <em>))((__block_impl </em>)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</p>
<p>// <strong>main_block_func_0方法代码如下,由此可见NSLog的global正是定义Block时为结构体传进去的局部变量global的值<br>static void </strong>main_block_func_0(struct <strong>main_block_impl_0 *</strong>cself) {<br>int global = <strong>cself-&gt;global; // bound by copy<br>NSLog((NSString *)&amp;</strong>NSConstantStringImpl__var_folders_6y_vkd9wnv13pz6lc_h8phss0jw0000gn_T_main_d5d9eb_mi_0, global);<br>}</p>
<p>// 由此可知,在Block定义时便是将局部变量的值传给Block变量所指向的结构体,因此在调用Block之前对局部变量进行修改并不会影响Block内部的值,同时内部的值也是不可修改的<br>Block内访问__block修饰的局部变量</p>
<p>在局部变量前使用下划线下划线block修饰,在声明Block之后、调用Block之前对局部变量进行修改,在调用Block时局部变量值是修改之后的新值<br>// 声明局部变量global<br>__block int global = 100;</p>
<p>void(^myBlock)() = ^{<br>NSLog(@”global = %d”, global);<br>};<br>global = 101;<br>// 调用后控制台输出”global = 101”<br>myBlock();<br>在局部变量前使用下划线下划线block修饰,在Block中可以直接修改局部变量<br>// 声明局部变量global<br>__block int global = 100;</p>
<p>void(^myBlock)() = ^{<br>global ++; // 这句正确<br>NSLog(@”global = %d”, global);<br>};<br>// 调用后控制台输出”global = 101”<br>myBlock();<br>注: 原理解析,通过clang命令将OC转为C++代码来查看一下Block底层实现<br>// OC代码如下<br>void(^myBlock)() = ^{<br>NSLog(@”global = %d”, global);<br>};</p>
<p>// 转为C++代码如下<br>void(<em>myBlock)() = ((void (</em>)())&amp;<strong>main_block_impl_0((void *)</strong>main_block_func_0, &amp;<strong>main_block_desc_0_DATA, (</strong>Block_byref_global_0 *)&amp;global, 570425344));</p>
<p>// 将变量类型精简之后C++代码如下,我们发现Block变量实际上就是一个指向结构体<strong>main_block_impl_0的指针,而结构体的第三个元素是局部变量global的指针<br>void(*myBlock)() = &amp;</strong>main_block_impl_0(<strong>main_block_func_0, &amp;</strong>main_block_desc_0_DATA, &amp;global, 570425344);</p>
<p>// 由此可知,在局部变量前使用__block修饰,在Block定义时便是将局部变量的指针传给Block变量所指向的结构体,因此在调用Block之前对局部变量进行修改会影响Block内部的值,同时内部的值也是可以修改的<br>Block内访问全局变量</p>
<p>在Block中可以访问全局变量<br>// 声明全局变量global<br>int global = 100;</p>
<p>void(^myBlock)() = ^{<br>NSLog(@”global = %d”, global);<br>};<br>// 调用后控制台输出”global = 100”<br>myBlock();<br>在声明Block之后、调用Block之前对全局变量进行修改,在调用Block时全局变量值是修改之后的新值<br>// 声明全局变量global<br>int global = 100;</p>
<p>void(^myBlock)() = ^{<br>NSLog(@”global = %d”, global);<br>};<br>global = 101;<br>// 调用后控制台输出”global = 101”<br>myBlock();<br>在Block中可以直接修改全局变量<br>// 声明全局变量global<br>int global = 100;</p>
<p>void(^myBlock)() = ^{<br>global ++;<br>NSLog(@”global = %d”, global);<br>};<br>// 调用后控制台输出”global = 101”<br>myBlock();<br>注: 原理解析,通过clang命令将OC转为C++代码来查看一下Block底层实现<br>// OC代码如下<br>void(^myBlock)() = ^{<br>NSLog(@”global = %d”, global);<br>};</p>
<p>// 转为C++代码如下<br>void(<em>myBlock)() = ((void (</em>)())&amp;<strong>main_block_impl_0((void *)</strong>main_block_func_0, &amp;__main_block_desc_0_DATA));</p>
<p>// 将变量类型精简之后C++代码如下,我们发现Block变量实际上就是一个指向结构体<strong>main_block_impl_0的指针,而结构体中并未保存全局变量global的值或者指针<br>void(*myBlock)() = &amp;</strong>main_block_impl_0(<strong>main_block_func_0, &amp;</strong>main_block_desc_0_DATA);</p>
<p>// 我们看一下结构体<strong>main_block_impl_0的代码<br>struct </strong>main_block_impl_0 {<br>struct <strong>block_impl impl;<br>struct </strong>main_block_desc_0<em> Desc;<br>__main_block_impl_0(void </em>fp, struct __main_block_desc_0 *desc, int flags=0) {<br>impl.isa = &amp;_NSConcreteStackBlock;<br>impl.Flags = flags;<br>impl.FuncPtr = fp;<br>Desc = desc;<br>}<br>};</p>
<p>// 在OC中调用Block的方法转为C++代码如下,实际上是指向结构体的指针myBlock访问其FuncPtr元素,在定义Block时为FuncPtr元素传进去的<strong>main_block_func_0方法<br>((void (*)(</strong>block_impl <em>))((__block_impl </em>)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</p>
<p>// <strong>main_block_func_0方法代码如下,由此可见NSLog的global还是全局变量global的值<br>static void </strong>main_block_func_0(struct <strong>main_block_impl_0 *</strong>cself) {<br>NSLog((NSString *)&amp;<strong>NSConstantStringImpl</strong>var_folders_6y_vkd9wnv13pz6lc_h8phss0jw0000gn_T_main_f35954_mi_0, global);<br>}</p>
<p>// 由此可知,全局变量所占用的内存只有一份,供所有函数共同调用,在Block定义时并未将全局变量的值或者指针传给Block变量所指向的结构体,因此在调用Block之前对局部变量进行修改会影响Block内部的值,同时内部的值也是可以修改的<br>Block内访问静态变量<br><img src="/img/qw.jpg" alt=""><br>在Block中可以访问静态变量<br>// 声明静态变量global<br>static int global = 100;</p>
<p>void(^myBlock)() = ^{<br>NSLog(@”global = %d”, global);<br>};<br>// 调用后控制台输出”global = 100”<br>myBlock();<br>在声明Block之后、调用Block之前对静态变量进行修改,在调用Block时静态变量值是修改之后的新值<br>// 声明静态变量global<br>static int global = 100;</p>
<p>void(^myBlock)() = ^{<br>NSLog(@”global = %d”, global);<br>};<br>global = 101;<br>// 调用后控制台输出”global = 101”<br>myBlock();<br>在Block中可以直接修改静态变量<br>// 声明静态变量global<br>static int global = 100;</p>
<p>void(^myBlock)() = ^{<br>global ++;<br>NSLog(@”global = %d”, global);<br>};<br>// 调用后控制台输出”global = 101”<br>myBlock();<br>注: 原理解析,通过clang命令将OC转为C++代码来查看一下Block底层实现<br>// OC代码如下<br>void(^myBlock)() = ^{<br>NSLog(@”global = %d”, global);<br>};</p>
<p>// 转为C++代码如下<br>void(<em>myBlock)() = ((void (</em>)())&amp;<strong>main_block_impl_0((void *)</strong>main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;global));</p>
<p>// 将变量类型精简之后C++代码如下,我们发现Block变量实际上就是一个指向结构体<strong>main_block_impl_0的指针,而结构体的第三个元素是静态变量global的指针<br>void(*myBlock)() = &amp;</strong>main_block_impl_0(<strong>main_block_func_0, &amp;</strong>main_block_desc_0_DATA, &amp;global);</p>
<p>// 我们看一下结构体<strong>main_block_impl_0的代码<br>struct </strong>main_block_impl_0 {<br>struct <strong>block_impl impl;<br>struct </strong>main_block_desc_0<em> Desc;<br>int </em>global;<br><strong>main_block_impl_0(void *fp, struct </strong>main_block_desc_0 <em>desc, int </em>_global, int flags=0) : global(_global) {<br>impl.isa = &amp;_NSConcreteStackBlock;<br>impl.Flags = flags;<br>impl.FuncPtr = fp;<br>Desc = desc;<br>}<br>};</p>
<p>// 在OC中调用Block的方法转为C++代码如下,实际上是指向结构体的指针myBlock访问其FuncPtr元素,在定义Block时为FuncPtr元素传进去的<strong>main_block_func_0方法<br>((void (*)(</strong>block_impl <em>))((__block_impl </em>)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</p>
<p>// <strong>main_block_func_0方法代码如下,由此可见NSLog的global正是定义Block时为结构体传进去的静态变量global的指针<br>static void </strong>main_block_func_0(struct <strong>main_block_impl_0 *</strong>cself) {<br>int <em>global = __cself-&gt;global; // bound by copy<br>NSLog((NSString </em>)&amp;<strong>NSConstantStringImpl</strong>var_folders_6y_vkd9wnv13pz6lc_h8phss0jw0000gn_T_main_4d124d_mi_0, (*global));<br>}</p>
<p>// 由此可知,在Block定义时便是将静态变量的指针传给Block变量所指向的结构体,因此在调用Block之前对静态变量进行修改会影响Block内部的值,同时内部的值也是可以修改的<br>Block在MRC及ARC下的内存管理</p>
<p>Block在MRC下的内存管理</p>
<p>默认情况下,Block的内存存储在栈中,不需要开发人员对其进行内存管理<br>// 当Block变量出了作用域,Block的内存会被自动释放<br>void(^myBlock)() = ^{<br>NSLog(@”———“);<br>};<br>myBlock();<br>在Block的内存存储在栈中时,如果在Block中引用了外面的对象,不会对所引用的对象进行任何操作<br>Person *p = [[Person alloc] init];</p>
<p>void(^myBlock)() = ^{<br>NSLog(@”———%@”, p);<br>};<br>myBlock();</p>
<p>[p release]; // Person对象在这里可以正常被释放<br>如果对Block进行一次copy操作,那么Block的内存会被移动到堆中,这时需要开发人员对其进行release操作来管理内存<br>void(^myBlock)() = ^{<br>NSLog(@”———“);<br>};<br>myBlock();</p>
<p>Block_copy(myBlock);</p>
<p>// do something …</p>
<p>Block_release(myBlock);<br>如果对Block进行一次copy操作,那么Block的内存会被移动到堆中,在Block的内存存储在堆中时,如果在Block中引用了外面的对象,会对所引用的对象进行一次retain操作,即使在Block自身调用了release操作之后,Block也不会对所引用的对象进行一次release操作,这时会造成内存泄漏<br>Person *p = [[Person alloc] init];</p>
<p>void(^myBlock)() = ^{<br>NSLog(@”———%@”, p);<br>};<br>myBlock();</p>
<p>Block_copy(myBlock);</p>
<p>// do something …</p>
<p>Block_release(myBlock);</p>
<p>[p release]; // Person对象在这里无法正常被释放,因为其在Block中被进行了一次retain操作<br>如果对Block进行一次copy操作,那么Block的内存会被移动到堆中,在Block的内存存储在堆中时,如果在Block中引用了外面的对象,会对所引用的对象进行一次retain操作,为了不对所引用的对象进行一次retain操作,可以在对象的前面使用下划线下划线block来修饰<br>__block Person *p = [[Person alloc] init];</p>
<p>void(^myBlock)() = ^{<br>NSLog(@”———%@”, p);<br>};<br>myBlock();</p>
<p>Block_copy(myBlock);</p>
<p>// do something …</p>
<p>Block_release(myBlock);</p>
<p>[p release]; // Person对象在这里可以正常被释放<br>如果对象内部有一个Block属性,而在Block内部又访问了该对象,那么会造成循环引用<br>情况一</p>
<p>@interface Person : NSObject</p>
<p>@property (nonatomic, copy) void(^myBlock)();</p>
<p>@end</p>
<p>@implementation Person</p>
<ul>
<li>(void)dealloc<br>{<br>NSLog(@”Person dealloc”);</li>
</ul>
<p>Block_release(_myBlock);<br>[super dealloc];<br>}</p>
<p>@end</p>
<p>Person *p = [[Person alloc] init];</p>
<p>p.myBlock = ^{<br>NSLog(@”———%@”, p);<br>};<br>p.myBlock();</p>
<p>[p release]; // 因为myBlock作为Person的属性,采用copy修饰符修饰(这样才能保证Block在堆里面,以免Block在栈中被系统释放),所以Block会对Person对象进行一次retain操作,导致循环引用无法释放<br>情况二</p>
<p>@interface Person : NSObject</p>
<p>@property (nonatomic, copy) void(^myBlock)();</p>
<ul>
<li>(void)resetBlock;</li>
</ul>
<p>@end</p>
<p>@implementation Person</p>
<ul>
<li><p>(void)resetBlock<br>{<br>self.myBlock = ^{<br>NSLog(@”———%@”, self);<br>};<br>}</p>
</li>
<li><p>(void)dealloc<br>{<br>NSLog(@”Person dealloc”);</p>
</li>
</ul>
<p>Block_release(_myBlock);</p>
<p>[super dealloc];<br>}</p>
<p>@end</p>
<p>Person *p = [[Person alloc] init];<br>[p resetBlock];<br>[p release]; // Person对象在这里无法正常释放,虽然表面看起来一个alloc对应一个release符合内存管理规则,但是实际在resetBlock方法实现中,Block内部对self进行了一次retain操作,导致循环引用无法释放<br>如果对象内部有一个Block属性,而在Block内部又访问了该对象,那么会造成循环引用,解决循环引用的办法是在对象的前面使用下划线下划线block来修饰,以避免Block对对象进行retain操作<br>情况一</p>
<p>@interface Person : NSObject</p>
<p>@property (nonatomic, copy) void(^myBlock)();</p>
<p>@end</p>
<p>@implementation Person</p>
<ul>
<li>(void)dealloc<br>{<br>NSLog(@”Person dealloc”);</li>
</ul>
<p>Block_release(_myBlock);<br>[super dealloc];<br>}</p>
<p>@end</p>
<p>__block Person *p = [[Person alloc] init];</p>
<p>p.myBlock = ^{<br>NSLog(@”———%@”, p);<br>};<br>p.myBlock();</p>
<p>[p release]; // Person对象在这里可以正常被释放<br>情况二</p>
<p>@interface Person : NSObject</p>
<p>@property (nonatomic, copy) void(^myBlock)();</p>
<ul>
<li>(void)resetBlock;</li>
</ul>
<p>@end</p>
<p>@implementation Person</p>
<ul>
<li><p>(void)resetBlock<br>{<br>// 这里为了通用一点,可以使用<strong>block typeof(self) p = self;
</strong>block Person *p = self;<br>self.myBlock = ^{<br>NSLog(@”———%@”, p);<br>};<br>}</p>
</li>
<li><p>(void)dealloc<br>{<br>NSLog(@”Person dealloc”);</p>
</li>
</ul>
<p>Block_release(_myBlock);</p>
<p>[super dealloc];<br>}</p>
<p>@end</p>
<p>Person *p = [[Person alloc] init];<br>[p resetBlock];<br>[p release]; // Person对象在这里可以正常被释放<br>Block在ARC下的内存管理</p>
<p>在ARC默认情况下,Block的内存存储在堆中,ARC会自动进行内存管理,程序员只需要避免循环引用即可<br>// 当Block变量出了作用域,Block的内存会被自动释放<br>void(^myBlock)() = ^{<br>NSLog(@”———“);<br>};<br>myBlock();<br>在Block的内存存储在堆中时,如果在Block中引用了外面的对象,会对所引用的对象进行强引用,但是在Block被释放时会自动去掉对该对象的强引用,所以不会造成内存泄漏<br>Person *p = [[Person alloc] init];</p>
<p>void(^myBlock)() = ^{<br>NSLog(@”———%@”, p);<br>};<br>myBlock();</p>
<p>// Person对象在这里可以正常被释放<br>如果对象内部有一个Block属性,而在Block内部又访问了该对象,那么会造成循环引用<br>情况一</p>
<p>@interface Person : NSObject</p>
<p>@property (nonatomic, copy) void(^myBlock)();</p>
<p>@end</p>
<p>@implementation Person</p>
<ul>
<li>(void)dealloc<br>{<br>NSLog(@”Person dealloc”);<br>}</li>
</ul>
<p>@end</p>
<p>Person *p = [[Person alloc] init];</p>
<p>p.myBlock = ^{<br>NSLog(@”———%@”, p);<br>};<br>p.myBlock();</p>
<p>// 因为myBlock作为Person的属性,采用copy修饰符修饰(这样才能保证Block在堆里面,以免Block在栈中被系统释放),所以Block会对Person对象进行一次强引用,导致循环引用无法释放<br>情况二</p>
<p>@interface Person : NSObject</p>
<p>@property (nonatomic, copy) void(^myBlock)();</p>
<ul>
<li>(void)resetBlock;</li>
</ul>
<p>@end</p>
<p>@implementation Person</p>
<ul>
<li><p>(void)resetBlock<br>{<br>self.myBlock = ^{<br>NSLog(@”———%@”, self);<br>};<br>}</p>
</li>
<li><p>(void)dealloc<br>{<br>NSLog(@”Person dealloc”);<br>}</p>
</li>
</ul>
<p>@end</p>
<p>Person *p = [[Person alloc] init];<br>[p resetBlock];</p>
<p>// Person对象在这里无法正常释放,在resetBlock方法实现中,Block内部对self进行了一次强引用,导致循环引用无法释放<br>如果对象内部有一个Block属性,而在Block内部又访问了该对象,那么会造成循环引用,解决循环引用的办法是使用一个弱引用的指针指向该对象,然后在Block内部使用该弱引用指针来进行操作,这样避免了Block对对象进行强引用<br>情况一</p>
<p>@interface Person : NSObject</p>
<p>@property (nonatomic, copy) void(^myBlock)();</p>
<p>@end</p>
<p>@implementation Person</p>
<ul>
<li>(void)dealloc<br>{<br>NSLog(@”Person dealloc”);<br>}</li>
</ul>
<p>@end</p>
<p>Person *p = [[Person alloc] init];<br>__weak typeof(p) weakP = p;</p>
<p>p.myBlock = ^{<br>NSLog(@”———%@”, weakP);<br>};<br>p.myBlock();</p>
<p>// Person对象在这里可以正常被释放<br>情况二</p>
<p>@interface Person : NSObject</p>
<p>@property (nonatomic, copy) void(^myBlock)();</p>
<ul>
<li>(void)resetBlock;</li>
</ul>
<p>@end</p>
<p>@implementation Person</p>
<ul>
<li><p>(void)resetBlock<br>{<br>// 这里为了通用一点,可以使用<strong>weak typeof(self) weakP = self;
</strong>weak Person *weakP = self;<br>self.myBlock = ^{<br>NSLog(@”———%@”, weakP);<br>};<br>}</p>
</li>
<li><p>(void)dealloc<br>{<br>NSLog(@”Person dealloc”);<br>}</p>
</li>
</ul>
<p>@end</p>
<p>Person *p = [[Person alloc] init];<br>[p resetBlock];</p>
<p>// Person对象在这里可以正常被释放<br>Block在ARC下的内存管理的官方案例</p>
<p>在MRC中,我们从当前控制器采用模态视图方式present进入MyViewController控制器,在Block中会对myViewController进行一次retain操作,造成循环引用</p>
<p>MyViewController *myController = [[MyViewController alloc] init];<br>// …<br>myController.completionHandler =  ^(NSInteger result) {<br>[myController dismissViewControllerAnimated:YES completion:nil];<br>};<br>[self presentViewController:myController animated:YES completion:^{<br>[myController release];<br>}];<br>在MRC中解决循环引用的办法即在变量前使用下划线下划线block修饰,禁止Block对所引用的对象进行retain操作</p>
<p>__block MyViewController *myController = [[MyViewController alloc] init];<br>// …<br>myController.completionHandler =  ^(NSInteger result) {<br>[myController dismissViewControllerAnimated:YES completion:nil];<br>};<br>[self presentViewController:myController animated:YES completion:^{<br>[myController release];<br>}];<br>但是上述方法在ARC下行不通,因为下划线下划线block在ARC中并不能禁止Block对所引用的对象进行强引用,解决办法可以是在Block中将myController置空(为了可以修改myController,还是需要使用下划线下划线block对变量进行修饰)</p>
<p>__block MyViewController *myController = [[MyViewController alloc] init];<br>// …<br>myController.completionHandler =  ^(NSInteger result) {<br>[myController dismissViewControllerAnimated:YES completion:nil];<br>myController = nil;<br>};<br>[self presentViewController:myController animated:YES completion:^{}];<br>上述方法确实可以解决循环引用,但是在ARC中还有更优雅的解决办法,新创建一个弱指针来指向该对象,并将该弱指针放在Block中使用,这样Block便不会造成循环引用</p>
<p>MyViewController <em>myController = [[MyViewController alloc] init];<br>// …<br>__weak MyViewController </em>weakMyController = myController;<br>myController.completionHandler =  ^(NSInteger result) {<br>[weakMyController dismissViewControllerAnimated:YES completion:nil];<br>};<br>[self presentViewController:myController animated:YES completion:^{}];<br>虽然解决了循环引用,但是也容易涉及到另一个问题,因为Block是通过弱引用指向了myController对象,那么有可能在调用Block之前myController对象便已经被释放了,所以我们需要在Block内部再定义一个强指针来指向myController对象</p>
<p>MyViewController <em>myController = [[MyViewController alloc] init];<br>// …<br>__weak MyViewController </em>weakMyController = myController;<br>myController.completionHandler =  ^(NSInteger result) {<br>MyViewController *strongMyController = weakMyController;<br>if (strongMyController)<br>{<br>[strongMyController dismissViewControllerAnimated:YES completion:nil];<br>}<br>else<br>{<br>// Probably nothing…<br>}<br>};<br>[self presentViewController:myController animated:YES completion:^{}];<br>这里需要补充一下,在Block内部定义的变量,会在作用域结束时自动释放,Block对其并没有强引用关系,且在ARC中只需要避免循环引用即可,如果只是Block单方面地对外部变量进行强引用,并不会造成内存泄漏</p>
<p>注: 关于下划线下划线block关键字在MRC和ARC下的不同<br>__block在MRC下有两个作用</p>
<ol>
<li>允许在Block中访问和修改局部变量</li>
<li>禁止Block对所引用的对象进行隐式retain操作</li>
</ol>
<p>__block在ARC下只有一个作用</p>
<ol>
<li>允许在Block中访问和修改局部变量<br>使用Block进行排序</li>
</ol>
<p>在开发中,我们一般使用数组的如下两个方法来进行排序</p>
<p>不可变数组的方法: - (NSArray *)sortedArrayUsingComparator:(NSComparator)cmptr<br>可变数组的方法 : - (void)sortUsingComparator:(NSComparator)cmptr<br>其中,NSComparator是利用typedef定义的Block类型</p>
<p>typedef NSComparisonResult (^NSComparator)(id obj1, id obj2);<br>其中,这个返回值为NSComparisonResult枚举,这个返回值用来决定Block的两个参数顺序,我们只需在Block中指明不同条件下Block的两个参数的顺序即可,方法内部会将数组中的元素分别利用Block来进行比较并排序<br><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs Objective-c">typedef NS_ENUM(NSInteger, NSComparisonResult)<br>&#123;<br>NSOrderedAscending &#x3D; -1L, &#x2F;&#x2F; 升序,表示左侧的字符在右侧的字符前边<br>NSOrderedSame, &#x2F;&#x2F; 相等<br>NSOrderedDescending &#x2F;&#x2F; 降序,表示左侧的字符在右侧的字符后边<br>&#125;;<br></code></pre></td></tr></table></figure><br>我们以Person类为例,对Person对象以年龄升序进行排序,具体方法如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs Objective-c"><br>@interface Student : NSObject<br><br>@property (nonatomic, assign) int age;<br><br>@end<br><br><br>@implementation Student<br><br>@end<br><br><br>Student *stu1 &#x3D; [[Student alloc] init];<br>stu1.age &#x3D; 18;<br>Student *stu2 &#x3D; [[Student alloc] init];<br>stu2.age &#x3D; 28;<br>Student *stu3 &#x3D; [[Student alloc] init];<br>stu3.age &#x3D; 11;<br><br>NSArray *array &#x3D; @[stu1,stu2,stu3];<br><br>array &#x3D; [array sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2) &#123;<br>Student *stu1 &#x3D; obj1;<br>Student *stu2 &#x3D; obj2;<br><br>if (stu1.age &gt; stu2.age)<br>&#123;<br>return NSOrderedDescending; &#x2F;&#x2F; 在这里返回降序,说明在该种条件下,obj1排在obj2的后边<br>&#125;<br>else if (stu1.age &lt; stu2.age)<br>&#123;<br>return NSOrderedAscending;<br>&#125;<br>else<br>&#123;<br>return NSOrderedSame;<br>&#125;<br>&#125;];<br><br></code></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>NSOperation、NSOperationQueue、NSThread+runloop实现常驻线程、加锁</title>
    <url>/2019/11/12/NSOperation%E3%80%81NSOperationQueue%E3%80%81NSThread-runloop%E5%AE%9E%E7%8E%B0%E5%B8%B8-%E9%A9%BB%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8A%A0%E9%94%81/</url>
    <content><![CDATA[<ul>
<li><p><code>NSOperationQueue</code>的优点</p>
</li>
<li><p><code>NSOperation</code>和<code>NSOperationQueue</code></p>
</li>
<li><p><code>NSThread+runloop</code>实现常驻线程</p>
</li>
<li><p>自旋锁与互斥锁</p>
</li>
</ul>
<hr>
<h4 id="一、NSOperationQueue的优点"><a href="#一、NSOperationQueue的优点" class="headerlink" title="一、NSOperationQueue的优点"></a>一、NSOperationQueue的优点</h4><p><code>NSOperation、NSOperationQueue</code> 是苹果提供给我们的一套多线程解决方案。实际上 <code>NSOperation、NSOperationQueue</code> 是基于<code>GCD</code>更高一层的封装，完全面向对象。但是比 GCD 更简单易用、代码可读性也更高。</p>
<ol>
<li><p>可以添加任务依赖，方便控制执行顺序.</p>
</li>
<li><p>可以设定操作执行的优先级.</p>
</li>
<li><p>任务执行状态控制:<code>isReady,isExecuting,isFinished,isCancelled</code></p>
</li>
</ol>
<p>如果只是重写<code>NSOperation</code>的<code>main</code>方法，由底层控制变更任务执行及完成状态，以及任务退出<br>如果重写了NSOperation的start方法，自行控制任务状态系统通过KVO的方式移除isFinished==YES的<code>NSOperation</code>.</p>
<ol>
<li>可以设置最大并发量.</li>
</ol>
<h4 id="二、NSOperation和NSOperationQueue"><a href="#二、NSOperation和NSOperationQueue" class="headerlink" title="二、NSOperation和NSOperationQueue"></a>二、NSOperation和NSOperationQueue</h4><ul>
<li>操作（Operation）：</li>
</ul>
<p>执行操作的意思，换句话说就是你在线程中执行的那段代码。<br>在<code>GCD</code>中是放在<code>block</code> 中的。在<code>NSOperation</code> 中，使用 <code>NSOperation</code>子类 <code>NSInvocationOperation</code>、<code>NSBlockOperation</code>，或者自定义子类来封装操作。</p>
<ul>
<li>操作队列（Operation Queues）：</li>
</ul>
<p>这里的队列指操作队列，即用来存放操作的队列。不同于 GCD 中的调度队列 FIFO（先进先出）的原则。NSOperationQueue 对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。<br>操作队列通过设置<code>最大并发操作数</code>（maxConcurrentOperationCount）来控制并发、串行。<br>NSOperationQueue 为我们提供了两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。</p>
<blockquote>
<p>为什么要使用 <code>NSOperation、NSOperationQueue</code>？</p>
</blockquote>
<ul>
<li>可添加完成的代码块，在操作完成后执行。</li>
<li>添加操作之间的依赖关系，方便的控制执行顺序。</li>
<li>设定操作执行的优先级。</li>
<li>可以很方便的取消一个操作的执行。</li>
<li>使用 KVO 观察对操作执行状态的更改：isExecuteing、isFinished、isCancelled。</li>
</ul>
<h5 id="NSOperation、NSOperationQueue-使用步骤"><a href="#NSOperation、NSOperationQueue-使用步骤" class="headerlink" title="NSOperation、NSOperationQueue 使用步骤"></a>NSOperation、NSOperationQueue 使用步骤</h5><p><code>NSOperation</code> 需要配合 <code>NSOperationQueue</code>来实现多线程。因为默认情况下，NSOperation 单独使用时系统同步执行操作，配合 NSOperationQueue 我们能更好的实现异步执行。</p>
<p><code>NSOperation</code> 实现多线程的使用步骤分为三步：</p>
<ul>
<li>创建操作：先将需要执行的操作封装到一个 <code>NSOperation</code>对象中。</li>
<li>创建队列：创建 <code>NSOperationQueue</code> 对象。</li>
<li>将操作加入到队列中：将 <code>NSOperation</code> 对象添加到<code>NSOperationQueue</code> 对象中。<br>之后呢，系统就会自动将 <code>NSOperationQueue</code> 中的 <code>NSOperation</code> 取出来，在新线程中执行操作。</li>
</ul>
<h5 id="NSOperation-和-NSOperationQueue-基本使用"><a href="#NSOperation-和-NSOperationQueue-基本使用" class="headerlink" title="NSOperation 和 NSOperationQueue 基本使用"></a>NSOperation 和 NSOperationQueue 基本使用</h5><h6 id="创建操作"><a href="#创建操作" class="headerlink" title="创建操作"></a>创建操作</h6><p><code>NSOperation</code>是个抽象类，不能用来封装操作。我们只有使用它的子类来封装操作。我们有三种方式来封装操作。</p>
<ul>
<li>使用子类 NSInvocationOperation</li>
<li>使用子类 NSBlockOperation</li>
<li>自定义继承自 NSOperation 的子类，通过实现内部相应的方法来封装操作。<br>在不使用 NSOperationQueue，单独使用 NSOperation 的情况下系统同步执行操作，下面我们学习以下操作的三种创建方式。</li>
</ul>
<p>1.使用子类 <code>NSInvocationOperation</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用子类 NSInvocationOperation</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-keyword">void</span>)useInvocationOperation &#123;<br><br>    <span class="hljs-comment">// 1.创建 NSInvocationOperation 对象</span><br>    <span class="hljs-built_in">NSInvocationOperation</span> *op = [[<span class="hljs-built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(task1) object:<span class="hljs-literal">nil</span>];<br><br>    <span class="hljs-comment">// 2.调用 start 方法开始执行操作</span><br>    [op start];<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 任务1</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-keyword">void</span>)task1 &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>]; <span class="hljs-comment">// 模拟耗时操作</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1---%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]); <span class="hljs-comment">// 打印当前线程</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>输出结果：<br><img src="1877784-8adc1a81b44170e6.png" alt=""></p>
<blockquote>
<p>可以看到：在其他线程中单独使用子类 <code>NSInvocationOperation</code>，操作是在当前调用的其他线程执行的，并没有开启新线程。</p>
</blockquote>
<ol>
<li>使用子类 <code>NSBlockOperation</code></li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用子类 NSBlockOperation</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-keyword">void</span>)useBlockOperation &#123;<br><br>    <span class="hljs-comment">// 1.创建 NSBlockOperation 对象</span><br>    <span class="hljs-built_in">NSBlockOperation</span> *op = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>]; <span class="hljs-comment">// 模拟耗时操作</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1---%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]); <span class="hljs-comment">// 打印当前线程</span><br>        &#125;<br>    &#125;];<br><br>    <span class="hljs-comment">// 2.调用 start 方法开始执行操作</span><br>    [op start];<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="1877784-bfec9a19f48614b07.png" alt=""></p>
<blockquote>
<p>可以看到：在没有使用 <code>NSOperationQueue</code>、在主线程中单独使用 <code>NSBlockOperation</code> 执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。</p>
</blockquote>
<p><code>注意：和上边</code>NSInvocationOperation<code>使用一样。因为代码是在主线程中调用的，所以打印结果为主线程。如果在其他线程中执行操作，则打印结果为其他线程。</code></p>
<p>但是，<code>NSBlockOperation</code> 还提供了一个方法 <code>addExecutionBlock:</code>，通过 <code>addExecutionBlock:</code> 就可以为 <code>NSBlockOperation</code> 添加额外的操作。这些操作（包括 <code>blockOperationWithBlock</code> 中的操作）可以在不同的线程中同时（并发）执行。只有当所有相关的操作已经完成执行时，才视为完成。</p>
<p>如果添加的操作多的话，<code>blockOperationWithBlock:</code> 中的操作也可能会在其他线程（非当前线程）中执行，这是由系统决定的，并不是说添加到 <code>blockOperationWithBlock:</code>中的操作一定会在当前线程中执行。（可以使用 addExecutionBlock: 多添加几个操作试试）。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用子类 NSBlockOperation</span><br><span class="hljs-comment"> * 调用方法 AddExecutionBlock:</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-keyword">void</span>)useBlockOperationAddExecutionBlock &#123;<br><br>    <span class="hljs-comment">// 1.创建 NSBlockOperation 对象</span><br>    <span class="hljs-built_in">NSBlockOperation</span> *op = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>]; <span class="hljs-comment">// 模拟耗时操作</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1---%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]); <span class="hljs-comment">// 打印当前线程</span><br>        &#125;<br>    &#125;];<br><br>    <span class="hljs-comment">// 2.添加额外的操作</span><br>    [op addExecutionBlock:^&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>]; <span class="hljs-comment">// 模拟耗时操作</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2---%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]); <span class="hljs-comment">// 打印当前线程</span><br>        &#125;<br>    &#125;];<br>    [op addExecutionBlock:^&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>]; <span class="hljs-comment">// 模拟耗时操作</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3---%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]); <span class="hljs-comment">// 打印当前线程</span><br>        &#125;<br>    &#125;];<br>    [op addExecutionBlock:^&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>]; <span class="hljs-comment">// 模拟耗时操作</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;4---%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]); <span class="hljs-comment">// 打印当前线程</span><br>        &#125;<br>    &#125;];<br>    [op addExecutionBlock:^&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>]; <span class="hljs-comment">// 模拟耗时操作</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;5---%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]); <span class="hljs-comment">// 打印当前线程</span><br>        &#125;<br>    &#125;];<br>    [op addExecutionBlock:^&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>]; <span class="hljs-comment">// 模拟耗时操作</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;6---%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]); <span class="hljs-comment">// 打印当前线程</span><br>        &#125;<br>    &#125;];<br>    [op addExecutionBlock:^&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>]; <span class="hljs-comment">// 模拟耗时操作</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;7---%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]); <span class="hljs-comment">// 打印当前线程</span><br>        &#125;<br>    &#125;];<br>    [op addExecutionBlock:^&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>]; <span class="hljs-comment">// 模拟耗时操作</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;8---%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]); <span class="hljs-comment">// 打印当前线程</span><br>        &#125;<br>    &#125;];<br><br>    <span class="hljs-comment">// 3.调用 start 方法开始执行操作</span><br>    [op start];<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>输出结果：<br><img src="1877784-86c1302fa13acc83.png" alt=""></p>
<blockquote>
<p>可以看出：使用子类 <code>NSBlockOperation</code>，并调用方法 <code>AddExecutionBlock:</code> 的情况下，<code>blockOperationWithBlock:</code>方法中的操作 和<code>addExecutionBlock:</code> 中的操作是在不同的线程中异步执行的。而且，这次执行结果中 <code>blockOperationWithBlock:</code>方法中的操作也不是在当前线程（主线程）中执行的。从而印证了<code>blockOperationWithBlock:</code>中的操作也可能会在其他线程（非当前线程）中执行。</p>
</blockquote>
<p>一般情况下，如果一个 <code>NSBlockOperation</code> 对象封装了多个操作。<code>NSBlockOperation</code> 是否开启新线程，取决于操作的个数。如果添加的操作的个数多，就会自动开启新线程。当然开启的线程数是由系统来决定的。</p>
<ol>
<li>使用自定义继承自 <code>NSOperation</code>的子类</li>
</ol>
<p>如果使用子类 <code>NSInvocationOperation</code>、<code>NSBlockOperation</code> 不能满足日常需求，我们可以使用自定义继承自 <code>NSOperation</code> 的子类。可以通过重写<code>main</code> 或者 start 方法 来定义自己的 <code>NSOperation</code> 对象。重写<code>main</code>方法比较简单，我们不需要管理操作的状态属性 <code>isExecuting</code> 和 <code>isFinished</code>。当 <code>main</code> 执行完返回的时候，这个操作就结束了。</p>
<p>先定义一个继承自 <code>NSOperation</code> 的子类，重写<code>main</code>方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// YSCOperation.h 文件</span><br><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">YSCOperation</span> : <span class="hljs-title">NSOperation</span></span><br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">// YSCOperation.m 文件</span><br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;YSCOperation.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">YSCOperation</span></span><br><br>- (<span class="hljs-keyword">void</span>)main &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.isCancelled) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1---%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>
<p>然后使用的时候导入头文件<code>YSCOperation.h</code>。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用自定义继承自 NSOperation 的子类</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-keyword">void</span>)useCustomOperation &#123;<br>    <span class="hljs-comment">// 1.创建 YSCOperation 对象</span><br>    YSCOperation *op = [[YSCOperation alloc] init];<br>    <span class="hljs-comment">// 2.调用 start 方法开始执行操作</span><br>    [op start];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果：<br><img src="1877784-3ed047566df45382.png" alt=""></p>
<blockquote>
<p>可以看出：在没有使用 <code>NSOperationQueue</code>、在主线程单独使用自定义继承自 <code>NSOperation</code>的子类的情况下，是在主线程执行操作，并没有开启新线程。</p>
</blockquote>
<p>下边我们来讲讲 <code>NSOperationQueue</code>的创建。</p>
<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><ol>
<li>创建队列</li>
</ol>
<blockquote>
<p><code>NSOperationQueue</code> 一共有两种队列：主队列、自定义队列。其中自定义队列同时包含了串行、并发功能。下边是主队列、自定义队列的基本创建方法和特点。</p>
</blockquote>
<ul>
<li>主队列<br>凡是添加到主队列中的操作，都会放到主线程中执行（注：不包括操作使用addExecutionBlock:添加的额外操作，额外操作可能在其他线程执行）。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">// 主队列获取方法</span><br><span class="hljs-built_in">NSOperationQueue</span> *queue = [<span class="hljs-built_in">NSOperationQueue</span> mainQueue];<br><br></code></pre></td></tr></table></figure>
<ul>
<li>自定义队列（非主队列）</li>
</ul>
<p>添加到这种队列中的操作，就会自动放到子线程中执行。<br>同时包含了：串行、并发功能。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 自定义队列创建方法</span><br><span class="hljs-built_in">NSOperationQueue</span> *queue = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];<br></code></pre></td></tr></table></figure>
<ol>
<li>将操作加入到队列中</li>
</ol>
<p>上边我们说到<code>NSOperation</code>需要配合<code>NSOperationQueue</code>来实现多线程。</p>
<p>那么我们需要将创建好的操作加入到队列中去。总共有两种方法：</p>
<ul>
<li>2.1 <code>- (void)addOperation:(NSOperation *)op;</code></li>
</ul>
<p>需要先创建操作，再将创建好的操作加入到创建好的队列中去</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用 addOperation: 将操作加入到操作队列中</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-keyword">void</span>)addOperationToQueue &#123;<br><br>    <span class="hljs-comment">// 1.创建队列</span><br>    <span class="hljs-built_in">NSOperationQueue</span> *queue = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];<br><br>    <span class="hljs-comment">// 2.创建操作</span><br>    <span class="hljs-comment">// 使用 NSInvocationOperation 创建操作1</span><br>    <span class="hljs-built_in">NSInvocationOperation</span> *op1 = [[<span class="hljs-built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(task1) object:<span class="hljs-literal">nil</span>];<br><br>    <span class="hljs-comment">// 使用 NSInvocationOperation 创建操作2</span><br>    <span class="hljs-built_in">NSInvocationOperation</span> *op2 = [[<span class="hljs-built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(task2) object:<span class="hljs-literal">nil</span>];<br><br>    <span class="hljs-comment">// 使用 NSBlockOperation 创建操作3</span><br>    <span class="hljs-built_in">NSBlockOperation</span> *op3 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>]; <span class="hljs-comment">// 模拟耗时操作</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3---%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]); <span class="hljs-comment">// 打印当前线程</span><br>        &#125;<br>    &#125;];<br>    [op3 addExecutionBlock:^&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>]; <span class="hljs-comment">// 模拟耗时操作</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;4---%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]); <span class="hljs-comment">// 打印当前线程</span><br>        &#125;<br>    &#125;];<br><br>    <span class="hljs-comment">// 3.使用 addOperation: 添加所有操作到队列中</span><br>    [queue addOperation:op1]; <span class="hljs-comment">// [op1 start]</span><br>    [queue addOperation:op2]; <span class="hljs-comment">// [op2 start]</span><br>    [queue addOperation:op3]; <span class="hljs-comment">// [op3 start]</span><br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="1877784-f31a03ee66c365e5.png" alt=""></p>
<blockquote>
<p>可以看出：使用 <code>NSOperation</code> 子类创建操作，并使用 <code>addOperation:</code> 将操作加入到操作队列后能够开启新线程，进行并发执行。</p>
</blockquote>
<ul>
<li>2.2 <code>- (void)addOperationWithBlock:(void (^)(void))block;</code></li>
</ul>
<blockquote>
<p>无需先创建操作，在 block 中添加操作，直接将包含操作的 block 加入到队列中。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用 addOperationWithBlock: 将操作加入到操作队列中</span><br><span class="hljs-comment"> */</span><br><br>- (<span class="hljs-keyword">void</span>)addOperationWithBlockToQueue &#123;<br>    <span class="hljs-comment">// 1.创建队列</span><br>    <span class="hljs-built_in">NSOperationQueue</span> *queue = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];<br><br>    <span class="hljs-comment">// 2.使用 addOperationWithBlock: 添加操作到队列中</span><br>    [queue addOperationWithBlock:^&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>]; <span class="hljs-comment">// 模拟耗时操作</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1---%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]); <span class="hljs-comment">// 打印当前线程</span><br>        &#125;<br>    &#125;];<br>    [queue addOperationWithBlock:^&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>]; <span class="hljs-comment">// 模拟耗时操作</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2---%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]); <span class="hljs-comment">// 打印当前线程</span><br>        &#125;<br>    &#125;];<br>    [queue addOperationWithBlock:^&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>]; <span class="hljs-comment">// 模拟耗时操作</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3---%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]); <span class="hljs-comment">// 打印当前线程</span><br>        &#125;<br>    &#125;];<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="1877784-ac8c2cdaf40b4202.png" alt=""></p>
<blockquote>
<p>可以看出：使用 <code>addOperationWithBlock:</code> 将操作加入到操作队列后能够开启新线程，进行并发执行。</p>
</blockquote>
<ol>
<li><code>NSOperationQueue</code> 控制串行执行、并发执行</li>
</ol>
<p>之前我们说过，<code>NSOperationQueue</code> 创建的自定义队列同时具有串行、并发功能，上边我们演示了并发功能，那么他的串行功能是如何实现的？<br>这里有个关键属性 <code>maxConcurrentOperationCount</code>，叫做最大并发操作数。用来控制一个特定队列中可以有多少个操作同时参与并发执行。</p>
<blockquote>
<p>注意：这里 <code>maxConcurrentOperationCount</code> 控制的不是并发线程的数量，而是一个队列中同时能并发执行的最大操作数。而且一个操作也并非只能在一个线程中运行。</p>
</blockquote>
<p>最大并发操作数：<code>maxConcurrentOperationCount</code><br><code>maxConcurrentOperationCount</code>默认情况下为-1，表示不进行限制，可进行并发执行。<br><code>maxConcurrentOperationCount</code> 为1时，队列为串行队列。只能串行执行。<br><code>maxConcurrentOperationCount</code>大于1时，队列为并发队列。操作并发执行，当然这个值不应超过系统限制，即使自己设置一个很大的值，系统也会自动调整为 <code>min&#123;自己设定的值，系统设定的默认最大值&#125;</code>。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置 MaxConcurrentOperationCount（最大并发操作数）</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-keyword">void</span>)setMaxConcurrentOperationCount &#123;<br><br>    <span class="hljs-comment">// 1.创建队列</span><br>    <span class="hljs-built_in">NSOperationQueue</span> *queue = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];<br><br>    <span class="hljs-comment">// 2.设置最大并发操作数</span><br>    queue.maxConcurrentOperationCount = <span class="hljs-number">1</span>; <span class="hljs-comment">// 串行队列</span><br><span class="hljs-comment">// queue.maxConcurrentOperationCount = 2; // 并发队列</span><br><span class="hljs-comment">// queue.maxConcurrentOperationCount = 8; // 并发队列</span><br><br>    <span class="hljs-comment">// 3.添加操作</span><br>    [queue addOperationWithBlock:^&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>]; <span class="hljs-comment">// 模拟耗时操作</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1---%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]); <span class="hljs-comment">// 打印当前线程</span><br>        &#125;<br>    &#125;];<br>    [queue addOperationWithBlock:^&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>]; <span class="hljs-comment">// 模拟耗时操作</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2---%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]); <span class="hljs-comment">// 打印当前线程</span><br>        &#125;<br>    &#125;];<br>    [queue addOperationWithBlock:^&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>]; <span class="hljs-comment">// 模拟耗时操作</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3---%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]); <span class="hljs-comment">// 打印当前线程</span><br>        &#125;<br>    &#125;];<br>    [queue addOperationWithBlock:^&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>]; <span class="hljs-comment">// 模拟耗时操作</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;4---%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]); <span class="hljs-comment">// 打印当前线程</span><br>        &#125;<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最大并发操作数为1 输出结果：</p>
<p><img src="1877784-79e0996ee294d434.png" alt=""></p>
<p>最大并发操作数为2 输出结果：</p>
<p><img src="1877784-c4f7ac2202fcb871.png" alt=""></p>
<blockquote>
<p>可以看出：当最大并发操作数为1时，操作是按顺序串行执行的，并且一个操作完成之后，下一个操作才开始执行。当最大操作并发数为2时，操作是并发执行的，可以同时执行两个操作。而开启线程数量是由系统决定的，不需要我们来管理。<br><code>这样看来，是不是比 GCD 还要简单了许多？</code></p>
</blockquote>
<ol>
<li><code>NSOperation</code>操作依赖</li>
</ol>
<p><code>NSOperation、NSOperationQueue</code> 最吸引人的地方是它能添加操作之间的依赖关系。通过操作依赖，我们可以很方便的控制操作之间的执行先后顺序。<code>NSOperation</code>提供了3个接口供我们管理和查看依赖。</p>
<ul>
<li><code>- (void)addDependency:(NSOperation *)op;</code> 添加依赖，使当前操作依赖于操作 op 的完成。</li>
<li><code>- (void)removeDependency:(NSOperation *)op;</code>移除依赖，取消当前操作对操作 op 的依赖。</li>
<li><code>@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies;</code> 在当前操作开始执行之前完成执行的所有操作对象数组。<br>当然，我们经常用到的还是添加依赖操作。现在考虑这样的需求，比如说有 A、B 两个操作，其中 A 执行完操作，B 才能执行操作。</li>
</ul>
<p>如果使用依赖来处理的话，那么就需要让操作 B 依赖于操作 A。具体代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 操作依赖</span><br><span class="hljs-comment"> * 使用方法：addDependency:</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-keyword">void</span>)addDependency &#123;<br><br>    <span class="hljs-comment">// 1.创建队列</span><br>    <span class="hljs-built_in">NSOperationQueue</span> *queue = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];<br><br>    <span class="hljs-comment">// 2.创建操作</span><br>    <span class="hljs-built_in">NSBlockOperation</span> *op1 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>]; <span class="hljs-comment">// 模拟耗时操作</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1---%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]); <span class="hljs-comment">// 打印当前线程</span><br>        &#125;<br>    &#125;];<br>    <span class="hljs-built_in">NSBlockOperation</span> *op2 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>]; <span class="hljs-comment">// 模拟耗时操作</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2---%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]); <span class="hljs-comment">// 打印当前线程</span><br>        &#125;<br>    &#125;];<br><br>    <span class="hljs-comment">// 3.添加依赖</span><br>    [op2 addDependency:op1]; <span class="hljs-comment">// 让op2 依赖于 op1，则先执行op1，在执行op2</span><br><br>    <span class="hljs-comment">// 4.添加操作到队列中</span><br>    [queue addOperation:op1];<br>    [queue addOperation:op2];<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="1877784-c0ce9c8c762ea71b.png" alt=""></p>
<blockquote>
<p>可以看到：通过添加操作依赖，无论运行几次，其结果都是 op1 先执行，op2 后执行。</p>
</blockquote>
<ol>
<li><code>NSOperation 优先级</code></li>
</ol>
<p><code>NSOperation</code> 提供了<code>queuePriority（优先级）</code>属性，<code>queuePriority属性</code>适用于同一操作队列中的操作，不适用于不同操作队列中的操作。默认情况下，所有新创建的操作对象优先级都是<code>NSOperationQueuePriorityNormal</code>。但是我们可以通过<code>setQueuePriority:</code>方法来改变当前操作在同一队列中的执行优先级。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">// 优先级的取值</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">NS_ENUM</span>(<span class="hljs-built_in">NSInteger</span>, <span class="hljs-built_in">NSOperationQueuePriority</span>) &#123;<br>    <span class="hljs-built_in">NSOperationQueuePriorityVeryLow</span> = <span class="hljs-number">-8</span>L,<br>    <span class="hljs-built_in">NSOperationQueuePriorityLow</span> = <span class="hljs-number">-4</span>L,<br>    <span class="hljs-built_in">NSOperationQueuePriorityNormal</span> = <span class="hljs-number">0</span>,<br>    <span class="hljs-built_in">NSOperationQueuePriorityHigh</span> = <span class="hljs-number">4</span>,<br>    <span class="hljs-built_in">NSOperationQueuePriorityVeryHigh</span> = <span class="hljs-number">8</span><br>&#125;;<br><br></code></pre></td></tr></table></figure>
<p>上边我们说过：对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。</p>
<blockquote>
<p>那么，什么样的操作才是进入就绪状态的操作呢？<br>  当一个操作的所有依赖都已经完成时，操作对象通常会进入准备就绪状态，等待执行。<br>举个例子，现在有4个优先级都是<code>NSOperationQueuePriorityNormal（默认级别）</code>的操作：op1，op2，op3，op4。其中 op3 依赖于 op2，op2 依赖于 op1，即 op3 -&gt; op2 -&gt; op1。现在将这4个操作添加到队列中并发执行。<br>因为 op1 和 op4 都没有需要依赖的操作，所以在 op1，op4 执行之前，就是处于准备就绪状态的操作。<br>而 op3 和 op2 都有依赖的操作（op3 依赖于 op2，op2 依赖于 op1），所以 op3 和 op2 都不是准备就绪状态下的操作。<br>理解了进入就绪状态的操作，那么我们就理解了queuePriority 属性的作用对象。<br><code>queuePriority</code>属性决定了进入准备就绪状态下的操作之间的开始执行顺序。并且，优先级不能取代依赖关系。如果一个队列中既包含高优先级操作，又包含低优先级操作，并且两个操作都已经准备就绪，那么队列先执行高优先级操作。比如上例中，如果 op1 和 op4 是不同优先级的操作，那么就会先执行优先级高的操作。如果，一个队列中既包含了准备就绪状态的操作，又包含了未准备就绪的操作，未准备就绪的操作优先级比准备就绪的操作优先级高。那么，虽然准备就绪的操作优先级低，也会优先执行。优先级不能取代依赖关系。如果要控制操作间的启动顺序，则必须使用依赖关系。</p>
</blockquote>
<ol>
<li><code>NSOperation、NSOperationQueue 线程间</code>的通信</li>
</ol>
<blockquote>
<p>在 iOS 开发过程中，我们一般在主线程里边进行 UI 刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线程间通信</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-keyword">void</span>)communication &#123;<br><br>    <span class="hljs-comment">// 1.创建队列</span><br>    <span class="hljs-built_in">NSOperationQueue</span> *queue = [[<span class="hljs-built_in">NSOperationQueue</span> alloc]init];<br><br>    <span class="hljs-comment">// 2.添加操作</span><br>    [queue addOperationWithBlock:^&#123;<br>        <span class="hljs-comment">// 异步进行耗时操作</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>]; <span class="hljs-comment">// 模拟耗时操作</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1---%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]); <span class="hljs-comment">// 打印当前线程</span><br>        &#125;<br><br>        <span class="hljs-comment">// 回到主线程</span><br>        [[<span class="hljs-built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;<br>            <span class="hljs-comment">// 进行一些 UI 刷新等操作</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>                [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>]; <span class="hljs-comment">// 模拟耗时操作</span><br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2---%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]); <span class="hljs-comment">// 打印当前线程</span><br>            &#125;<br>        &#125;];<br>    &#125;];<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="1877784-c284bc79994a08dc.png" alt=""></p>
<blockquote>
<p><strong><em>可以看到：通过线程间的通信，先在其他线程中执行操作，等操作执行完了之后再回到主线程执行主线程的相应操作。</em></strong></p>
</blockquote>
<ol>
<li><code>NSOperation、NSOperationQueue</code> 线程同步和线程安全</li>
</ol>
<ul>
<li>线程安全：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。<br>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。</li>
<li>线程同步：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。<br>举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。</li>
</ul>
<p>下面，我们模拟火车票售卖的方式，实现 NSOperation 线程安全和解决线程同步问题。<br>场景：总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。</p>
<ol>
<li><code>NSOperation、NSOperationQueue</code> 非线程安全</li>
</ol>
<p>先来看看不考虑线程安全的代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 非线程安全：不使用 NSLock</span><br><span class="hljs-comment"> * 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-keyword">void</span>)initTicketStatusNotSave &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;currentThread---%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]); <span class="hljs-comment">// 打印当前线程</span><br><br>    <span class="hljs-keyword">self</span>.ticketSurplusCount = <span class="hljs-number">50</span>;<br><br>    <span class="hljs-comment">// 1.创建 queue1,queue1 代表北京火车票售卖窗口</span><br>    <span class="hljs-built_in">NSOperationQueue</span> *queue1 = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];<br>    queue1.maxConcurrentOperationCount = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 2.创建 queue2,queue2 代表上海火车票售卖窗口</span><br>    <span class="hljs-built_in">NSOperationQueue</span> *queue2 = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];<br>    queue2.maxConcurrentOperationCount = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 3.创建卖票操作 op1</span><br>    <span class="hljs-built_in">NSBlockOperation</span> *op1 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        [<span class="hljs-keyword">self</span> saleTicketNotSafe];<br>    &#125;];<br><br>    <span class="hljs-comment">// 4.创建卖票操作 op2</span><br>    <span class="hljs-built_in">NSBlockOperation</span> *op2 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        [<span class="hljs-keyword">self</span> saleTicketNotSafe];<br>    &#125;];<br><br>    <span class="hljs-comment">// 5.添加操作，开始卖票</span><br>    [queue1 addOperation:op1];<br>    [queue2 addOperation:op2];<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 售卖火车票(非线程安全)</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-keyword">void</span>)saleTicketNotSafe &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.ticketSurplusCount &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//如果还有票，继续售卖</span><br>            <span class="hljs-keyword">self</span>.ticketSurplusCount--;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;剩余票数:%d 窗口:%@&quot;</span>, <span class="hljs-keyword">self</span>.ticketSurplusCount, [<span class="hljs-built_in">NSThread</span> currentThread]]);<br>            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">0.2</span>];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;所有火车票均已售完&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="1877784-e4a2e86c0523d4c8.png" alt=""></p>
<p>省略一部分结果图。。。</p>
<p><img src="1877784-4a354394f006929f.png" alt=""></p>
<blockquote>
<p>可以看到：在不考虑线程安全，不使用<code>NSLock</code> 情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。</p>
</blockquote>
<ol>
<li><code>NSOperation、NSOperationQueue</code> 线程安全</li>
</ol>
<p>线程安全解决方案：可以给线程加锁，在一个线程执行该操作的时候，不允许其他线程进行操作。iOS 实现线程加锁有很多种方式。<code>@synchronized</code>、 <code>NSLock</code>、<code>NSRecursiveLock</code>、<code>NSCondition</code>、<code>NSConditionLock</code>、<code>pthread_mutex</code>、<code>dispatch_semaphore</code>、<code>OSSpinLock</code>、<code>atomic(property) set/get</code>等等各种方式。这里我们使用<code>NSLock</code> 对象来解决线程同步问题。<code>NSLock</code> 对象可以通过进入锁时调用 lock 方法，解锁时调用 unlock 方法来保证线程安全。</p>
<p>考虑线程安全的代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线程安全：使用 NSLock 加锁</span><br><span class="hljs-comment"> * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票</span><br><span class="hljs-comment"> */</span><br><br>- (<span class="hljs-keyword">void</span>)initTicketStatusSave &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;currentThread---%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]); <span class="hljs-comment">// 打印当前线程</span><br><br>    <span class="hljs-keyword">self</span>.ticketSurplusCount = <span class="hljs-number">50</span>;<br><br>    <span class="hljs-keyword">self</span>.lock = [[<span class="hljs-built_in">NSLock</span> alloc] init];  <span class="hljs-comment">// 初始化 NSLock 对象</span><br><br>    <span class="hljs-comment">// 1.创建 queue1,queue1 代表北京火车票售卖窗口</span><br>    <span class="hljs-built_in">NSOperationQueue</span> *queue1 = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];<br>    queue1.maxConcurrentOperationCount = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 2.创建 queue2,queue2 代表上海火车票售卖窗口</span><br>    <span class="hljs-built_in">NSOperationQueue</span> *queue2 = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];<br>    queue2.maxConcurrentOperationCount = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 3.创建卖票操作 op1</span><br>    <span class="hljs-built_in">NSBlockOperation</span> *op1 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        [<span class="hljs-keyword">self</span> saleTicketSafe];<br>    &#125;];<br><br>    <span class="hljs-comment">// 4.创建卖票操作 op2</span><br>    <span class="hljs-built_in">NSBlockOperation</span> *op2 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        [<span class="hljs-keyword">self</span> saleTicketSafe];<br>    &#125;];<br><br>    <span class="hljs-comment">// 5.添加操作，开始卖票</span><br>    [queue1 addOperation:op1];<br>    [queue2 addOperation:op2];<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 售卖火车票(线程安全)</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-keyword">void</span>)saleTicketSafe &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><br>        <span class="hljs-comment">// 加锁</span><br>        [<span class="hljs-keyword">self</span>.lock lock];<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.ticketSurplusCount &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//如果还有票，继续售卖</span><br>            <span class="hljs-keyword">self</span>.ticketSurplusCount--;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;剩余票数:%d 窗口:%@&quot;</span>, <span class="hljs-keyword">self</span>.ticketSurplusCount, [<span class="hljs-built_in">NSThread</span> currentThread]]);<br>            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">0.2</span>];<br>        &#125;<br><br>        <span class="hljs-comment">// 解锁</span><br>        [<span class="hljs-keyword">self</span>.lock unlock];<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.ticketSurplusCount &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;所有火车票均已售完&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure>
<p>输出结果：<br><img src="1877784-7bffb9eade5887d0.png" alt=""></p>
<p>省略一部分结果图。。。<br><img src="1877784-6698fdd0d10b0d14.png" alt=""></p>
<blockquote>
<p>可以看出：在考虑了线程安全，使用<code>NSLock</code> 加锁、解锁机制的情况下，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。</p>
</blockquote>
<ol>
<li><code>NSOperation、NSOperationQueue</code>常用属性和方法归纳</li>
</ol>
<ul>
<li>NSOperation 常用属性和方法</li>
</ul>
<p>取消操作方法<br><code>- (void)cancel;</code>可取消操作，实质是标记 isCancelled 状态。</p>
<ul>
<li>判断操作状态方法<br><code>- (BOOL)isFinished;</code>判断操作是否已经结束。<br><code>- (BOOL)isCancelled;</code>判断操作是否已经标记为取消。<br><code>- (BOOL)isExecuting;</code> 判断操作是否正在在运行。<br><code>- (BOOL)isReady;</code> 判断操作是否处于准备就绪状态，这个值和操作的依赖关系相关。</li>
<li>操作同步<br><code>- (void)waitUntilFinished;</code> 阻塞当前线程，直到该操作结束。可用于线程执行顺序的同步。<br><code>- (void)setCompletionBlock:(void (^)(void))block;</code> <code>completionBlock</code> 会在当前操作执行完毕时执行 completionBlock。<br><code>- (void)addDependency:(NSOperation *)op;</code> 添加依赖，使当前操作依赖于操作 op 的完成。<br><code>- (void)removeDependency:(NSOperation *)op</code>; 移除依赖，取消当前操作对操作 op 的依赖。<br><code>@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies</code>; 在当前操作开始执行之前完成执行的所有操作对象数组。</li>
</ul>
<ol>
<li><p><code>NSOperationQueue</code>常用属性和方法</p>
</li>
<li><ol>
<li><ol>
<li>取消/暂停/恢复操作<br><code>- (void)cancelAllOperations;</code> 可以取消队列的所有操作。<br><code>- (BOOL)isSuspended;</code>判断队列是否处于暂停状态。 YES 为暂停状态，NO 为恢复状态。<br><code>- (void)setSuspended:(BOOL)b</code>; 可设置操作的暂停和恢复，YES 代表暂停队列，NO 代表恢复队列。</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li><ol>
<li>操作同步</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><code>- (void)waitUntilAllOperationsAreFinished</code>; 阻塞当前线程，直到队列中的操作全部执行完毕。</p>
<ol>
<li><ol>
<li><ol>
<li>添加/获取操作</li>
</ol>
</li>
</ol>
</li>
</ol>
<ul>
<li><code>- (void)addOperationWithBlock:(void (^)(void))block</code>; 向队列中添加一个 NSBlockOperation 类型操作对象。</li>
<li><code>- (void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait</code>; 向队列中添加操作数组，<code>wait</code> 标志是否阻塞当前线程直到所有操作结束</li>
<li><code>- (NSArray *)operations;</code> 当前在队列中的操作数组（某个操作执行结束后会自动从这个数组清除）。</li>
<li><code>- (NSUInteger)operationCount;</code>当前队列中的操作数。</li>
</ul>
<ol>
<li><ol>
<li><ol>
<li>获取队列</li>
</ol>
</li>
</ol>
</li>
</ol>
<ul>
<li><code>+ (id)currentQueue;</code> 获取当前队列，如果当前线程不是在 <code>NSOperationQueue</code> 上运行则返回<code>nil</code>。</li>
<li><code>+ (id)mainQueue;</code> 获取主队列。</li>
</ul>
<blockquote>
<p>注意：</p>
</blockquote>
<ol>
<li>这里的暂停和取消（包括操作的取消和队列的取消）并不代表可以将当前的操作立即取消，而是当当前的操作执行完毕之后不再执行新的操作。</li>
<li>暂停和取消的区别就在于：暂停操作之后还可以恢复操作，继续向下执行；而取消操作之后，所有的操作就清空了，无法再接着执行剩下的操作。</li>
</ol>
<h4 id="NSThread-runloop实现常驻线程"><a href="#NSThread-runloop实现常驻线程" class="headerlink" title="NSThread+runloop实现常驻线程"></a><code>NSThread+runloop</code>实现常驻线程</h4><p><code>NSThread</code>在实际开发中比较常用到的场景就是去实现常驻线程。</p>
<p>由于每次开辟子线程都会消耗cpu，在需要频繁使用子线程的情况下，频繁开辟子线程会消耗大量的cpu，而且创建线程都是任务执行完成之后也就释放了，不能再次利用，那么如何创建一个线程可以让它可以再次工作呢？也就是创建一个常驻线程。<br>首先常驻线程既然是常驻，那么我们可以用<code>GCD</code>实现一个单例来保存<code>NSThread</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">+ (<span class="hljs-built_in">NSThread</span> *)shareThread &#123;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">NSThread</span> *shareThread = <span class="hljs-literal">nil</span>;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> oncePredicate;<br>    <br>    <span class="hljs-built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;<br>        <br>        shareThread = [[<span class="hljs-built_in">NSThread</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(threadTest) object:<span class="hljs-literal">nil</span>];<br><br>        [shareThread setName:<span class="hljs-string">@&quot;threadTest&quot;</span>];<br>        <br>        [shareThread start];<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> shareThread;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样创建的thread就不会销毁了吗？<br><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(test) onThread:[ViewController shareThread] withObject:<span class="hljs-literal">nil</span> waitUntilDone:<span class="hljs-literal">NO</span>];<br><br>- (<span class="hljs-keyword">void</span>)test<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;test:%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;<br><br><br></code></pre></td></tr></table></figure><br>并没有打印，说明<code>test方法</code>没有被调用。<br>那么可以用<code>runloop</code>来让线程常驻:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br>+ (<span class="hljs-built_in">NSThread</span> *)shareThread &#123;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">NSThread</span> *shareThread = <span class="hljs-literal">nil</span>;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> oncePredicate;<br>    <br>    <span class="hljs-built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;<br>        <br>        shareThread = [[<span class="hljs-built_in">NSThread</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(threadTest2) object:<span class="hljs-literal">nil</span>];<br>        <br>        [shareThread setName:<span class="hljs-string">@&quot;threadTest&quot;</span>];<br>        <br>        [shareThread start];<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> shareThread;<br>&#125;<br><br>+ (<span class="hljs-keyword">void</span>)threadTest<br>&#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        <br>        <span class="hljs-built_in">NSRunLoop</span> *runLoop = [<span class="hljs-built_in">NSRunLoop</span> currentRunLoop];<br>        <br>        [runLoop addPort:[<span class="hljs-built_in">NSMachPort</span> port] forMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span>];<br>        <br>        [runLoop run];<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>
<p>这时候再去调用<code>performSelector</code>就有打印了。</p>
<h4 id="自旋锁与互斥锁"><a href="#自旋锁与互斥锁" class="headerlink" title="自旋锁与互斥锁"></a>自旋锁与互斥锁</h4><p><img src="1782258-8ca7c2b6e5fe5352.png" alt=""></p>
<p><strong>自旋锁</strong>：</p>
<p>是一种用于保护多线程共享资源的锁，与一般互斥锁（mutex）不同之处在于当自旋锁尝试获取锁时以忙等待（busy waiting）的形式不断地循环检查锁是否可用。当上一个线程的任务没有执行完毕的时候（被锁住），那么下一个线程会一直等待（不会睡眠），当上一个线程的任务执行完毕，下一个线程会立即执行。<br>在多CPU的环境中，对持有锁较短的程序来说，使用自旋锁代替一般的互斥锁往往能够提高程序的性能。</p>
<p><strong>互斥锁</strong>：</p>
<p>当上一个线程的任务没有执行完毕的时候（被锁住），那么下一个线程会进入睡眠状态等待任务执行完毕，当上一个线程的任务执行完毕，下一个线程会自动唤醒然后执行任务。</p>
<p><strong>总结</strong>：</p>
<p>自旋锁会忙等: 所谓忙等，即在访问被锁资源时，调用者线程不会休眠，而是不停循环在那里，直到被锁资源释放锁。<br>互斥锁会休眠: 所谓休眠，即在访问被锁资源时，调用者线程会休眠，此时cpu可以调度其他线程工作。直到被锁资源释放锁。此时会唤醒休眠线程。</p>
<p><strong>优缺点</strong>：</p>
<p>自旋锁的优点在于，因为自旋锁不会引起调用者睡眠，所以不会进行线程调度，CPU时间片轮转等耗时操作。所有如果能在很短的时间内获得锁，自旋锁的效率远高于互斥锁。<br>　　缺点在于，自旋锁一直占用CPU，他在未获得锁的情况下，一直运行－－自旋，所以占用着CPU，如果不能在很短的时 间内获得锁，这无疑会使CPU效率降低。自旋锁不能实现递归调用。</p>
<p><strong>自旋锁</strong>：<code>atomic</code>、<code>OSSpinLock</code>、<code>dispatch_semaphore_t</code></p>
<p><strong>互斥锁</strong>：<code>pthread_mutex</code>、<code>@ synchronized</code>、<code>NSLock</code>、<code>NSConditionLock</code> 、<code>NSCondition</code>、<code>NSRecursiveLock</code>.</p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>NSOperation</tag>
        <tag>NSOperationQueue</tag>
        <tag>NSThread</tag>
        <tag>runloop</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（二）</title>
    <url>/2020/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p><img src="http://q96fa88b1.bkt.clouddn.com/gjk.jpg" alt=""></p>
<h2 id="2-数据结构与算法-线性表"><a href="#2-数据结构与算法-线性表" class="headerlink" title="2.数据结构与算法-线性表"></a>2.数据结构与算法-线性表</h2><blockquote>
<p>链表是一种线性表, 也是一种存储数据的数据结构.如下图：这种的一个节点中包含自身数据以及指向下一个节点的位置,一个嵌套着下一个. 这中结构就称之为链表.<br><img src="https://gitee.com/platojobs/images/raw/master/gitartos20200415193109.png" alt=""><br><img src="https://gitee.com/platojobs/images/raw/master/gitartos20200415203106.png" alt=""></p>
</blockquote>
<a id="more"></a>
<h3 id="2-1-线性表的顺序表示和实现"><a href="#2-1-线性表的顺序表示和实现" class="headerlink" title="2.1 线性表的顺序表示和实现"></a>2.1 线性表的顺序表示和实现</h3><h4 id="2-1-1-顺序表"><a href="#2-1-1-顺序表" class="headerlink" title="2.1.1 顺序表"></a>2.1.1 顺序表</h4><blockquote>
<p>ADT list{<br>Data:线性表的数据对象集合为{a1,a2,a,……an},每个元素的类型均为DataType，其中，除了第一个元素a1 外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an 外，每个元素有且只有一个直接后续元素，数据元素之间的关系是一对一的关系。<br>OPeration（操作）<br>InitList(&amp;L)           初始化表<br>操作结果：初始化操作，建立一个空的线性表L<br>DestroyList(&amp;L)        销毁表<br>初始条件：线性表L已存在<br>操作结果：销毁线性表L<br>ClearList(&amp;L)          清空表<br>初始条件：线性表L已存在<br>操作结果：将L重置为空表<br>ListEmpty(L)           表是否为空<br>初始条件：线性表L已存在<br>操作结果：若L为空表，则返回true，否则返回false<br>ListLength(L)          表长度（元素个数）<br>初始条件：线性表L已存在<br>操作结果：返回L中数据元素的个数<br>……<br>GetElem(L,i,&amp;e)        获取元素<br>初始条件: 线性表L已存在,且1&lt;=i&lt;ListLength(L)<br>操作结果: 用e返回L中第i个数据元素的值;<br>LocateElem(L,e)<br>初始条件: 线性表L已存在<br>操作结果: 返回L中第1个值与e相同的元素在L中的位置. 若数据不不存在则返回0;<br>PriorElem(L, cur_e,&amp;pre_e);<br>初始条件: 线性表L已存在<br>操作结果: 若cur_e是L的数据元素,且不不是第⼀一个,则⽤用pre_e返回其前驱,否则操作失败.<br>NextElem(L, cur_e,&amp;next_e);<br>初始条件: 线性表L已存在<br>操作结果: 若cur_e是L的数据元素,且不不是最后⼀一个,则⽤用next_e返回其后继,否则操作失败.<br>……<br>ListInsert(L,i,e);<br>初始条件: 线性表L已存在,且1&lt;=i&lt;=listLength(L)<br>操作结果: 在L中第i个位置之前插⼊入新的数据元素e,L⻓长度加1.<br>ListDelete(L,i);<br>初始条件: 线性表L已存在,且1&lt;=i&lt;=listLength(L)<br>操作结果: 删除L的第i个元素,L的⻓长度减1.<br>TraverseList(L);<br>初始条件: 线性表L已存在<br>操作结果: 对线性表L进⾏行行遍历,在遍历的过程中对L的每个结点访问1次.<br>}ADT List.</p>
</blockquote>
<h4 id="2-1-2-顺序表基本操作"><a href="#2-1-2-顺序表基本操作" class="headerlink" title="2.1.2 顺序表基本操作"></a>2.1.2 顺序表基本操作</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdlib.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;math.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;time.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 100</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRUE 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FALSE 0</span><br><br><span class="hljs-comment">//KElementType类型根据实际情况而定，这里假设为int</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> KElementType;<br><span class="hljs-comment">//KStatus是函数的类型,其值是函数结果状态代码，如OK等</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> KStatus;<br><br><br><span class="hljs-comment">//顺序表结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KSequenceList</span> &#123;</span><br>    KElementType *data;<br>    <span class="hljs-keyword">int</span> length;<br>&#125;KSList;<br><br><span class="hljs-comment">// 1 顺序表初始化</span><br><span class="hljs-function">KStatus <span class="hljs-title">initSequenceList</span><span class="hljs-params">(KSList *L)</span> </span>&#123;<br>    <br>    <span class="hljs-comment">//为顺序表分配一个大小为MAXSIZE 的数组空间</span><br>    L-&gt;data = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(KElementType) * MAXSIZE);<br>    <span class="hljs-comment">//存储分配失败直接退出</span><br>    <span class="hljs-keyword">if</span>(!L-&gt;data) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-comment">//空表长度为0</span><br>    L-&gt;length = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 2 顺序表的插入</span><br><span class="hljs-comment">// 初始条件：顺序线性表L已存在,1≤i≤ListLength(L);</span><br><span class="hljs-comment">// 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1</span><br><span class="hljs-function">KStatus <span class="hljs-title">insertElement</span><span class="hljs-params">(KSList *L, <span class="hljs-keyword">int</span> i, KElementType e)</span> </span>&#123;<br>    <br>    <span class="hljs-comment">//边界条件判断</span><br>    <span class="hljs-comment">//1.1 出入的索引 i 合法性判断, 不能超过链表总长度</span><br>    <span class="hljs-keyword">if</span>((i &lt; <span class="hljs-number">1</span>) || (i &gt; L-&gt;length+<span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-comment">//1.2 存储空间是否已满</span><br>    <span class="hljs-keyword">if</span>(L-&gt;length == MAXSIZE) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    <span class="hljs-comment">//1.3 插入数据如果不在表尾部，则先往后移动腾出位置给要插入的元素</span><br>    <span class="hljs-keyword">if</span>(i &lt;= L-&gt;length) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = L-&gt;length<span class="hljs-number">-1</span>; j &gt;= i<span class="hljs-number">-1</span>; j--) &#123;<br>            <span class="hljs-comment">//插入位置后面的元素都移动1个位置，让出第i个位置</span><br>            L-&gt;data[i+<span class="hljs-number">1</span>] = L-&gt;data[i];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//1.4 将新元素赋值到腾出的位置，完成插入</span><br>    L-&gt;data[i<span class="hljs-number">-1</span>] = e;<br>    <br>    <span class="hljs-comment">//1.5 链表长度增加1</span><br>    ++L-&gt;length;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br><span class="hljs-comment">// 3. 顺序表的取值</span><br><span class="hljs-function">KStatus <span class="hljs-title">getElement</span><span class="hljs-params">(KSList L, <span class="hljs-keyword">int</span> i, KElementType *e)</span> </span>&#123;<br>    <br>    <span class="hljs-comment">//边界条件判断，i不能超过总长度</span><br>    <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; L.length) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    <span class="hljs-comment">//直接取出第i个元素的值，索引下标对应为i-1 (下标默认从0开始)</span><br>    *e = L.data[i<span class="hljs-number">-1</span>];<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 4. 顺序表删除</span><br><span class="hljs-comment">//初始条件：顺序线性表L已存在，1≤i≤ListLength(L)</span><br><span class="hljs-comment">//操作结果: 删除L的第i个数据元素,L的长度减1</span><br><span class="hljs-function">KStatus <span class="hljs-title">deleteElement</span><span class="hljs-params">(KSList *L, <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <br>    <span class="hljs-comment">//边界条件判断</span><br>    <span class="hljs-comment">//线性表是否为空</span><br>    <span class="hljs-keyword">if</span>(L-&gt;length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-comment">//i值合法性判断</span><br>    <span class="hljs-keyword">if</span>((i &lt; <span class="hljs-number">1</span>) || (i &gt; L-&gt;length+<span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; L-&gt;length; j++) &#123;<br>        <span class="hljs-comment">//被删除的元素后面的所有元素往前移动一个位置</span><br>        L-&gt;data[j<span class="hljs-number">-1</span>] = L-&gt;data[j];<br>    &#125;<br>    <br>    <span class="hljs-comment">//表长度减1</span><br>    L-&gt;length--;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 5. 清空顺序表</span><br><span class="hljs-comment">//初始条件：顺序线性表L已存在。操作结果：将L重置为空表</span><br><span class="hljs-function">KStatus <span class="hljs-title">clearList</span><span class="hljs-params">(KSList *L)</span> </span>&#123;<br>    L-&gt;length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 6. 判断顺序表清空</span><br><span class="hljs-comment">//初始条件：顺序线性表L已存在。操作结果：若L为空表，则返回TRUE，否则返回FALSE</span><br><span class="hljs-function">KStatus <span class="hljs-title">isListEmpty</span><span class="hljs-params">(KSList L)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> L.length == <span class="hljs-number">0</span> ;<br>&#125;<br><br><span class="hljs-comment">// 7. 获取顺序表表长度</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getListLength</span><span class="hljs-params">(KSList L)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> L.length;<br>&#125;<br><br><span class="hljs-comment">// 8. 遍历顺序表</span><br><span class="hljs-comment">//初始条件：顺序线性表L已存在</span><br><span class="hljs-comment">//操作结果：依次对L的每个数据元素输出</span><br><span class="hljs-function">KStatus <span class="hljs-title">traverseList</span><span class="hljs-params">(KSList L)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d.\n&quot;</span>,L.data[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 9. 查找顺序表元素下标</span><br><span class="hljs-comment">//初始条件：顺序线性表L已存在</span><br><span class="hljs-comment">//操作结果：返回L中第1个与e满足关系的数据元素的位序。</span><br><span class="hljs-comment">//若这样的数据元素不存在，则返回值为0</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getElementIndex</span><span class="hljs-params">(KSList L, KElementType e)</span> </span>&#123;<br>    <span class="hljs-comment">//边界条件判断</span><br>    <span class="hljs-keyword">if</span> (L.length == <span class="hljs-number">0</span> ) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">//顺序查找</span><br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; L.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (L.data[i] == e) &#123;<span class="hljs-keyword">break</span>;&#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (i &gt;= L.length) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-comment">// 10. 单元测试</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    KSList L1;<br>    <span class="hljs-comment">//KSList L2;</span><br>    KElementType e;<br>    KStatus iStatus;<br>    <br>    <span class="hljs-comment">//1.1 顺序表初始化</span><br>    iStatus = initSequenceList(&amp;L1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;初始化L1后: L.Length = %d\n&quot;</span>, L1.length);<br>    <br>    <span class="hljs-comment">//1.2 顺序表数据插入</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">5</span>;j++)&#123;<br>        iStatus = insertElement(&amp;L1, <span class="hljs-number">1</span>, j);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入数据L1长度: %d\n&quot;</span>,L1.length);<br>    <br>    <span class="hljs-comment">//1.3 顺序表取值</span><br>    getElement(L1, <span class="hljs-number">5</span>, &amp;e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;顺序表L1第5个元素的值为:%d\n&quot;</span>,e);<br>    <br>    <span class="hljs-comment">//1.4 顺序表删除第2个元素</span><br>    deleteElement(&amp;L1, <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;顺序表L1删除第%d元素,长度为%d\n&quot;</span>,<span class="hljs-number">2</span>,L1.length);<br>    <br>    <span class="hljs-comment">//1.5 清空顺序表</span><br>    iStatus = clearList(&amp;L1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;清空L1后,L.length = %d\n&quot;</span>,L1.length);<br>    <br>    <span class="hljs-comment">//1.6 判断List是否为空</span><br>    iStatus = isListEmpty(L1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;L1是否空：i=%d(1:是 0:否)\n&quot;</span>,iStatus);<br>    <br>    <span class="hljs-comment">//1.8 遍历打印顺序表</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">5</span>;j++)&#123;<br>        iStatus = insertElement(&amp;L1, <span class="hljs-number">1</span>, j);<br>    &#125;<br>    traverseList(L1);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;<br>    <span class="hljs-comment">// insert code here...</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>);<br>    test();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="2-1-2-1-上述输出结果"><a href="#2-1-2-1-上述输出结果" class="headerlink" title="2.1.2.1  上述输出结果"></a>2.1.2.1  上述输出结果</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">Hello, World!<br>初始化L1后: L.Length = <span class="hljs-number">0</span><br>插入数据L1长度: <span class="hljs-number">5</span><br>顺序表L1第<span class="hljs-number">5</span>个元素的值为:<span class="hljs-number">446</span><br>顺序表L1删除第<span class="hljs-number">2</span>元素,长度为<span class="hljs-number">4</span><br>清空L1后,L.length = <span class="hljs-number">0</span><br>L1是否空：i=<span class="hljs-number">1</span>(<span class="hljs-number">1</span>:是 <span class="hljs-number">0</span>:否)<br><span class="hljs-number">5.</span><br><span class="hljs-number">0.</span><br><span class="hljs-number">0.</span><br><span class="hljs-number">446.</span><br><span class="hljs-number">446.</span><br><br>Program ended with <span class="hljs-built_in">exit</span> code: <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure>
<h4 id="2-1-3-线性表之单链表"><a href="#2-1-3-线性表之单链表" class="headerlink" title="2.1.3 线性表之单链表"></a>2.1.3 线性表之单链表</h4><h5 id="2-1-3-1-单链表逻辑状态"><a href="#2-1-3-1-单链表逻辑状态" class="headerlink" title="2.1.3.1 单链表逻辑状态"></a>2.1.3.1 单链表逻辑状态</h5><p><img src="https://gitee.com/platojobs/images/raw/master/gitartos20200415203101.png" alt=""></p>
<h5 id="2-1-3-2-增加头结点的单链表逻辑状态"><a href="#2-1-3-2-增加头结点的单链表逻辑状态" class="headerlink" title="2.1.3.2 增加头结点的单链表逻辑状态"></a>2.1.3.2 增加头结点的单链表逻辑状态</h5><p><img src="https://gitee.com/platojobs/images/raw/master/gitartos20200415203102.png" alt=""></p>
<h5 id="2-1-3-3-单链表为什么要增加头结点"><a href="#2-1-3-3-单链表为什么要增加头结点" class="headerlink" title="2.1.3.3 单链表为什么要增加头结点"></a>2.1.3.3 单链表为什么要增加头结点</h5><p><img src="https://gitee.com/platojobs/images/raw/master/gitartos20200415203104.png" alt=""></p>
<h5 id="2-1-3-4-单链表示例DEmo"><a href="#2-1-3-4-单链表示例DEmo" class="headerlink" title="2.1.3.4 单链表示例DEmo"></a>2.1.3.4 单链表示例DEmo</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;string.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ctype.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdlib.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;math.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;time.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRUE 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FALSE 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK 1</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 20</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> KStatus;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> KElementType;<br><br><span class="hljs-comment">//定义结点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KNodeInfo</span>&#123;</span><br>    KElementType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KNodeInfo</span> *<span class="hljs-title">next</span>;</span><br>&#125;Node;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KNodeInfo</span> *<span class="hljs-title">KLinkList</span>;</span><br><br><br><span class="hljs-comment">//1. 初始化单链表</span><br><span class="hljs-function">KStatus <span class="hljs-title">initList</span><span class="hljs-params">(KLinkList *L)</span> </span>&#123;<br>    <br>    <span class="hljs-comment">//生成头结点，并使用L指向此头结点</span><br>    *L = (KLinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    <span class="hljs-comment">//如果分配空间失败，直接退出</span><br>    <span class="hljs-keyword">if</span>(*L == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-comment">//将头结点的指针域置为空</span><br>    (*L)-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//2. 单链表插入</span><br><span class="hljs-comment">//初始条件:顺序线性表L已存在,1≤i≤ListLength(L);</span><br><span class="hljs-comment">//操作结果：在L中第i个位置之后插入新的数据元素e，L的长度加1;</span><br><span class="hljs-function">KStatus <span class="hljs-title">insertElement</span><span class="hljs-params">(KLinkList *L, <span class="hljs-keyword">int</span> i, KElementType e)</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;<br>    KLinkList p, s;<br>    p = *L;<br>    <br>    <span class="hljs-comment">//寻找第i-1个结点</span><br>    <span class="hljs-keyword">while</span> (p &amp;&amp; j &lt; i) &#123;<br>        p = p-&gt;next;<br>        ++j;<br>    &#125;<br>    <span class="hljs-comment">//判断第i个元素是否存在</span><br>    <span class="hljs-keyword">if</span>(!p || j &gt; i) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    <span class="hljs-comment">//生成新结点s</span><br>    s = (KLinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    <span class="hljs-comment">//将e赋值给s的数值域</span><br>    s-&gt;data = e;<br>    <span class="hljs-comment">//将p的后继结点赋值给s的后继</span><br>    s-&gt;next = p-&gt;next;<br>    <span class="hljs-comment">//将s赋值给p的后继</span><br>    p-&gt;next = s;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//3. 单链表取值</span><br><span class="hljs-comment">//初始条件: 顺序线性表L已存在,1≤i≤ListLength(L);</span><br><span class="hljs-comment">//操作结果：用e返回L中第i个数据元素的值</span><br><span class="hljs-function">KStatus <span class="hljs-title">getElement</span><span class="hljs-params">(KLinkList L, <span class="hljs-keyword">int</span> i, KElementType *e)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//将结点p,指向链表L的第一个结点</span><br>    KLinkList p = L-&gt;next;<br>    <br>    <span class="hljs-comment">//查找结点,p不为空,且计算j不等于i,则循环继续</span><br>    <span class="hljs-keyword">while</span> (p &amp;&amp; j &lt; i) &#123;<br>        p = p-&gt;next;<br>        ++j;<br>    &#125;<br>    <span class="hljs-comment">//如果p为空或者j&gt;i,则 返回error</span><br>    <span class="hljs-keyword">if</span>(!p || j &gt; i) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    *e = p-&gt;data;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//4. 单链表删除元素</span><br><span class="hljs-comment">//初始条件：顺序线性表L已存在，1≤i≤ListLength(L)</span><br><span class="hljs-comment">//操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1</span><br><span class="hljs-function">KStatus <span class="hljs-title">deleteElement</span><span class="hljs-params">(KLinkList *L, <span class="hljs-keyword">int</span> i, KElementType *e)</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;<br>    KLinkList p,q;<br>    p = (*L)-&gt;next;<br>    <br>    <span class="hljs-comment">//查找第i-1个结点，p指向该结点</span><br>    <span class="hljs-keyword">while</span> (p-&gt;next &amp;&amp; j &lt; (i<span class="hljs-number">-1</span>)) &#123;<br>        p = p-&gt;next;<br>        ++j;<br>    &#125;<br>    <br>    <span class="hljs-comment">//当i&gt;n 或者 i&lt;i 时，删除位置不合理</span><br>    <span class="hljs-keyword">if</span> (!(p-&gt;next) || (j&gt;i<span class="hljs-number">-1</span>)) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    <span class="hljs-comment">//q指向要删除的结点</span><br>    q = p-&gt;next;<br>    <span class="hljs-comment">//将q的后继赋值给p的后继</span><br>    p-&gt;next = q-&gt;next;<br>    <span class="hljs-comment">//将q结点中的数据赋值给e</span><br>    *e = q-&gt;data;<br>    <span class="hljs-comment">//释放内存</span><br>    <span class="hljs-built_in">free</span>(q);<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//5. 遍历单链表</span><br><span class="hljs-comment">//初始条件：顺序线性表L已存在</span><br><span class="hljs-comment">//操作结果：依次对L的每个数据元素输出</span><br><span class="hljs-function">KStatus <span class="hljs-title">traverseList</span><span class="hljs-params">(KLinkList L)</span> </span>&#123;<br>    KLinkList p = L-&gt;next;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,p-&gt;data);<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//6. 清空单链表</span><br><span class="hljs-comment">//初始条件：顺序线性表L已存在。操作结果：将L重置为空表</span><br><span class="hljs-function">KStatus <span class="hljs-title">clearList</span><span class="hljs-params">(KLinkList *L)</span> </span>&#123;<br>    <br>    KLinkList p, q;<br>    <span class="hljs-comment">//指向第一个结点</span><br>    p = (*L)-&gt;next;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        <span class="hljs-comment">//遍历删除每个结点，并释放内存</span><br>        q = p-&gt;next;<br>        <span class="hljs-built_in">free</span>(p);<br>        p = q;<br>    &#125;<br>    <span class="hljs-comment">//头结点指针域赋值为空</span><br>    (*L)-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//7. 创建单链表：头插入法</span><br><span class="hljs-comment">//随机产生n个元素值,建立带表头结点的单链线性表L(前插法)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createListByHeadInsert</span><span class="hljs-params">(KLinkList *L, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    KLinkList p;<br>    <span class="hljs-comment">//建立1个带头结点的单链表</span><br>    *L = (KLinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    (*L)-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-comment">//循环前插入随机数据</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">//生成新结点</span><br>        p = (KLinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>        <span class="hljs-comment">//i赋值给新结点</span><br>        p-&gt;data = i;<br>        <br>        <span class="hljs-comment">//将结点p插入到头结点之后</span><br>        p-&gt;next = (*L)-&gt;next;<br>        (*L)-&gt;next = p;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//8. 创建单链表：尾部插入法</span><br><span class="hljs-comment">//随机产生n个元素值,建立带表头结点的单链线性表L(后插法)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createListByTailInsert</span><span class="hljs-params">(KLinkList *L, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <br>    KLinkList p, r;<br>    <br>    <span class="hljs-comment">//建立1个带头结点的单链表</span><br>    *L = (KLinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    (*L)-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-comment">//让r指针指向尾部结点</span><br>    r = *L;<br>    <br>    <span class="hljs-comment">//循环创建链表结点，尾部插入</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">//生成新结点</span><br>        p = (Node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>        <span class="hljs-comment">//赋值随机数i</span><br>        p-&gt;data = i;<br>        <br>        <span class="hljs-comment">//尾部插入新结点</span><br>        <span class="hljs-comment">//将表尾终端结点的指针指向新结点</span><br>        r-&gt;next = p;<br>        <span class="hljs-comment">//将当前的新结点定义为表尾终端结点</span><br>        r = p;<br>    &#125;<br>    <br>    <span class="hljs-comment">//将尾部指针next=NULL</span><br>    r-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <br>&#125;<br><br><span class="hljs-comment">//9. 单元测试</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        KStatus iStatus;<br>        KLinkList L;<br>        KElementType e;<br>        <br>        <span class="hljs-comment">//2.1 单链表初始化</span><br>        iStatus = initList(&amp;L);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;L 是否初始化成功?(0:失败,1:成功) %d\n&quot;</span>,iStatus);<br>        <br>        <span class="hljs-comment">//2.2 单链表插入数据</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">10</span>;j++)<br>        &#123;<br>            iStatus = insertElement(&amp;L, <span class="hljs-number">1</span>, j);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;L 插入后\n&quot;</span>);<br>        traverseList(L);<br>        <br>        <span class="hljs-comment">//2.3 单链表获取元素</span><br>        getElement(L,<span class="hljs-number">5</span>,&amp;e);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第5个元素的值为：%d\n&quot;</span>,e);<br>        <br>        <span class="hljs-comment">//2.4 删除第5个元素</span><br>        iStatus = deleteElement(&amp;L, <span class="hljs-number">5</span>, &amp;e);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除第5个元素值为:%d\n&quot;</span>,e);<br>        traverseList(L);<br>        <br>        <span class="hljs-comment">//3.1 前插法整理创建链表L</span><br>        iStatus = clearList(&amp;L);<br>        createListByHeadInsert(&amp;L, <span class="hljs-number">20</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;整理创建L的元素(前插法):\n&quot;</span>);<br>        traverseList(L);<br>        <br>        <span class="hljs-comment">//3.2 后插法整理创建链表L</span><br>        iStatus = clearList(&amp;L);<br>        createListByTailInsert(&amp;L, <span class="hljs-number">20</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;整理创建L的元素(后插法):\n&quot;</span>);<br>        traverseList(L);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;<br>    <span class="hljs-comment">// insert code here...</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>);<br>    test();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-2-线性表存储结构和实现"><a href="#2-2-线性表存储结构和实现" class="headerlink" title="2.2 线性表存储结构和实现"></a>2.2 线性表存储结构和实现</h3><h4 id="2-2-1-线性表的顺序存储结构"><a href="#2-2-1-线性表的顺序存储结构" class="headerlink" title="2.2.1 线性表的顺序存储结构"></a>2.2.1 线性表的顺序存储结构</h4><blockquote>
<p>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素</p>
</blockquote>
<h5 id="2-2-1-1-顺序存储方式"><a href="#2-2-1-1-顺序存储方式" class="headerlink" title="2.2.1.1 顺序存储方式"></a>2.2.1.1 顺序存储方式</h5><p>顺序存储方式：<br>(1)描述顺序存储结构需要三个属性：</p>
<p>存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置<br>线性表的最大存储容量：数组长度MaxSize<br>线性表的当前长度：length</p>
<h5 id="2-2-1-2-数组长度与线性表长度的区别"><a href="#2-2-1-2-数组长度与线性表长度的区别" class="headerlink" title="2.2.1.2 数组长度与线性表长度的区别"></a>2.2.1.2 数组长度与线性表长度的区别</h5><p>(1)数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的</p>
<p>(2)线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的</p>
<p>(3)线性表的长度应该小于等于数组的长度</p>
<h5 id="2-2-1-3-地址计算方法"><a href="#2-2-1-3-地址计算方法" class="headerlink" title="2.2.1.3 地址计算方法??"></a>2.2.1.3 地址计算方法??</h5><h5 id="2-2-1-4-线性表顺序存储的优缺点"><a href="#2-2-1-4-线性表顺序存储的优缺点" class="headerlink" title="2.2.1.4 线性表顺序存储的优缺点"></a>2.2.1.4 线性表顺序存储的优缺点</h5><ul>
<li><p>优点：<br> 1.无须为表示表中元素之间的逻辑关系而增加额外的存储空间<br> 2.可以快速地存取表中任一位置的元素。</p>
</li>
<li><p>缺点：</p>
<ol>
<li>插入和删除操作需要移动大量元素</li>
<li>当线性表长度变化较大时，难以确定存储空间的容量</li>
<li>造成存储空间的<code>碎片</code></li>
</ol>
</li>
</ul>
<h4 id="2-2-2-线性表的链式存储结构"><a href="#2-2-2-线性表的链式存储结构" class="headerlink" title="2.2.2 线性表的链式存储结构"></a>2.2.2 线性表的链式存储结构</h4><h5 id="2-2-2-1-线性表链式存储结构定义"><a href="#2-2-2-1-线性表链式存储结构定义" class="headerlink" title="2.2.2.1 线性表链式存储结构定义"></a>2.2.2.1 线性表链式存储结构定义</h5><p>(1)线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。这就意味着，这些数据元素可以存在内存未被占用的任意位置</p>
<p>(2)链表的每个结点中只包含一个指针域，所以叫做单链表<br>(3)链表中第一个结点的存储位置叫做头指针<br>(4)线性链表的最后一个结点指针为“空”</p>
<h5 id="2-2-2-2-头指针与头节点的异同"><a href="#2-2-2-2-头指针与头节点的异同" class="headerlink" title="2.2.2.2 头指针与头节点的异同"></a>2.2.2.2 头指针与头节点的异同</h5><p><img src="https://gitee.com/platojobs/images/raw/master/gitartos20200415193102.png" alt=""></p>
<h3 id="2-3-线性表的循环链表（设计与实现增删改查等）"><a href="#2-3-线性表的循环链表（设计与实现增删改查等）" class="headerlink" title="2.3 线性表的循环链表（设计与实现增删改查等）"></a>2.3 线性表的循环链表（设计与实现增删改查等）</h3><blockquote>
<p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表</p>
</blockquote>
<p><code>单向循环链表</code>结点的定义跟单链表一样，区别就是尾结点执行头结点，形成一个环。 如下图（1）表示一个单向循环链表，由尾结点指向头结点：</p>
<p><img src="https://gitee.com/platojobs/images/raw/master/gitartos20200415203502.png" alt=""></p>
<p>我们再来回顾一下单向链表的结构图：如下图：图2<br><img src="https://gitee.com/platojobs/images/raw/master/gitartos20200415203501.png" alt=""></p>
<blockquote>
<p>我们对比看，可以明显的看出，单向循环链表和单向链表的区别，仅仅是多了一个尾结点指针指向头结点的过程，他们的结点定义是一样的。</p>
</blockquote>
<h4 id="2-3-1-单向循环链表的操作"><a href="#2-3-1-单向循环链表的操作" class="headerlink" title="2.3.1 单向循环链表的操作"></a>2.3.1 单向循环链表的操作</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;string.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ctype.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdlib.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;math.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;time.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRUE 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FALSE 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK 1</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 20 <span class="hljs-comment">/* 存储空间初始分配量 */</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> Status;<span class="hljs-comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<span class="hljs-comment">/* ElemType类型根据实际情况而定，这里假设为int */</span><br><br><span class="hljs-comment">//定义结点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125;Node;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">LinkList</span>;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 4.1 循环链表创建!</span><br><span class="hljs-comment"> 2种情况:① 第一次开始创建; ②已经创建,往里面新增数据</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> 1. 判断是否第一次创建链表</span><br><span class="hljs-comment">    YES-&gt;创建一个新结点,并使得新结点的next 指向自身; (*L)-&gt;next = (*L);</span><br><span class="hljs-comment">    NO-&gt; 找链表尾结点,将尾结点的next = 新结点. 新结点的next = (*L);</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">Status <span class="hljs-title">CreateList</span><span class="hljs-params">(LinkList *L)</span></span>&#123;<br><br>    <span class="hljs-keyword">int</span> item;<br>    LinkList temp = <span class="hljs-literal">NULL</span>;<br>    LinkList target = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入节点的值，输入0结束\n&quot;</span>);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;item);<br>        <span class="hljs-keyword">if</span>(item==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        <br>          <span class="hljs-comment">//如果输入的链表是空。则创建一个新的节点，使其next指针指向自己  (*head)-&gt;next=*head;</span><br>        <span class="hljs-keyword">if</span>(*L==<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            *L = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>            <span class="hljs-keyword">if</span>(!L)<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>            (*L)-&gt;data=item;<br>            (*L)-&gt;next=*L;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>           <span class="hljs-comment">//输入的链表不是空的，寻找链表的尾节点，使尾节点的next=新节点。新节点的next指向头节点</span><br>            <br>            <span class="hljs-keyword">for</span> (target = *L; target-&gt;next != *L; target = target-&gt;next);<br>            <br>            temp=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>            <br>            <span class="hljs-keyword">if</span>(!temp) <span class="hljs-keyword">return</span> ERROR;<br>            <br>            temp-&gt;data=item;<br>            temp-&gt;next=*L;  <span class="hljs-comment">//新节点指向头节点</span><br>            target-&gt;next=temp;<span class="hljs-comment">//尾节点指向新节点</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">CreateList2</span><span class="hljs-params">(LinkList *L)</span></span>&#123;<br>    <br>    <span class="hljs-keyword">int</span> item;<br>    LinkList temp = <span class="hljs-literal">NULL</span>;<br>    LinkList target = <span class="hljs-literal">NULL</span>;<br>    LinkList r = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入新的结点, 当输入0时结束!\n&quot;</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;item);<br>        <span class="hljs-keyword">if</span> (item == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">//第一次创建</span><br>        <span class="hljs-keyword">if</span>(*L == <span class="hljs-literal">NULL</span>)&#123;<br>            <br>            *L = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>            <span class="hljs-keyword">if</span>(!*L) <span class="hljs-keyword">return</span> ERROR;<br>            (*L)-&gt;data = item;<br>            (*L)-&gt;next = *L;<br>            r = *L;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <br>            temp = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>            <span class="hljs-keyword">if</span>(!temp) <span class="hljs-keyword">return</span>  ERROR;<br>            temp-&gt;data = item;<br>            temp-&gt;next = *L;<br>            r-&gt;next = temp;<br>            <br>            r = temp;<br>        &#125;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br><br><span class="hljs-comment">//4.2 遍历循环链表，循环链表的遍历最好用do while语句，因为头节点就有值</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(LinkList p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//如果链表是空</span><br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打印的链表为空!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>        <br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        LinkList temp;<br>        temp = p;<br>        <span class="hljs-keyword">do</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%5d&quot;</span>,temp-&gt;data);<br>            temp = temp-&gt;next;<br>        &#125;<span class="hljs-keyword">while</span> (temp != p);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-comment">//4.3 循环链表插入数据</span><br><span class="hljs-function">Status <span class="hljs-title">ListInsert</span><span class="hljs-params">(LinkList *L, <span class="hljs-keyword">int</span> place, <span class="hljs-keyword">int</span> num)</span></span>&#123;<br>    <br>    LinkList temp ,target;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">if</span> (place == <span class="hljs-number">1</span>) &#123;<br>        <br>        <span class="hljs-comment">//如果插入的位置为1,则属于插入首元结点,所以需要特殊处理</span><br>        <span class="hljs-comment">//1. 创建新结点temp,并判断是否创建成功,成功则赋值,否则返回ERROR;</span><br>        <span class="hljs-comment">//2. 找到链表最后的结点_尾结点,</span><br>        <span class="hljs-comment">//3. 让新结点的next 执行头结点.</span><br>        <span class="hljs-comment">//4. 尾结点的next 指向新的头结点;</span><br>        <span class="hljs-comment">//5. 让头指针指向temp(临时的新结点)</span><br>        <br>        temp = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>        <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> ERROR;<br>        &#125;<br>        temp-&gt;data = num;<br>        <br>        <span class="hljs-keyword">for</span> (target = *L; target-&gt;next != *L; target = target-&gt;next);<br>        <br>        temp-&gt;next = *L;<br>        target-&gt;next = temp;<br>        *L = temp;<br>        <br>    &#125;<span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">//如果插入的位置在其他位置;</span><br>        <span class="hljs-comment">//1. 创建新结点temp,并判断是否创建成功,成功则赋值,否则返回ERROR;</span><br>        <span class="hljs-comment">//2. 先找到插入的位置,如果超过链表长度,则自动插入队尾;</span><br>        <span class="hljs-comment">//3. 通过target找到要插入位置的前一个结点, 让target-&gt;next = temp;</span><br>        <span class="hljs-comment">//4. 插入结点的前驱指向新结点,新结点的next 指向target原来的next位置 ;</span><br>        <br>        temp = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>        <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> ERROR;<br>        &#125;<br>        temp-&gt;data = num;<br>        <br>        <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">1</span>,target = *L; target-&gt;next != *L &amp;&amp; i != place - <span class="hljs-number">1</span>; target = target-&gt;next,i++) ;<br>        <br>        temp-&gt;next = target-&gt;next;<br>        target-&gt;next = temp;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//4.4 循环链表删除元素</span><br><span class="hljs-function">Status  <span class="hljs-title">LinkListDelete</span><span class="hljs-params">(LinkList *L,<span class="hljs-keyword">int</span> place)</span></span>&#123;<br>    <br>    LinkList temp,target;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-comment">//temp 指向链表首元结点</span><br>    temp = *L;<br>    <span class="hljs-keyword">if</span>(temp == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">if</span> (place == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">//①.如果删除到只剩下首元结点了,则直接将*L置空;</span><br>        <span class="hljs-keyword">if</span>((*L)-&gt;next == (*L))&#123;<br>            (*L) = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-keyword">return</span> OK;<br>        &#125;<br>        <span class="hljs-comment">//②.链表还有很多数据,但是删除的是首结点;</span><br>        <span class="hljs-comment">//1. 找到尾结点, 使得尾结点next 指向头结点的下一个结点 target-&gt;next = (*L)-&gt;next;</span><br>        <span class="hljs-comment">//2. 新结点做为头结点,则释放原来的头结点</span><br>        <br>        <span class="hljs-keyword">for</span> (target = *L; target-&gt;next != *L; target = target-&gt;next);<br>        temp = *L;<br>        <br>        *L = (*L)-&gt;next;<br>        target-&gt;next = *L;<br>        <span class="hljs-built_in">free</span>(temp);<br>    &#125;<span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">//如果删除其他结点--其他结点</span><br>        <span class="hljs-comment">//1. 找到删除结点前一个结点target</span><br>        <span class="hljs-comment">//2. 使得target-&gt;next 指向下一个结点</span><br>        <span class="hljs-comment">//3. 释放需要删除的结点temp</span><br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>,target = *L;target-&gt;next != *L &amp;&amp; i != place <span class="hljs-number">-1</span>;target = target-&gt;next,i++);<br>            temp = target-&gt;next;<br>            target-&gt;next = temp-&gt;next;<br>            <span class="hljs-built_in">free</span>(temp);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br><span class="hljs-comment">//4.5 循环链表查询值</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findValue</span><span class="hljs-params">(LinkList L,<span class="hljs-keyword">int</span> value)</span></span>&#123;<br>    <br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    LinkList p;<br>    p = L;<br>    <br>    <span class="hljs-comment">//寻找链表中的结点 data == value</span><br>    <span class="hljs-keyword">while</span> (p-&gt;data != value &amp;&amp; p-&gt;next != L) &#123;<br>        i++;<br>        p = p-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-comment">//当尾结点指向头结点就会直接跳出循环,所以要额外增加一次判断尾结点的data == value;</span><br>    <span class="hljs-keyword">if</span> (p-&gt;next == L &amp;&amp; p-&gt;data != value) &#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> i;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;<br>    <span class="hljs-comment">// insert code here...</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, kongyulu!\n&quot;</span>);<br>    <br>    LinkList head;<br>    <span class="hljs-keyword">int</span> place,num;<br>    <span class="hljs-keyword">int</span> iStatus;<br>    <br>    <span class="hljs-comment">//iStatus = CreateList(&amp;head);</span><br>    iStatus = CreateList2(&amp;head);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;原始的链表：\n&quot;</span>);<br>    show(head);<br>    <br><span class="hljs-comment">//    printf(&quot;输入要插入的位置和数据用空格隔开：&quot;);</span><br><span class="hljs-comment">//    scanf(&quot;%d %d&quot;,&amp;place,&amp;num);</span><br><span class="hljs-comment">//    iStatus = ListInsert(&amp;head,place,num);</span><br><span class="hljs-comment">//    show(head);</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入要删除的位置：&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;place);<br>    LinkListDelete(&amp;head,place);<br>    show(head);<br>    <br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入你想查找的值:&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num);<br>    place=findValue(head,num);<br>    <span class="hljs-keyword">if</span>(place!=<span class="hljs-number">-1</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;找到的值的位置是place = %d\n&quot;</span>,place);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;没找到值\n&quot;</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h4 id="2-3-2-输出结果"><a href="#2-3-2-输出结果" class="headerlink" title="2.3.2 输出结果"></a>2.3.2 输出结果</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><br>Hello, kongyulu!<br>请输入新的结点, 当输入<span class="hljs-number">0</span>时结束!<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br><span class="hljs-number">6</span><br><span class="hljs-number">0</span><br>原始的链表：<br>    <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span>    <span class="hljs-number">4</span>    <span class="hljs-number">5</span>    <span class="hljs-number">6</span><br>输入要删除的位置：<span class="hljs-number">1</span><br>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span>    <span class="hljs-number">4</span>    <span class="hljs-number">5</span>    <span class="hljs-number">6</span><br>输入你想查找的值:<span class="hljs-number">4</span><br>找到的值的位置是place = <span class="hljs-number">3</span><br>Program ended with <span class="hljs-built_in">exit</span> code: <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure>
<h3 id="2-4-线性表的双向链表（设计与实现增删改查等）"><a href="#2-4-线性表的双向链表（设计与实现增删改查等）" class="headerlink" title="2.4 线性表的双向链表（设计与实现增删改查等）"></a>2.4 线性表的双向链表（设计与实现增删改查等）</h3><h4 id="2-4-1-双向链表"><a href="#2-4-1-双向链表" class="headerlink" title="2.4.1 双向链表"></a>2.4.1 双向链表</h4><p>我们为啥要使用双向链表，相比单向链表，双向链表的优点是什么？</p>
<blockquote>
<p>单链表相对于顺序表，确实在某些场景下解决了一些重要的问题，例如在需要插入或者删除大量元素的时候，它并不需要像顺序表一样移动很多元素，只需要修改指针的指向就可以了，其时间复杂度为 O(1) 但是这可是有前提的，那就是这一切都基于确定节点后，纯粹考虑删除和插入的情况下，但是如果我们仍未确定节点的位置，那么单链表就会出现一些问题了.</p>
</blockquote>
<p>单向链表删除操作，如下图我们要删除一个结点，假如想要删除第2个节点 a1 只需要 将首元结点的指针指向到第三个节点的地址去：<br><img src="https://gitee.com/platojobs/images/raw/master/gitartos20200415204501.png" alt=""></p>
<p>我们遇到的问题就在于我们如何得到待删除节点的前驱，也就是我们图中的首元结点，我们给出两种方法：</p>
<p>A：定位待删除节点的同时，一直顺便保存当前节点的前驱<br>B：删除节点后，重新回到单链表表头，定位到其指定前驱</p>
<p>但是无论我们选择哪一种方法，指针的总移动数都会是 2n 次，而双链表却在这一类型问题上做出了很好的处理。<br>我们接下来看一下双链表的删除结点的过程：</p>
<p><img src="https://gitee.com/platojobs/images/raw/master/gitartos20200415204502.png" alt=""></p>
<p>双链表相比单链表每个结点都多了一个指向前驱的指针，这样我们无论是向前查找，还是向后查找都比较方便。单链表中之所以出现问题，就是因为各个节点只有一个指向后继的指针域 next，只能向后移动查找，一旦我们想要查询前一节点，就变得很麻烦，所以双链表就在每个节点前面增加一个指向前驱的指针域 prior，这样我们就可以直接定位到我们的前一个节点了，这也就是双链表的优点。<br>我们可以计算一下它们删除是的操作数量：<br><img src="https://gitee.com/platojobs/images/raw/master/gitartos20200415204503.png" alt=""></p>
<p>双链表虽然解决了单链表中的反向查找痛点，但是是以每个结点增加了一个指针域为代价的，也就是用空间来换取的。</p>
<p>接下来，我们来了解一下双向链表的基本操作代码实现。</p>
<h5 id="2-4-1-1-代码实现"><a href="#2-4-1-1-代码实现" class="headerlink" title="2.4.1.1 代码实现"></a>2.4.1.1 代码实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;string.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ctype.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdlib.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;math.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;time.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRUE 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FALSE 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK 1</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 20 <span class="hljs-comment">/* 存储空间初始分配量 */</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> KStatus;<span class="hljs-comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> KElementType;<span class="hljs-comment">/* KElementType类型根据实际情况而定，这里假设为int */</span><br><br><span class="hljs-comment">//定义结点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KNode</span>&#123;</span><br>    KElementType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KNode</span> *<span class="hljs-title">prior</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;KNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KNode</span> * <span class="hljs-title">LinkList</span>;</span><br><br><span class="hljs-comment">//5.1 创建双向链接</span><br><span class="hljs-function">KStatus <span class="hljs-title">createLinkList</span><span class="hljs-params">(LinkList *L)</span></span>&#123;<br>    <br>    <span class="hljs-comment">//*L 指向头结点</span><br>    *L = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(KNode));<br>    <span class="hljs-keyword">if</span> (*L == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    (*L)-&gt;prior = <span class="hljs-literal">NULL</span>;<br>    (*L)-&gt;next = <span class="hljs-literal">NULL</span>;<br>    (*L)-&gt;data = <span class="hljs-number">-1</span>;<br>    <br>    <span class="hljs-comment">//新增数据</span><br>    LinkList p = *L;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>;i++)&#123;<br>        <br>        <span class="hljs-comment">//1.创建1个临时的结点</span><br>        LinkList temp = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(KNode));<br>        temp-&gt;prior = <span class="hljs-literal">NULL</span>;<br>        temp-&gt;next = <span class="hljs-literal">NULL</span>;<br>        temp-&gt;data = i;<br>        <br>        <span class="hljs-comment">//2.为新增的结点建立双向链表关系</span><br>        <span class="hljs-comment">//① temp 是p的后继</span><br>        p-&gt;next = temp;<br>        <span class="hljs-comment">//② temp 的前驱是p</span><br>        temp-&gt;prior = p;<br>        <span class="hljs-comment">//③ p 要记录最后的结点的位置,方便下一次插入</span><br>        p = p-&gt;next;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//5.2 打印循环链表的元素</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">(LinkList L)</span></span>&#123;<br>    <br>    LinkList temp = L-&gt;next;<br>    <br>    <span class="hljs-keyword">if</span>(temp == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打印的双向链表为空!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span> (temp) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d  &quot;</span>,temp-&gt;data);<br>        temp = temp-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <br>&#125;<br><br><span class="hljs-comment">//5.3 双向链表插入元素</span><br><span class="hljs-function">KStatus <span class="hljs-title">ListInsert</span><span class="hljs-params">(LinkList *L, <span class="hljs-keyword">int</span> i, KElementType data)</span></span>&#123;<br>    <br>    <span class="hljs-comment">//1. 插入的位置不合法 为0或者为负数</span><br>    <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    <span class="hljs-comment">//2. 新建结点</span><br>    LinkList temp = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(KNode));<br>    temp-&gt;data = data;<br>    temp-&gt;prior = <span class="hljs-literal">NULL</span>;<br>    temp-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-comment">//3.将p指向头结点!</span><br>    LinkList p = *L;<br>    <br>    <span class="hljs-comment">//4. 找到插入位置i直接的结点</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i &amp;&amp; p;j++)<br>        p = p-&gt;next;<br>    <br>    <span class="hljs-comment">//5. 如果插入的位置超过链表本身的长度</span><br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span>  ERROR;<br>    &#125;<br>    <br>    <span class="hljs-comment">//6. 判断插入位置是否为链表尾部;</span><br>    <span class="hljs-keyword">if</span> (p-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>        <br>        p-&gt;next = temp;<br>        temp-&gt;prior = p;<br>    &#125;<span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">//1️⃣ 将p-&gt;next 结点的前驱prior = temp</span><br>        p-&gt;next-&gt;prior = temp;<br>        <span class="hljs-comment">//2️⃣ 将temp-&gt;next 指向原来的p-&gt;next</span><br>        temp-&gt;next = p-&gt;next;<br>        <span class="hljs-comment">//3️⃣ p-&gt;next 更新成新创建的temp</span><br>        p-&gt;next = temp;<br>        <span class="hljs-comment">//4️⃣ 新创建的temp前驱 = p</span><br>        temp-&gt;prior = p;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span>  OK;<br>&#125;<br><br><span class="hljs-comment">//5.4 删除双向链表指定位置上的结点</span><br><span class="hljs-function">KStatus <span class="hljs-title">ListDelete</span><span class="hljs-params">(LinkList *L, <span class="hljs-keyword">int</span> i, KElementType *e)</span></span>&#123;<br>    <br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>;<br>    LinkList p = (*L);<br>    <br>    <span class="hljs-comment">//1.判断双向链表是否为空,如果为空则返回ERROR;</span><br>    <span class="hljs-keyword">if</span> (*L == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <br>  <br>    <span class="hljs-comment">//2. 将指针p移动到删除元素位置前一个</span><br>    <span class="hljs-keyword">while</span> (k &lt; i &amp;&amp; p != <span class="hljs-literal">NULL</span>) &#123;<br>        p = p-&gt;next;<br>        k++;<br>    &#125;<br>    <br>    <span class="hljs-comment">//3.如果k&gt;i 或者 p == NULL 则返回ERROR</span><br>    <span class="hljs-keyword">if</span> (k&gt;i || p == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span>  ERROR;<br>    &#125;<br>    <br>    <span class="hljs-comment">//4.创建临时指针delTemp 指向要删除的结点,并将要删除的结点的data 赋值给*e,带回到main函数</span><br>    LinkList delTemp = p-&gt;next;<br>    *e = delTemp-&gt;data;<br>    <br>    <span class="hljs-comment">//5. p-&gt;next 等于要删除的结点的下一个结点</span><br>    p-&gt;next = delTemp-&gt;next;<br>    <br>    <span class="hljs-comment">//6. 如果删除结点的下一个结点不为空,则将将要删除的下一个结点的前驱指针赋值p;</span><br>    <span class="hljs-keyword">if</span> (delTemp-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>        delTemp-&gt;next-&gt;prior = p;<br>    &#125;<br>    <br>    <span class="hljs-comment">//7.删除delTemp结点</span><br>    <span class="hljs-built_in">free</span>(delTemp);<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>    <br>&#125;<br><br><span class="hljs-comment">//5.5 删除双向链表指定的元素</span><br><span class="hljs-function">KStatus <span class="hljs-title">LinkListDeletVAL</span><span class="hljs-params">(LinkList *L, <span class="hljs-keyword">int</span> data)</span></span>&#123;<br>    <br>    LinkList p = *L;<br>    <br>    <span class="hljs-comment">//1.遍历双向循环链表</span><br>    <span class="hljs-keyword">while</span> (p) &#123;<br>       <br>        <span class="hljs-comment">//2.判断当前结点的数据域和data是否相等,若相等则删除该结点</span><br>        <span class="hljs-keyword">if</span> (p-&gt;data == data) &#123;<br>            <br>            <span class="hljs-comment">//修改被删除结点的前驱结点的后继指针,参考图上步骤1️⃣</span><br>            p-&gt;prior-&gt;next = p-&gt;next;<br>            <span class="hljs-comment">//修改被删除结点的后继结点的前驱指针,参考图上步骤2️⃣</span><br>            <span class="hljs-keyword">if</span>(p-&gt;next != <span class="hljs-literal">NULL</span>)&#123;<br>                p-&gt;next-&gt;prior = p-&gt;prior;<br>            &#125;<br>            <span class="hljs-comment">//释放被删除结点p</span><br>            <span class="hljs-built_in">free</span>(p);<br>            <span class="hljs-comment">//退出循环</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">//没有找到该结点,则继续移动指针p</span><br>        p = p-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>    <br>&#125;<br><br><span class="hljs-comment">//5.6.1 在双向链表中查找元素</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">selectElem</span><span class="hljs-params">(LinkList L,KElementType elem)</span></span>&#123;<br>    <br>    LinkList p = L-&gt;next;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;data == elem) &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <br>        i++;<br>        p = p-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span>  <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">//5.6.2 在双向链表中更新结点</span><br><span class="hljs-function">KStatus <span class="hljs-title">replaceLinkList</span><span class="hljs-params">(LinkList *L,<span class="hljs-keyword">int</span> index,KElementType newElem)</span></span>&#123;<br>    LinkList p = (*L)-&gt;next;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; index; i++) &#123;<br>        p = p-&gt;next;<br>    &#125;<br>    <br>    p-&gt;data = newElem;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span> <span class="hljs-params">()</span> </span>&#123;<br>    KStatus iStatus = <span class="hljs-number">0</span>;<br>      LinkList L;<br>      <span class="hljs-keyword">int</span> temp,item,e;<br>      <br>      iStatus =  createLinkList(&amp;L);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;iStatus = %d\n&quot;</span>,iStatus);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表创建成功,打印链表:\n&quot;</span>);<br>      display(L);<br>      <br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入插入的位置\n&quot;</span>);<br>      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;temp,&amp;item);<br>      iStatus = ListInsert(&amp;L, temp, item);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入数据,打印链表:\n&quot;</span>);<br>      display(L);<br>      <br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入插入的位置\n&quot;</span>);<br>      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;temp,&amp;item);<br>      iStatus = ListInsert(&amp;L, temp, item);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入数据,打印链表:\n&quot;</span>);<br>      display(L);<br>      <br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入插入的位置\n&quot;</span>);<br>      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;temp,&amp;item);<br>      iStatus = ListInsert(&amp;L, temp, item);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入数据,打印链表:\n&quot;</span>);<br>      display(L);<br>      <br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入删除的位置\n&quot;</span>);<br>      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;temp);<br>      iStatus = ListDelete(&amp;L, temp, &amp;e);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除元素: 删除位置为%d,data = %d\n&quot;</span>,temp,e);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除操作之后的,双向链表:\n&quot;</span>);<br>      display(L);<br>      <br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入你要删除的内容\n&quot;</span>);<br>      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;temp);<br>      iStatus = LinkListDeletVAL(&amp;L, temp);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除指定data域等于%d的结点,双向链表:\n&quot;</span>,temp);<br>      display(L);<br><br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入你要查找的内容\n&quot;</span>);<br>       <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;temp);<br>      KElementType index = selectElem(L, temp);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;在双向链表中查找到数据域为%d的结点,位置是:%d\n&quot;</span>,temp,index);<br><br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入你要更新的结点以及内容\n&quot;</span>);<br>      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;temp,&amp;item);<br>      iStatus = replaceLinkList(&amp;L, temp, item);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;更新结点数据后的双向链表:\n&quot;</span>);<br>      display(L);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;<br>    <span class="hljs-comment">// insert code here...</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>);<br>    test();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-4-2-双向循环链表"><a href="#2-4-2-双向循环链表" class="headerlink" title="2.4.2 双向循环链表"></a>2.4.2 双向循环链表</h4><h5 id="2-4-2-1-结点定义"><a href="#2-4-2-1-结点定义" class="headerlink" title="2.4.2.1 结点定义"></a>2.4.2.1 结点定义</h5><p> 双向循环链表的结点定义和双向链表是一样的</p>
<p> <img src="https://gitee.com/platojobs/images/raw/master/gitartos20200415205701.png" alt=""><br> <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//定义结点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KNode</span>&#123;</span><br>    KElementType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KNode</span> *<span class="hljs-title">prior</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;KNode;<br></code></pre></td></tr></table></figure></p>
<h5 id="2-4-2-2-建表"><a href="#2-4-2-2-建表" class="headerlink" title="2.4.2.2 建表"></a>2.4.2.2 建表</h5><p>建表过程，实际上就是从一个空表，按照我们给到的数据创建一个非空链表的过程。</p>
<p>如下图定义的是一个空的双向循环链表，带头结点的，头结点的前驱指针prior和后继指针next都指向它自己：<br><img src="https://gitee.com/platojobs/images/raw/master/gitartos20200415205702.png" alt=""></p>
<p>如下图：是上面空链表一次从尾部插入A，B元素后得到的链表，另外我们还可以从首部插入B,A 元素，也可以得到下面的表：</p>
<p><img src="https://gitee.com/platojobs/images/raw/master/gitartos20200415205703.png" alt=""></p>
<p>下面的代码是循环链表创建过程，代码中我们通过尾部插入法，插入0，1，2，3，4，5，6，7，8，9 总共10个元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//6.1 双向循环链表初始化</span><br><span class="hljs-function">KStatus <span class="hljs-title">creatLinkList</span><span class="hljs-params">(LinkList *L)</span></span>&#123;<br>    <br>    *L = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(KNode));<br>    <span class="hljs-keyword">if</span> (*L == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <br>    (*L)-&gt;next = (*L);<br>    (*L)-&gt;prior = (*L);<br>    <br>    <span class="hljs-comment">//新增数据</span><br>    LinkList p = *L;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>;i++)&#123;<br>        <br>        <span class="hljs-comment">//1.创建1个临时的结点</span><br>        LinkList temp = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(KNode));<br>        temp-&gt;data = i;<br>        <br>        <span class="hljs-comment">//2.为新增的结点建立双向链表关系</span><br>        <span class="hljs-comment">//① temp 是p的后继</span><br>        p-&gt;next = temp;<br>        <span class="hljs-comment">//② temp 的前驱是p</span><br>        temp-&gt;prior = p;<br>        <span class="hljs-comment">//③ temp的后继是*L</span><br>        temp-&gt;next = (*L);<br>        <span class="hljs-comment">//④ p 的前驱是新建的temp</span><br>        p-&gt;prior = temp;<br>        <span class="hljs-comment">//⑤ p 要记录最后的结点的位置,方便下一次插入</span><br>        p = p-&gt;next;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>   <br>&#125;<br><br></code></pre></td></tr></table></figure>
<h5 id="2-4-2-3-插入结点"><a href="#2-4-2-3-插入结点" class="headerlink" title="2.4.2.3 插入结点"></a>2.4.2.3 插入结点</h5><p><img src="https://gitee.com/platojobs/images/raw/master/gitartos20200415205704.png" alt=""></p>
<p>双向循环链表的插入过程如下：</p>
<ul>
<li>先找到要插入的元素的前驱，(如上图我们找到B结点的前驱A，用p指针指向A)</li>
<li>新建一个结点赋值为CC，并用临时指针temp指向CC结点：temp-&gt;data = e;</li>
<li>将结点temp 的前驱结点为p： temp-&gt;prior = p;</li>
<li>将新建结点temp的后继结点指向p-&gt;next： temp-&gt;next = p-&gt;next;</li>
<li>让p的后继指向新结点temp： p-&gt;next = temp;</li>
<li>判断当前要插入的新结点temp是不是最后一个结点，如果是则：让L的前驱结点指向temp: (*L)-&gt;prior = temp;；如果不是是则将temp节点的下一个结点的前驱为temp 结点：temp-&gt;next-&gt;prior = temp;</li>
</ul>
<p>插入结点的代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//6.2 双向循环链表插入元素</span><br><span class="hljs-comment">/*当插入位置超过链表长度则插入到链表末尾*/</span><br><span class="hljs-function">KStatus <span class="hljs-title">LinkListInsert</span><span class="hljs-params">(LinkList *L, <span class="hljs-keyword">int</span> index, KElementType e)</span></span>&#123;<br>   <br>    <span class="hljs-comment">//1. 创建指针p,指向双向链表头</span><br>    LinkList p = (*L);<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">//2.双向循环链表为空,则返回error</span><br>    <span class="hljs-keyword">if</span>(*L == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ERROR;<br>   <br>    <span class="hljs-comment">//3.找到插入前一个位置上的结点p</span><br>    <span class="hljs-keyword">while</span> (i &lt; index &amp;&amp; p-&gt;next != *L) &#123;<br>        p = p-&gt;next;<br>        i++;<br>    &#125;<br>    <br>    <span class="hljs-comment">//4.如果i&gt;index 则返回error</span><br>    <span class="hljs-keyword">if</span> (i &gt; index)  <span class="hljs-keyword">return</span> ERROR;<br>    <br>    <span class="hljs-comment">//5.创建新结点temp</span><br>    LinkList temp = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(KNode));<br>    <br>    <span class="hljs-comment">//6.temp 结点为空,则返回error</span><br>    <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    <span class="hljs-comment">//7.将生成的新结点temp数据域赋值e.</span><br>    temp-&gt;data = e;<br>    <br>    <span class="hljs-comment">//8.将结点temp 的前驱结点为p;</span><br>    temp-&gt;prior = p;<br>    <span class="hljs-comment">//9.temp的后继结点指向p-&gt;next;</span><br>    temp-&gt;next = p-&gt;next;<br>    <span class="hljs-comment">//10.p的后继结点为新结点temp;</span><br>    p-&gt;next = temp;<br>    <br>    <span class="hljs-comment">//如果temp 结点不是最后一个结点</span><br>    <span class="hljs-keyword">if</span> (*L != temp-&gt;next) &#123;<br>        <br>        <span class="hljs-comment">//11.temp节点的下一个结点的前驱为temp 结点</span><br>        temp-&gt;next-&gt;prior = temp;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br><br>        (*L)-&gt;prior = temp;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h5 id="2-4-2-4-删除结点"><a href="#2-4-2-4-删除结点" class="headerlink" title="2.4.2.4 删除结点"></a>2.4.2.4 删除结点</h5><p>循环双链表删除结点的过程如下：<br>1.找到要删除的结点（如上图用temp指针指向要删除的结点B）<br>2.给e赋值要删除结点的数据域：*e = temp-&gt;data;<br>3.修改被删除结点的前驱结点的后继指针 图1️⃣：temp-&gt;prior-&gt;next = temp-&gt;next; (也就B结点的前驱结点A的next指向B结点的后继C)<br>4.修改被删除结点的后继结点的前驱指针 图2️⃣:temp-&gt;next-&gt;prior = temp-&gt;prior; (让B结点的后继结点C的前驱指针指向B结点的前驱A)<br>5.删除结点temp，释放内存：free(temp);</p>
<p><img src="https://gitee.com/platojobs/images/raw/master/gitartos20200415205801.png" alt=""></p>
<p>循环双链表删除结点的实现代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//6.4 双向循环链表删除结点</span><br><span class="hljs-function">KStatus <span class="hljs-title">LinkListDelete</span><span class="hljs-params">(LinkList *L,<span class="hljs-keyword">int</span> index,KElementType *e)</span></span>&#123;<br>    <br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    LinkList temp = (*L)-&gt;next;<br>    <br>    <span class="hljs-keyword">if</span> (*L == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span>  ERROR;<br>    &#125;<br>    <br>    <span class="hljs-comment">//①.如果删除到只剩下首元结点了,则直接将*L置空;</span><br>    <span class="hljs-keyword">if</span>(temp-&gt;next == *L)&#123;<br>        <span class="hljs-built_in">free</span>(*L);<br>        (*L) = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> OK;<br>    &#125;<br>    <br>    <span class="hljs-comment">//1.找到要删除的结点</span><br>    <span class="hljs-keyword">while</span> (i &lt; index) &#123;<br>        temp = temp-&gt;next;<br>        i++;<br>    &#125;<br><br>    <span class="hljs-comment">//2.给e赋值要删除结点的数据域</span><br>    *e = temp-&gt;data;<br>    <br>    <span class="hljs-comment">//3.修改被删除结点的前驱结点的后继指针 图1️⃣</span><br>    temp-&gt;prior-&gt;next = temp-&gt;next;<br>    <span class="hljs-comment">//4.修改被删除结点的后继结点的前驱指针 图2️⃣</span><br>    temp-&gt;next-&gt;prior = temp-&gt;prior;<br>    <span class="hljs-comment">//5. 删除结点temp</span><br>    <span class="hljs-built_in">free</span>(temp);<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure>
<h5 id="2-4-2-5-代码实现"><a href="#2-4-2-5-代码实现" class="headerlink" title="2.4.2.5 代码实现"></a>2.4.2.5 代码实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;string.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ctype.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdlib.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;math.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;time.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRUE 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FALSE 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK 1</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 20 <span class="hljs-comment">/* 存储空间初始分配量 */</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> KStatus;<span class="hljs-comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> KElementType;<span class="hljs-comment">/* KElementType类型根据实际情况而定，这里假设为int */</span><br><br><span class="hljs-comment">//定义结点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KNode</span>&#123;</span><br>    KElementType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KNode</span> *<span class="hljs-title">prior</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;KNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KNode</span> * <span class="hljs-title">LinkList</span>;</span><br><br><br><span class="hljs-comment">//6.1 双向循环链表初始化</span><br><span class="hljs-function">KStatus <span class="hljs-title">creatLinkList</span><span class="hljs-params">(LinkList *L)</span></span>&#123;<br>    <br>    *L = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(KNode));<br>    <span class="hljs-keyword">if</span> (*L == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <br>    (*L)-&gt;next = (*L);<br>    (*L)-&gt;prior = (*L);<br>    <br>    <span class="hljs-comment">//新增数据</span><br>    LinkList p = *L;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>;i++)&#123;<br>        <br>        <span class="hljs-comment">//1.创建1个临时的结点</span><br>        LinkList temp = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(KNode));<br>        temp-&gt;data = i;<br>        <br>        <span class="hljs-comment">//2.为新增的结点建立双向链表关系</span><br>        <span class="hljs-comment">//① temp 是p的后继</span><br>        p-&gt;next = temp;<br>        <span class="hljs-comment">//② temp 的前驱是p</span><br>        temp-&gt;prior = p;<br>        <span class="hljs-comment">//③ temp的后继是*L</span><br>        temp-&gt;next = (*L);<br>        <span class="hljs-comment">//④ p 的前驱是新建的temp</span><br>        p-&gt;prior = temp;<br>        <span class="hljs-comment">//⑤ p 要记录最后的结点的位置,方便下一次插入</span><br>        p = p-&gt;next;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>   <br>&#125;<br><br><span class="hljs-comment">//6.2 双向循环链表插入元素</span><br><span class="hljs-comment">/*当插入位置超过链表长度则插入到链表末尾*/</span><br><span class="hljs-function">KStatus <span class="hljs-title">LinkListInsert</span><span class="hljs-params">(LinkList *L, <span class="hljs-keyword">int</span> index, KElementType e)</span></span>&#123;<br>   <br>    <span class="hljs-comment">//1. 创建指针p,指向双向链表头</span><br>    LinkList p = (*L);<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">//2.双向循环链表为空,则返回error</span><br>    <span class="hljs-keyword">if</span>(*L == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ERROR;<br>   <br>    <span class="hljs-comment">//3.找到插入前一个位置上的结点p</span><br>    <span class="hljs-keyword">while</span> (i &lt; index &amp;&amp; p-&gt;next != *L) &#123;<br>        p = p-&gt;next;<br>        i++;<br>    &#125;<br>    <br>    <span class="hljs-comment">//4.如果i&gt;index 则返回error</span><br>    <span class="hljs-keyword">if</span> (i &gt; index)  <span class="hljs-keyword">return</span> ERROR;<br>    <br>    <span class="hljs-comment">//5.创建新结点temp</span><br>    LinkList temp = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(KNode));<br>    <br>    <span class="hljs-comment">//6.temp 结点为空,则返回error</span><br>    <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ERROR;<br>    <br>    <span class="hljs-comment">//7.将生成的新结点temp数据域赋值e.</span><br>    temp-&gt;data = e;<br>    <br>    <span class="hljs-comment">//8.将结点temp 的前驱结点为p;</span><br>    temp-&gt;prior = p;<br>    <span class="hljs-comment">//9.temp的后继结点指向p-&gt;next;</span><br>    temp-&gt;next = p-&gt;next;<br>    <span class="hljs-comment">//10.p的后继结点为新结点temp;</span><br>    p-&gt;next = temp;<br>    <br>    <span class="hljs-comment">//如果temp 结点不是最后一个结点</span><br>    <span class="hljs-keyword">if</span> (*L != temp-&gt;next) &#123;<br>        <br>        <span class="hljs-comment">//11.temp节点的下一个结点的前驱为temp 结点</span><br>        temp-&gt;next-&gt;prior = temp;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br><br>        (*L)-&gt;prior = temp;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br><span class="hljs-comment">//6.3 遍历双向循环链表</span><br><span class="hljs-function">KStatus <span class="hljs-title">Display</span><span class="hljs-params">(LinkList L)</span></span>&#123;<br>    <br>    <span class="hljs-keyword">if</span> (L == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打印的双向循环链表为空!\n\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;双向循环链表内容:  &quot;</span>);<br>    <br>    LinkList p = L-&gt;next;<br>    <span class="hljs-keyword">while</span> (p != L) &#123;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d  &quot;</span>,p-&gt;data);<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//6.4 双向循环链表删除结点</span><br><span class="hljs-function">KStatus <span class="hljs-title">LinkListDelete</span><span class="hljs-params">(LinkList *L,<span class="hljs-keyword">int</span> index,KElementType *e)</span></span>&#123;<br>    <br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    LinkList temp = (*L)-&gt;next;<br>    <br>    <span class="hljs-keyword">if</span> (*L == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span>  ERROR;<br>    &#125;<br>    <br>    <span class="hljs-comment">//①.如果删除到只剩下首元结点了,则直接将*L置空;</span><br>    <span class="hljs-keyword">if</span>(temp-&gt;next == *L)&#123;<br>        <span class="hljs-built_in">free</span>(*L);<br>        (*L) = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> OK;<br>    &#125;<br>    <br>    <span class="hljs-comment">//1.找到要删除的结点</span><br>    <span class="hljs-keyword">while</span> (i &lt; index) &#123;<br>        temp = temp-&gt;next;<br>        i++;<br>    &#125;<br><br>    <span class="hljs-comment">//2.给e赋值要删除结点的数据域</span><br>    *e = temp-&gt;data;<br>    <br>    <span class="hljs-comment">//3.修改被删除结点的前驱结点的后继指针 图1️⃣</span><br>    temp-&gt;prior-&gt;next = temp-&gt;next;<br>    <span class="hljs-comment">//4.修改被删除结点的后继结点的前驱指针 图2️⃣</span><br>    temp-&gt;next-&gt;prior = temp-&gt;prior;<br>    <span class="hljs-comment">//5. 删除结点temp</span><br>    <span class="hljs-built_in">free</span>(temp);<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    LinkList L;<br>    KStatus iStatus;<br>    KElementType temp,item;<br>    <br>    iStatus = creatLinkList(&amp;L);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;双向循环链表初始化是否成功(1-&gt;YES)/ (0-&gt;NO):  %d\n\n&quot;</span>,iStatus);<br>    Display(L);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入要插入的位置和数据用空格隔开：&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;temp,&amp;item);<br>    iStatus = LinkListInsert(&amp;L,temp,item);<br>    Display(L);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入要删除位置：&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;temp);<br>    iStatus = LinkListDelete(&amp;L, temp, &amp;item);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除链表位置为%d,结点数据域为:%d\n&quot;</span>,temp,item);<br>    Display(L);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;<br>    <span class="hljs-comment">// insert code here...</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>);<br>    test();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>
<h3 id="2-5-线性表有关的面试题目"><a href="#2-5-线性表有关的面试题目" class="headerlink" title="2.5 线性表有关的面试题目"></a>2.5 线性表有关的面试题目</h3><h4 id="2-5-1-合并两个有序链表"><a href="#2-5-1-合并两个有序链表" class="headerlink" title="2.5.1 合并两个有序链表"></a>2.5.1 合并两个有序链表</h4><blockquote>
<p>题目1： 将2个递增的有序链表合并为一个有序链表；要求结果链表仍然使用两个链表的存储空间，不另外占用其他的存储空间。表中不允许有重复的数据。<br>例如：La{1,2,3}, Lb{3,6,9} 合并成 Lc {1,2,3,6,9}</p>
</blockquote>
<p>下面我们来分析解决问题：</p>
<ul>
<li>先分析题目的关键字，找出细节点： 关键词:<ol>
<li>递增有序链表,不允许有重复数据,保留递增关系(后插法)</li>
<li>不占用额外的存储空间指的是不能开辟新节点,赋值在链接到链表上;</li>
</ol>
</li>
</ul>
<ul>
<li><p>分析问题，列出解题思路：</p>
<blockquote>
<p>算法思想:<br>(1)假设待合并的链表为La和Lb,合并后的新表使用头指针Lc(Lc的表头结点设为La的表头结点)指向. Pa 和 Pb 分别是La,Lb的工作指针.初始化为相应链表的首元结点<br>(2)从首元结点开始比较, 当两个链表La 和Lb 均未到达表尾结点时,依次摘取其中较小值重新链表在Lc表的最后.<br>(3)如果两个表中的元素相等,只摘取La表中的元素,删除Lb表中的元素,这样确保合并后表中无重复的元素;<br>(4)当一个表达到表尾结点为空时,非空表的剩余元素直接链接在Lc表最后.<br>(5)最后释放链表Lb的头结点;</p>
</blockquote>
</li>
<li><p>问题求解，代码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//目标:将2个递增的有序链表La,Lb 合并为一个递增的有序链表Lc</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeList</span><span class="hljs-params">(LinkList *La, LinkList *Lb, LinkList *Lc)</span> </span>&#123;<br>    LinkList pa, pb, pc, temp;<br>    <span class="hljs-comment">//pa 是链表La的工作指针,pb 是链表Lb的工作指针, 初始化为首元结点;</span><br>    pa = (*La)-&gt;next;<br>    pb = (*Lb)-&gt;next;<br>    <br>    *Lc = pc = *La;<br>    <span class="hljs-keyword">while</span> (pa &amp;&amp; pb) &#123;<br>        <span class="hljs-keyword">if</span> (pa-&gt;data &lt; pb-&gt;data) &#123;<br>            <span class="hljs-comment">//取较小者La中的元素,将pa链接在pc的后面,pa指针后移</span><br>            pc-&gt;next = pa;<br>            pc = pa;<br>            pa = pa-&gt;next;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pa-&gt;data &gt; pb-&gt;data) &#123;<br>            <span class="hljs-comment">//取较小者Lb的元素,将pb链接在pc后面, pb指针后移</span><br>            pc-&gt;next = pb;<br>            pc = pb;<br>            pb = pb-&gt;next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//相等时取La中的元素,删除Lb的元素;</span><br>            pc-&gt;next = pa;<br>            pc = pa;<br>            pa = pa-&gt;next;<br>            temp = pb-&gt;next;<br>            <span class="hljs-built_in">free</span>(pb);<br>            pb = temp;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//将非空表的剩余元素之间链接在Lc表的最后</span><br>    pc-&gt;next = pa ? pa : pb;<br>    <span class="hljs-comment">//释放Lb的头结点</span><br>    <span class="hljs-built_in">free</span>(*Lb);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：O(n) 空间复杂度：O(1)</p>
</blockquote>
</li>
<li><p>测试验证：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;测试mergeList：\n&quot;</span>);<br>    <br>    KStatus iStatus;<br>    LinkList La,Lb,Lc;<br>    initList(&amp;La);<br>    initList(&amp;Lb);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;******题目1:********\n&quot;</span>);<br>    <span class="hljs-comment">//设计2个递增链表La,Lb</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">10</span>;j&gt;=<span class="hljs-number">0</span>;j-=<span class="hljs-number">2</span>)<br>    &#123;<br>        iStatus = insertElement(&amp;La, <span class="hljs-number">1</span>, j);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;La:\n&quot;</span>);<br>    traverseList(La);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">11</span>;j&gt;<span class="hljs-number">0</span>;j-=<span class="hljs-number">2</span>)<br>    &#123;<br>        iStatus = insertElement(&amp;Lb, <span class="hljs-number">1</span>, j);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Lb:\n&quot;</span>);<br>    traverseList(Lb);<br><br>    mergeList(&amp;La, &amp;Lb, &amp;Lc);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Lc:\n&quot;</span>);<br>    traverseList(Lc);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">测试mergeList：<br>******题目<span class="hljs-number">1</span>:********<br>La:<br><span class="hljs-number">0</span>  <span class="hljs-number">2</span>  <span class="hljs-number">4</span>  <span class="hljs-number">6</span>  <span class="hljs-number">8</span>  <span class="hljs-number">10</span>  <br>Lb:<br><span class="hljs-number">1</span>  <span class="hljs-number">3</span>  <span class="hljs-number">5</span>  <span class="hljs-number">7</span>  <span class="hljs-number">9</span>  <span class="hljs-number">11</span>  <br>Lc:<br><span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  <span class="hljs-number">10</span>  <span class="hljs-number">11</span>  <br><br><br></code></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>经典编程书籍一箩筐</title>
    <url>/2019/11/15/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B8%80%E7%AE%A9%E7%AD%90/</url>
    <content><![CDATA[<h1 id="经典编程书籍大全"><a href="#经典编程书籍大全" class="headerlink" title="经典编程书籍大全"></a>经典编程书籍大全</h1><p>100+ 经典技术书籍，涵盖：计算机系统与网络、系统架构、算法与数据结构、前端开发、后端开发、移动开发、数据库、测试、项目与团队、程序员职业修炼、求职面试 和 编程相关的经典书籍。</p>
<p>这个列表综合了伯乐在线网站以往推荐<a href="http://blog.jobbole.com/tag/book/">经典书籍</a>文章中的列表，以及在微信和微博中被广泛推荐的好书。虽然已经包括了100多本，覆盖的面也比较全。仍然有很多方面需要补充，而且相信还有很多没有被收录的好书。欢迎大家在 issues 中推荐或自荐。</p>
<h2 id="计算机系统与网络"><a href="#计算机系统与网络" class="headerlink" title="计算机系统与网络"></a>计算机系统与网络</h2><ul>
<li>《<a href="https://www.amazon.cn/gp/product/B00AAQXKXS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00AAQXKXS&amp;linkCode=as2&amp;tag=vastwork-23">图灵的秘密:他的生平、思想及论文解读</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B0011F9OQE/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0011F9OQE&amp;linkCode=as2&amp;tag=vastwork-23">计算机系统概论</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B0011F5RYM/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0011F5RYM&amp;linkCode=as2&amp;tag=vastwork-23">深入理解Linux内核</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B003QN7J7U/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B003QN7J7U&amp;linkCode=as2&amp;tag=vastwork-23">深入Linux内核架构</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00116OTVS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00116OTVS&amp;linkCode=as2&amp;tag=vastwork-23">TCP/IP详解 卷1：协议</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00JUM2ML4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00JUM2ML4&amp;linkCode=as2&amp;tag=vastwork-23">Linux系统编程（第2版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B004X3Z3D4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B004X3Z3D4&amp;linkCode=as2&amp;tag=vastwork-23">Linux内核设计与实现（第3版）</a>》</li>
<li>《<a href="https://amazon.cn/gp/product/B01N03IQK4/ref=as_li_qf_asin_il_tl?ie=UTF8&amp;tag=vastwork-23&amp;creative=3200&amp;linkCode=as2&amp;creativeASIN=B01N03IQK4&amp;linkId=b87deba0291c05df8d8ea0d64fefb0f0">深入理解计算机系统（原书第3版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B0011AP7RY/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0011AP7RY&amp;linkCode=as2&amp;tag=vastwork-23">计算机程序的构造和解释（原书第2版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B009RSXIB4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B009RSXIB4&amp;linkCode=as2&amp;tag=vastwork-23">编码：隐匿在计算机软硬件背后的语言</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B0140I5WPK/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0140I5WPK&amp;linkCode=as2&amp;tag=vastwork-23">性能之颠：洞悉系统、企业与云计算</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B011S72JB6/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B011S72JB6&amp;linkCode=as2&amp;tag=vastwork-23">UNIX网络编程 卷1：套接字联网API（第3版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B012R5A29O/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B012R5A29O&amp;linkCode=as2&amp;tag=vastwork-23">UNIX网络编程 卷2：进程间通信</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B001GS7918/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B001GS7918&amp;linkCode=as2&amp;tag=vastwork-23">Windows核心编程(第5版)</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00PB5QQ84/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00PB5QQ84&amp;linkCode=as2&amp;tag=vastwork-23">WireShark网络分析就这么简单</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B01AS1OS8A/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B01AS1OS8A&amp;linkCode=as2&amp;tag=vastwork-23">WireShark网络分析的艺术</a>》</li>
</ul>
<h2 id="编程通用"><a href="#编程通用" class="headerlink" title="编程通用"></a>编程通用</h2><ul>
<li>《<a href="https://www.amazon.cn/dp/B00CD1EWMG/ref=sr_1_1?ie=UTF8&amp;qid=1514903810&amp;sr=8-1">设计原本</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B006P7V73G/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B006P7V73G&amp;linkCode=as2&amp;tag=vastwork-23">编程原本</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B0061XKRXA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0061XKRXA&amp;linkCode=as2&amp;tag=vastwork-23">代码大全</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B008Z1IEQ8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B008Z1IEQ8&amp;linkCode=as2&amp;tag=vastwork-23">UNIX编程艺术</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B0031M9GHC/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0031M9GHC&amp;linkCode=as2&amp;tag=vastwork-23">代码整洁之道</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00SFZH0DC/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00SFZH0DC&amp;linkCode=as2&amp;tag=vastwork-23">编程珠玑（第2版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B0150BMQDM/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0150BMQDM&amp;linkCode=as2&amp;tag=vastwork-23">编程珠玑（续）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00IOAM6VE/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00IOAM6VE&amp;linkCode=as2&amp;tag=vastwork-23">软件调试的艺术</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00KMJ2Q1U/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00KMJ2Q1U&amp;linkCode=as2&amp;tag=vastwork-23">修改代码的艺术</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B007HYMPBY/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B007HYMPBY&amp;linkCode=as2&amp;tag=vastwork-23">编程语言实现模式</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B008B4DTG4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B008B4DTG4&amp;linkCode=as2&amp;tag=vastwork-23">编写可读代码的艺术</a>》</li>
<li>《解析极限编程：拥抱变化》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B008UCHA58/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B008UCHA58&amp;linkCode=as2&amp;tag=vastwork-23">精通正则表达式（第3版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B001NGO85I/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B001NGO85I&amp;linkCode=as2&amp;tag=vastwork-23">编译原理（第2版）</a>》龙书</li>
<li>《<a href="https://www.amazon.cn/gp/product/B011LPUB42/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B011LPUB42&amp;linkCode=as2&amp;tag=vastwork-23">重构：改善既有代码的设计</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00ALPRM3M/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00ALPRM3M&amp;linkCode=as2&amp;tag=vastwork-23">七周七语言：理解多种编程范型</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00CBBLUFK/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00CBBLUFK&amp;linkCode=as2&amp;tag=vastwork-23">调试九法：软硬件错误的排查之道</a>》</li>
<li>《程序设计语言：实践之路（第3版）》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00PG0MM3C/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00PG0MM3C&amp;linkCode=as2&amp;tag=vastwork-23">计算的本质：深入剖析程序和计算机</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B001130JN8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B001130JN8&amp;linkCode=as2&amp;tag=vastwork-23">设计模式 : 可复用面向对象软件的基础</a>》</li>
<li>《<a href="https://amazon.cn/gp/product/B0011FBU34/ref=as_li_qf_asin_il_tl?ie=UTF8&amp;tag=vastwork-23&amp;creative=3200&amp;linkCode=as2&amp;creativeASIN=B0011FBU34&amp;linkId=cd5d20e99ff289529d6dbe2cd223f2b6">Head First 设计模式（中文版）</a> 》（感谢<a href="https://github.com/Great-Li-Xin">@Great-Li-Xin</a> <a href="https://github.com/jobbole/awesome-programming-books/issues/27">推荐</a> ）</li>
</ul>
<h2 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h2><ul>
<li>《<a href="https://www.amazon.cn/gp/product/B009OCFQ0O/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B009OCFQ0O&amp;linkCode=as2&amp;tag=vastwork-23">算法（第4版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00AK7BYJY/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00AK7BYJY&amp;linkCode=as2&amp;tag=vastwork-23">算法导论（原书第2版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B019NB0VCI/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B019NB0VCI&amp;linkCode=as2&amp;tag=vastwork-23">Python算法教程</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00S4HCQUI/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00S4HCQUI&amp;linkCode=as2&amp;tag=vastwork-23">算法设计与分析基础（第3版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B016DWSF8M/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B016DWSF8M&amp;linkCode=as2&amp;tag=vastwork-23">学习 JavaScript 数据结构与算法</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B01LDG2DSG/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B01LDG2DSG&amp;linkCode=as2&amp;tag=vastwork-23">数据结构与算法分析 : C++描述（第4版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B002WC7NGS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B002WC7NGS&amp;linkCode=as2&amp;tag=vastwork-23">数据结构与算法分析 : C语言描述（第2版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B01CNP0CG6/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B01CNP0CG6&amp;linkCode=as2&amp;tag=vastwork-23">数据结构与算法分析 : Java语言描述（第2版）</a>》</li>
</ul>
<h2 id="职业修炼与规划"><a href="#职业修炼与规划" class="headerlink" title="职业修炼与规划"></a>职业修炼与规划</h2><ul>
<li>《<a href="https://www.amazon.cn/gp/product/B00KQDTZ4S/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00KQDTZ4S&amp;linkCode=as2&amp;tag=vastwork-23">大教堂与集市</a>》</li>
<li>《卓有成效的程序员》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B01LZJ8L9J/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B01LZJ8L9J&amp;linkCode=as2&amp;tag=vastwork-23">程序员的职业素养</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B004GV08CY/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B004GV08CY&amp;linkCode=as2&amp;tag=vastwork-23">程序员修炼之道：从小工到专家</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00H6X6LD4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00H6X6LD4&amp;linkCode=as2&amp;tag=vastwork-23">软件开发者路线图：从学徒到高手</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00CBBKDGM/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00CBBKDGM&amp;linkCode=as2&amp;tag=vastwork-23">我编程，我快乐: 程序员职业规划之道</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B007VARUIM/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B007VARUIM&amp;linkCode=as2&amp;tag=vastwork-23">程序员的思维修炼：开发认知潜能的九堂课</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00OA9L3NU/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00OA9L3NU&amp;linkCode=as2&amp;tag=vastwork-23">高效程序员的45个习惯：敏捷开发修炼之道(修订版)</a>》</li>
</ul>
<h2 id="大师访谈"><a href="#大师访谈" class="headerlink" title="大师访谈"></a>大师访谈</h2><ul>
<li>《<a href="https://www.amazon.cn/gp/product/B00451BP72/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00451BP72&amp;linkCode=as2&amp;tag=vastwork-23">编程大师智慧</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00ALPRKMA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00ALPRKMA&amp;linkCode=as2&amp;tag=vastwork-23">编程大师访谈录</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00QA7GA2Y/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00QA7GA2Y&amp;linkCode=as2&amp;tag=vastwork-23">编程人生 : 15位软件先驱访谈录</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B007ED88CI/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B007ED88CI&amp;linkCode=as2&amp;tag=vastwork-23">奇思妙想 : 15位计算机天才及其重大发现</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B008G80O9K/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B008G80O9K&amp;linkCode=as2&amp;tag=vastwork-23">图灵和ACM图灵奖</a>》</li>
</ul>
<h2 id="架构-性能"><a href="#架构-性能" class="headerlink" title="架构/性能"></a>架构/性能</h2><ul>
<li>《<a href="https://www.amazon.cn/图书/dp/B01DXW29IM/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1496288348&amp;sr=1-1">架构即未来</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B01ER75V6O/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B01ER75V6O&amp;linkCode=as2&amp;tag=vastwork-23">微服务设计</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00NGW4EAG/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00NGW4EAG&amp;linkCode=as2&amp;tag=vastwork-23">大数据日知录</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B003LBSRDM/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B003LBSRDM&amp;linkCode=as2&amp;tag=vastwork-23">企业应用架构模式</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00JMKWHFU/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00JMKWHFU&amp;linkCode=as2&amp;tag=vastwork-23">Web性能权威指南</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B01M0EHQ43/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B01M0EHQ43&amp;linkCode=as2&amp;tag=vastwork-23">SRE：Google运维解密</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B0153178XM/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0153178XM&amp;linkCode=as2&amp;tag=vastwork-23">发布！软件的设计与部署</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B01HZFHQQI/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B01HZFHQQI&amp;linkCode=as2&amp;tag=vastwork-23">高扩展性网站的 50 条原则</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00F3Z26G8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00F3Z26G8&amp;linkCode=as2&amp;tag=vastwork-23">大型网站技术架构:核心原理与案例分析</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00EP6TGAU/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00EP6TGAU&amp;linkCode=as2&amp;tag=vastwork-23">恰如其分的软件架构：风险驱动的设计方法</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00CMMUXC4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00CMMUXC4&amp;linkCode=as2&amp;tag=vastwork-23">软件系统架构：使用视点和视角与利益相关者合作（第2版）</a>》</li>
</ul>
<h2 id="Linux-Unix"><a href="#Linux-Unix" class="headerlink" title="Linux / Unix"></a>Linux / Unix</h2><ul>
<li>《<a href="https://amazon.cn/gp/product/B00HLA8TYG/ref=as_li_qf_asin_il_tl?ie=UTF8&amp;tag=vastwork-23&amp;creative=3200&amp;linkCode=as2&amp;creativeASIN=B00HLA8TYG&amp;linkId=2d246600ae289155a09ec47545d584f6">Linux/Unix 系统编程手册</a>》（感谢<a href="https://github.com/geekgao">@geekgao</a> 的推荐）</li>
<li>《<a href="https://amazon.cn/gp/product/B00KMR129E/ref=as_li_qf_asin_il_tl?ie=UTF8&amp;tag=vastwork-23&amp;creative=3200&amp;linkCode=as2&amp;creativeASIN=B00KMR129E&amp;linkId=9655c290f9d97c4d7e80093839cc5944">Unix 环境高级编程(第3版)</a>》</li>
<li>《Unix/Linux 编程实践教程》</li>
<li>《<a href="https://amazon.cn/gp/product/B003TJNO98/ref=as_li_qf_asin_il_tl?ie=UTF8&amp;tag=vastwork-23&amp;creative=3200&amp;linkCode=as2&amp;creativeASIN=B003TJNO98&amp;linkId=dda37757175b431dedc5e20212021f21">鸟哥的 Linux 私房菜（基础学习篇）</a>》和《<a href="https://amazon.cn/gp/product/B008AEI8A2/ref=as_li_qf_asin_il_tl?ie=UTF8&amp;tag=vastwork-23&amp;creative=3200&amp;linkCode=as2&amp;creativeASIN=B008AEI8A2&amp;linkId=35f878fbebb2f66ae8c4fc3e76914ff6">鸟哥的 Linux 私房菜（服务器架设篇）</a>》</li>
<li>《<a href="https://amazon.cn/gp/product/B0719GT5W1/ref=as_li_qf_asin_il_tl?ie=UTF8&amp;tag=vastwork-23&amp;creative=3200&amp;linkCode=as2&amp;creativeASIN=B0719GT5W1&amp;linkId=aeef8bc8651bd9e5f363527b86d1229a">Linux 命令行与 shell 脚本编程大全（第3版）</a>》</li>
<li>《<a href="https://amazon.cn/gp/product/B00MB51SAI/ref=as_li_qf_asin_il_tl?ie=UTF8&amp;tag=vastwork-23&amp;creative=3200&amp;linkCode=as2&amp;creativeASIN=B00MB51SAI&amp;linkId=b22fe2eaac93168eae25d9bab11fe30c">只是为了好玩 : Linux 之父林纳斯自传</a>》</li>
</ul>
<h2 id="Web前端"><a href="#Web前端" class="headerlink" title="Web前端"></a>Web前端</h2><ul>
<li>《<a href="https://www.amazon.cn/gp/product/B013SGB2AO/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B013SGB2AO&amp;linkCode=as2&amp;tag=vastwork-23">高性能 JavaScript</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B0089TDFNS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0089TDFNS&amp;linkCode=as2&amp;tag=vastwork-23">锋利的 jQuery（第2版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B016DWSEWO/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B016DWSEWO&amp;linkCode=as2&amp;tag=vastwork-23">JavaScript 忍者秘籍</a>》（感谢<a href="https://github.com/jobbole/awesome-programming-books/issues?q=is%3Aissue+is%3Aopen+author%3Ajoker-danta">@joker-danta</a> 补充推荐）</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00BQ7RMW0/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00BQ7RMW0&amp;linkCode=as2&amp;tag=vastwork-23">编写可维护的 JavaScript</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00W34DZ8K/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00W34DZ8K&amp;linkCode=as2&amp;tag=vastwork-23">你不知道的 JavaScript（上）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B01LMYXGAI/ref=pd_sim_14_1?ie=UTF8&amp;psc=1&amp;refRID=4JRMK10EFJQHDAG8MCZF">你不知道的 JavaScript（中）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B007VISQ1Y/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B007VISQ1Y&amp;linkCode=as2&amp;tag=vastwork-23">JavaScript 权威指南（第6版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B0097CON2S/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0097CON2S&amp;linkCode=as2&amp;tag=vastwork-23">JavaScript 语言精粹（修订版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B004VJM5KE/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B004VJM5KE&amp;linkCode=as2&amp;tag=vastwork-23">JavaScript DOM编程艺术 （第2版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B007OQQVMY/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B007OQQVMY&amp;linkCode=as2&amp;tag=vastwork-23">JavaScript 高级程序设计（第3版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00JVLEYY2/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00JVLEYY2&amp;linkCode=as2&amp;tag=vastwork-23">JavaScript 异步编程：设计快速响应的网络应用</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00XJ2AU3S/ref=pd_bxgy_14_img_3?ie=UTF8&amp;psc=1&amp;refRID=4JRMK10EFJQHDAG8MCZF">JavaScript设计模式与开发实践</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B07574N7Y2/ref=pd_sim_14_7?ie=UTF8&amp;psc=1&amp;refRID=W48SJ7HFN2TXAQ1VAA8K">JavaScript框架设计（第2版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00GMXI1QY/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00GMXI1QY&amp;linkCode=as2&amp;tag=vastwork-23">Effective JavaScript：编写高质量JavaScript代码的68个有效方法</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00H706BIG/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00H706BIG&amp;linkCode=as2&amp;tag=vastwork-23">HTML5 权威指南</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B015316VJY/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B015316VJY&amp;linkCode=as2&amp;tag=vastwork-23">HTML5 秘籍（第2版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00K58535O/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00K58535O&amp;linkCode=as2&amp;tag=vastwork-23">HTML5 与 CSS3 基础教程（第八版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B01ET3FO86/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B01ET3FO86&amp;linkCode=as2&amp;tag=vastwork-23">CSS 揭秘</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00M2DKZ1W/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00M2DKZ1W&amp;linkCode=as2&amp;tag=vastwork-23">CSS 设计指南（第3版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B0011F5SIC/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0011F5SIC&amp;linkCode=as2&amp;tag=vastwork-23">CSS 权威指南（第3版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B01LXL42O5/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B01LXL42O5&amp;linkCode=as2&amp;tag=vastwork-23">深入浅出 HTML 与 CSS</a>》</li>
<li>《<a href="https://www.amazon.cn/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8-%E9%98%AE%E4%B8%80%E5%B3%B0/dp/B0755547ZZ/ref=sr_1_3?s=books&amp;ie=UTF8&amp;qid=1510299626&amp;sr=1-3&amp;keywords=Ecmascript">ES6 标准入门（第三版）</a>》</li>
<li>《<a href="https://www.amazon.cn/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6-Nicholas-C-Zakas/dp/B071GW3JDP/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1510299626&amp;sr=1-1&amp;keywords=Ecmascript">深入理解 ES6</a>》</li>
</ul>
<h2 id="Java开发"><a href="#Java开发" class="headerlink" title="Java开发"></a>Java开发</h2><ul>
<li>《<a href="https://www.amazon.cn/gp/product/B01ER75QC8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B01ER75QC8&amp;linkCode=as2&amp;tag=vastwork-23">Java8 实战</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B0077K9XHW/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0077K9XHW&amp;linkCode=as2&amp;tag=vastwork-23">Java并发编程实战</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B01DLB7Z66/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B01DLB7Z66&amp;linkCode=as2&amp;tag=vastwork-23">Java性能权威指南</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00E0D2OX4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00E0D2OX4&amp;linkCode=as2&amp;tag=vastwork-23">Java程序员修炼之道</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B017MEN094/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B017MEN094&amp;linkCode=as2&amp;tag=vastwork-23">实战Java高并发程序设计</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B0011F7WU4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0011F7WU4&amp;linkCode=as2&amp;tag=vastwork-23">Java编程思想 （第4版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B01HI0BUF8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B01HI0BUF8&amp;linkCode=as2&amp;tag=vastwork-23">深入理解Java虚拟机（第2版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B001PTGR52/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B001PTGR52&amp;linkCode=as2&amp;tag=vastwork-23">Effective java 中文版（第2版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B01M22BGUQ/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B01M22BGUQ&amp;linkCode=as2&amp;tag=vastwork-23">Java核心技术·卷1：基础知识（原书第9版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00IK7SM6O/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00IK7SM6O&amp;linkCode=as2&amp;tag=vastwork-23">Java核心技术·卷2：高级特性（原书第9版）</a>》</li>
</ul>
<h2 id="NET-NET-Core"><a href="#NET-NET-Core" class="headerlink" title=".NET/.NET Core"></a>.NET/.NET Core</h2><ul>
<li>《<a href="https://www.amazon.cn/C-6-0%E6%9C%AC%E8%B4%A8%E8%AE%BA-%E9%A9%AC%E5%85%8B%C2%B7%E7%B1%B3%E5%87%AF%E5%88%A9%E6%96%AF/dp/B01N7U95UK/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1510299751&amp;sr=1-1&amp;keywords=C%23+%E6%9C%AC%E8%B4%A8%E8%AE%BA">C# 6.0 本质论</a>》</li>
<li>《<a href="https://www.amazon.cn/%E6%9E%9C%E5%A3%B3%E4%B8%AD%E7%9A%84C-C-5-0%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E9%98%BF%E5%9D%9D%E5%93%88%E7%91%9E/dp/B00G51PUDA/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1510299796&amp;sr=1-1&amp;keywords=%E6%9E%9C%E5%A3%B3%E4%B8%AD%E7%9A%84C%23">果壳中的C#：C#5.0权威指南</a>》</li>
<li>《你必须知道的.NET（第2版）》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00J94AG2A/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00J94AG2A&amp;linkCode=as2&amp;tag=vastwork-23">深入理解C#（第3版）</a>》</li>
<li>《Effective C#: 50 Specific Ways to Improve Your C#, Third Edition》</li>
<li>《More Effective C# (Includes Content Update Program): 50 Specific Ways to Improve Your C#, 2nd edition》</li>
<li>《<a href="https://www.amazon.cn/Async-in-C-5-0-Unleash-the-Power-of-Async-Davies-Alex/dp/1449337163/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1510299899&amp;sr=1-1&amp;keywords=Async+in+C%23+5.0">Async in C# 5.0: Unleash the Power of Async</a>》</li>
<li>《<a href="https://www.amazon.cn/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B-%E5%85%8B%E5%88%A9%E9%87%8C/dp/B00QVLZEQ2/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1510299937&amp;sr=1-1&amp;keywords=C%23%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B">C#并发编程经典实例</a>》</li>
<li>《<a href="https://www.amazon.cn/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E6%98%93%E6%A0%BC%E6%81%A9%C2%B7%E9%98%BF%E6%A0%BC%E4%BD%9B%E6%B8%A9/dp/B06XHXV5FQ/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1510299974&amp;sr=1-1&amp;keywords=C%23%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98">C#多线程编程实战(原书第2版)</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00P8VZ8T4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00P8VZ8T4&amp;linkCode=as2&amp;tag=vastwork-23">CLR via C#（第4版）</a>》</li>
<li>《.NET本质论 第1卷:公共语言运行库》</li>
<li>《.NET探秘 : MSIL权威指南》</li>
<li>《Pro .NET Performance》</li>
<li>《Shared Source CLI Essentials》</li>
<li>《.NET 高级调试》</li>
<li>《Microsoft.NET 和 Windows 应用程序调试》</li>
<li>《微软.NET 程序的加密与解密》</li>
<li>《<a href="https://www.amazon.cn/NET-Development-Using-the-Compiler-API-Bock-Jason/dp/1484221109/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1510300116&amp;sr=1-1&amp;keywords=.NET+Development+Using+the+Compiler+API">.NET Development Using the Compiler API</a>》</li>
<li>《.NET设计规范 : 约定、惯用法与模式》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B074JS9HWX/ref=pd_sim_14_9?ie=UTF8&amp;psc=1&amp;refRID=67XZ7GZVFZ3J57NQTJ8X">编写高性能的.NET代码</a>》</li>
<li>《<a href="https://www.amazon.cn/Building-Microservices-with-NET-Core-Develop-skills-in-Reactive-Microservices-database-scaling-Azure-Microservices-and-more-Aroraa-Gaurav-Kumar/dp/B01MQ52RM3/ref=sr_1_10?s=books&amp;ie=UTF8&amp;qid=1510300439&amp;sr=1-10&amp;keywords=.net+core">Building Microservices with .NET Core</a>》</li>
<li>《<a href="https://www.amazon.cn/Microservices-in-NET-Core-with-Examples-in-NancyFX-Horsdal-Christian/dp/1617293377/ref=sr_1_15?s=books&amp;ie=UTF8&amp;qid=1510300439&amp;sr=1-15&amp;keywords=.net+core">Microservices in .NET Core, with Examples in NancyFX</a>》</li>
</ul>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><ul>
<li>《<a href="https://www.amazon.cn/gp/product/B00UI93JD8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00UI93JD8&amp;linkCode=as2&amp;tag=vastwork-23">集体智慧编程</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00P6OJ0TC/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00P6OJ0TC&amp;linkCode=as2&amp;tag=vastwork-23">笨办法学Python</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00KAFX65Q/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00KAFX65Q&amp;linkCode=as2&amp;tag=vastwork-23">Python基础教程</a>》</li>
<li>《Python源码剖析》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B007NB2B4M/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B007NB2B4M&amp;linkCode=as2&amp;tag=vastwork-23">Head First Python</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00HECW20S/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00HECW20S&amp;linkCode=as2&amp;tag=vastwork-23">与孩子一起学编程</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B004TUJ7A6/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B004TUJ7A6&amp;linkCode=as2&amp;tag=vastwork-23">Python学习手册（第4版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00WKR1OKG/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00WKR1OKG&amp;linkCode=as2&amp;tag=vastwork-23">Python Cookbook（第3版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B01MCUN37Y/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B01MCUN37Y&amp;linkCode=as2&amp;tag=vastwork-23">Python参考手册（第4版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B01FQAS0KK/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B01FQAS0KK&amp;linkCode=as2&amp;tag=vastwork-23">Python核心编程（第3版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B01HCVUJFA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B01HCVUJFA&amp;linkCode=as2&amp;tag=vastwork-23">Python科学计算（第2版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00GHGZLWS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00GHGZLWS&amp;linkCode=as2&amp;tag=vastwork-23">利用 Python 进行数据分析</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B01ION3W54/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B01ION3W54&amp;linkCode=as2&amp;tag=vastwork-23">Think Python：像计算机科学家一样思考Python（第2版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00MHDPIJ6/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00MHDPIJ6&amp;linkCode=as2&amp;tag=vastwork-23">Python编程实战:运用设计模式、并发和程序库创建高质量程序</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B019ZRGBVU/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B019ZRGBVU&amp;linkCode=as2&amp;tag=vastwork-23">Python绝技：运用Python成为顶级黑客</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B0153177A6/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0153177A6&amp;linkCode=as2&amp;tag=vastwork-23">Flask Web开发:基于Python的Web应用开发实战</a>》</li>
</ul>
<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><ul>
<li>《<a href="https://www.amazon.cn/gp/product/B01FSXCBOQ/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B01FSXCBOQ&amp;linkCode=as2&amp;tag=vastwork-23">Android编程权威指南（第2版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00SFZGX08/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00SFZGX08&amp;linkCode=as2&amp;tag=vastwork-23">移动应用UI设计模式（第2版）</a>》</li>
<li>《<a href="https://www.amazon.cn/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E4%BB%BB%E7%8E%89%E5%88%9A/dp/B014HV1X3K/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1478155289&amp;sr=1-1&amp;keywords=android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2">Android开发艺术探索</a>》</li>
</ul>
<h2 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h2><ul>
<li>《<a href="https://www.amazon.cn/gp/product/B00NKZCM3U/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00NKZCM3U&amp;linkCode=as2&amp;tag=vastwork-23">iOS编程实战</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B013UG2ULW/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B013UG2ULW&amp;linkCode=as2&amp;tag=vastwork-23">iOS编程（第4版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00DE60G3S/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00DE60G3S&amp;linkCode=as2&amp;tag=vastwork-23">Objective-C高级编程</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00IDSGY06/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00IDSGY06&amp;linkCode=as2&amp;tag=vastwork-23">Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法</a>》</li>
</ul>
<h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><ul>
<li>《<a href="https://www.amazon.cn/gp/product/B004R1QIJU/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B004R1QIJU&amp;linkCode=as2&amp;tag=vastwork-23">Head First PHP &amp; MySQL（中文版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B005D6IRRY/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B005D6IRRY&amp;linkCode=as2&amp;tag=vastwork-23">深入PHP：面向对象、模式与实践（第3版）</a>》</li>
</ul>
<h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h2><ul>
<li>《<a href="https://www.amazon.cn/gp/product/B00IZW4DK8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00IZW4DK8&amp;linkCode=as2&amp;tag=vastwork-23">C标准库</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00163LU68/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00163LU68&amp;linkCode=as2&amp;tag=vastwork-23">C和指针</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B0012NIW9K/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0012NIW9K&amp;linkCode=as2&amp;tag=vastwork-23">C专家编程</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B0012UMPBY/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0012UMPBY&amp;linkCode=as2&amp;tag=vastwork-23">C陷阱与缺陷</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B01D10NSCM/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B01D10NSCM&amp;linkCode=as2&amp;tag=vastwork-23">C语言接口与实现</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B0011425T8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0011425T8&amp;linkCode=as2&amp;tag=vastwork-23">C程序设计语言（第2版）</a>》</li>
<li>《C语言参考手册（第5版）》</li>
</ul>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><ul>
<li>《<a href="https://www.amazon.cn/gp/product/B00YLZIRHI/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00YLZIRHI&amp;linkCode=as2&amp;tag=vastwork-23">C++标准库</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B005CFUQR0/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B005CFUQR0&amp;linkCode=as2&amp;tag=vastwork-23">C++编程思想</a>》</li>
<li><span style="font-weight: normal;">《</span>C++语言的设计与演化<span style="font-weight: normal;">》</span></li>
<li>《<a href="https://www.amazon.cn/gp/product/B003VPX6YS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B003VPX6YS&amp;linkCode=as2&amp;tag=vastwork-23">C++程序设计原理与实践</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00ESUIL0O/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00ESUIL0O&amp;linkCode=as2&amp;tag=vastwork-23">C++ Primer （中文第5版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00S6U4C6E/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00S6U4C6E&amp;linkCode=as2&amp;tag=vastwork-23">C++ Primer习题集(第5版)</a> 》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B01I9BNASA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B01I9BNASA&amp;linkCode=as2&amp;tag=vastwork-23">C++程序设计语言(第1-3部分)(原书第4版)</a> 》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B004G72P24/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B004G72P24&amp;linkCode=as2&amp;tag=vastwork-23">Effective C++:改善程序与设计的55个具体做法(第3版)(中文版) </a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B004IP8BD6/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B004IP8BD6&amp;linkCode=as2&amp;tag=vastwork-23">More Effective C++:35个改善编程与设计的有效方法(中文版) </a>》<br>&nbsp;</li>
</ul>
<h2 id="机器学习和数据挖掘"><a href="#机器学习和数据挖掘" class="headerlink" title="机器学习和数据挖掘"></a>机器学习和数据挖掘</h2><ul>
<li>《<a href="https://www.amazon.cn/gp/product/B00JUE9DXW/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00JUE9DXW&amp;linkCode=as2&amp;tag=vastwork-23">数据之巅</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00NTM5GK0/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00NTM5GK0&amp;linkCode=as2&amp;tag=vastwork-23">矩阵分析</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B002WC7NH2/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B002WC7NH2&amp;linkCode=as2&amp;tag=vastwork-23">机器学习</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B007TSFMTA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B007TSFMTA&amp;linkCode=as2&amp;tag=vastwork-23">统计学习方法</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B01AG3ZV9K/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B01AG3ZV9K&amp;linkCode=as2&amp;tag=vastwork-23">机器学习导论</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B008AK5YJO/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B008AK5YJO&amp;linkCode=as2&amp;tag=vastwork-23">推荐系统实践</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00D747PTK/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00D747PTK&amp;linkCode=as2&amp;tag=vastwork-23">机器学习实战</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00AY830HS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00AY830HS&amp;linkCode=as2&amp;tag=vastwork-23">Web数据挖掘</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B006PHIVNA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B006PHIVNA&amp;linkCode=as2&amp;tag=vastwork-23">深入浅出统计学</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00116C3DY/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00116C3DY&amp;linkCode=as2&amp;tag=vastwork-23">模式分类（第2版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00264GG56/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00264GG56&amp;linkCode=as2&amp;tag=vastwork-23">概率论与数理统计</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00PRH2BXA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00PRH2BXA&amp;linkCode=as2&amp;tag=vastwork-23">统计学习基础(第2版)(英文)</a> 》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B007NR0T4A/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B007NR0T4A&amp;linkCode=as2&amp;tag=vastwork-23">数据挖掘：概念与技术（第3版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00K5I91WK/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00K5I91WK&amp;linkCode=as2&amp;tag=vastwork-23">数据挖掘：实用机器学习工具与技术（原书第3版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B011I34CGA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B011I34CGA&amp;linkCode=as2&amp;tag=vastwork-23">大数据：互联网大规模数据挖掘与分布式处理（第2版）</a>》</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul>
<li>《<a href="https://amazon.cn/gp/product/B007KYSEZC/ref=as_li_qf_asin_il_tl?ie=UTF8&amp;tag=vastwork-23&amp;creative=3200&amp;linkCode=as2&amp;creativeASIN=B007KYSEZC&amp;linkId=32d1830aaeeda5b1ccaf242af94e73ad">数据库系统概念</a>》 感谢<a href="https://github.com/noisnemid">@noisnemid</a> <a href="https://github.com/jobbole/awesome-programming-books/issues/16">推荐</a></li>
<li>《<a href="https://amazon.cn/gp/product/B003NX8D0A/ref=as_li_qf_asin_il_tl?ie=UTF8&amp;tag=vastwork-23&amp;creative=3200&amp;linkCode=as2&amp;creativeASIN=B003NX8D0A&amp;linkId=3d1723a92384a5febb43c2400b31f1fe">数据库系统实现</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00H6X6M1A/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00H6X6M1A&amp;linkCode=as2&amp;tag=vastwork-23">SQL应用重构</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/0596009763/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=0596009763&amp;linkCode=as2&amp;tag=vastwork-23">SQL Cookbook</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00C1W58DE/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00C1W58DE&amp;linkCode=as2&amp;tag=vastwork-23">高性能MySQL （第3版）</a>》</li>
<li>《深入浅出SQL（中文版）》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00ETOV48K/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00ETOV48K&amp;linkCode=as2&amp;tag=vastwork-23">MySQL技术内幕 : InnoDB存储引擎（第2版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00KR87J8G/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00KR87J8G&amp;linkCode=as2&amp;tag=vastwork-23">深入浅出MySQL : 数据库开发、优化与管理维护</a>》</li>
<li>《<a href="https://www.amazon.cn/%E6%94%B6%E8%8E%B7-%E4%B8%8D%E6%AD%A2SQL%E4%BC%98%E5%8C%96-%E6%8A%93%E4%BD%8FSQL%E7%9A%84%E6%9C%AC%E8%B4%A8-%E6%A2%81%E6%95%AC%E5%BD%AC/dp/B071S6ZYH8/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1510300270&amp;sr=1-1&amp;keywords=%E4%B8%8D%E6%AD%A2+sql">收获,不止SQL优化:抓住SQL的本质</a>》</li>
<li>《<a href="https://www.amazon.cn/SQL-Server%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E7%AE%A1%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF-%E9%BB%84%E9%92%8A%E5%90%89/dp/B00NW2FVAM/ref=tmm_pap_swatch_0?_encoding=UTF8&amp;qid=1510300294&amp;sr=1-8">SQL Server 性能优化与管理的艺术</a>》</li>
<li>《<a href="https://www.amazon.cn/SQL-Server%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98-%E9%99%88%E7%95%85%E4%BA%AE/dp/B0171JJEN6/ref=sr_1_11?s=books&amp;ie=UTF8&amp;qid=1510300294&amp;sr=1-11&amp;keywords=sql+server">SQL Server性能调优实战</a>》</li>
<li>《<a href="https://www.amazon.cn/T-SQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%A7%98%E7%AC%88-%E5%9F%BA%E4%BA%8ESQL-Server-2012%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0-%E6%9C%AC-%E7%94%98/dp/B00M1CH5A8/ref=sr_1_14?s=books&amp;ie=UTF8&amp;qid=1510300294&amp;sr=1-14&amp;keywords=sql+server">T-SQL性能调优秘笈:基于SQL Server 2012窗口函数</a>》</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul>
<li>《<a href="https://www.amazon.cn/gp/product/B003JBIV0S/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B003JBIV0S&amp;linkCode=as2&amp;tag=vastwork-23">探索式软件测试</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00PVOND2W/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00PVOND2W&amp;linkCode=as2&amp;tag=vastwork-23">有效的单元测试</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00FH36R6G/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00FH36R6G&amp;linkCode=as2&amp;tag=vastwork-23">Google软件测试之道</a>》</li>
</ul>
<h2 id="项目与团队"><a href="#项目与团队" class="headerlink" title="项目与团队"></a>项目与团队</h2><ul>
<li>《<a href="https://www.amazon.cn/gp/product/B00VR8ZO28/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00VR8ZO28&amp;linkCode=as2&amp;tag=vastwork-23">人月神话</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B001DBRWL0/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B001DBRWL0&amp;linkCode=as2&amp;tag=vastwork-23">快速软件开发</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00MO7R1SG/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00MO7R1SG&amp;linkCode=as2&amp;tag=vastwork-23">人件（原书第3版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00CBBKRQ8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00CBBKRQ8&amp;linkCode=as2&amp;tag=vastwork-23">门后的秘密：卓越管理的故事</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00BLZMG8W/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00BLZMG8W&amp;linkCode=as2&amp;tag=vastwork-23">极客与团队：软件工程师的团队生存秘笈</a>》</li>
<li>《<a href="https://amazon.cn/gp/product/B00EE5HBAO/ref=as_li_qf_asin_il_tl?ie=UTF8&amp;tag=vastwork-23&amp;creative=3200&amp;linkCode=as2&amp;creativeASIN=B00EE5HBAO&amp;linkId=d904f054b7a79a701065f544a449512b">硝烟中的 Scrum 和 XP</a>》 (感谢<a href="https://github.com/geekgao">@geekgao</a> 的推荐。</li>
</ul>
<h2 id="求职面试"><a href="#求职面试" class="headerlink" title="求职面试"></a>求职面试</h2><ul>
<li>《<a href="https://www.amazon.cn/gp/product/B00G8VOQOG/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00G8VOQOG&amp;linkCode=as2&amp;tag=vastwork-23">程序员面试金典（第5版）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00W5269HO/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00W5269HO&amp;linkCode=as2&amp;tag=vastwork-23">编程之美 : 微软技术面试心得</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00ALPRM7S/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00ALPRM7S&amp;linkCode=as2&amp;tag=vastwork-23">金领简历：敲开苹果、微软、谷歌的大门</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00L5LKMVU/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00L5LKMVU&amp;linkCode=as2&amp;tag=vastwork-23">剑指Offer：名企面试官精讲典型编程题（纪念版）</a>》</li>
</ul>
<h2 id="编程之外"><a href="#编程之外" class="headerlink" title="编程之外"></a>编程之外</h2><ul>
<li>《<a href="https://www.amazon.cn/gp/product/B005DSK4W8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B005DSK4W8&amp;linkCode=as2&amp;tag=vastwork-23">暗时间</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00P6OJ09C/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00P6OJ09C&amp;linkCode=as2&amp;tag=vastwork-23">数学之美</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00ANY9KZE/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00ANY9KZE&amp;linkCode=as2&amp;tag=vastwork-23">赢得朋友</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B008MIFWJG/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B008MIFWJG&amp;linkCode=as2&amp;tag=vastwork-23">精益创业</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00QPZARMA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00QPZARMA&amp;linkCode=as2&amp;tag=vastwork-23">批判性思维</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00M2DKZNA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00M2DKZNA&amp;linkCode=as2&amp;tag=vastwork-23">世界是数字的</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00A4H3JJS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00A4H3JJS&amp;linkCode=as2&amp;tag=vastwork-23">程序员的数学</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00N4LZ6RO/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00N4LZ6RO&amp;linkCode=as2&amp;tag=vastwork-23">程序员健康指南</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B005O4PUFC/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B005O4PUFC&amp;linkCode=as2&amp;tag=vastwork-23">禅与摩托车维修艺术</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B0081M8TZ2/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0081M8TZ2&amp;linkCode=as2&amp;tag=vastwork-23">关键对话：如何高效能沟通</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00EY8JUBO/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00EY8JUBO&amp;linkCode=as2&amp;tag=vastwork-23">写作法宝：非虚构写作指南</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00G1ZT2C0/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00G1ZT2C0&amp;linkCode=as2&amp;tag=vastwork-23">黑客与画家 : 来自计算机时代的高见</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00WDTQU8M/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00WDTQU8M&amp;linkCode=as2&amp;tag=vastwork-23">软件随想录（卷1）</a>》《<a href="https://www.amazon.cn/gp/product/B00WFT32FY/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00WFT32FY&amp;linkCode=as2&amp;tag=vastwork-23">软件随想录（卷2）</a>》</li>
<li>《<a href="https://www.amazon.cn/gp/product/B00ICWNKT6/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00ICWNKT6&amp;linkCode=as2&amp;tag=vastwork-23">如何把事情做到最好：改变全球9800万人的人生指导书</a>》</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>职业规划</tag>
        <tag>架构</tag>
        <tag>算法</tag>
        <tag>编程</tag>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
